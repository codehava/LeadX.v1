// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $RegionalOfficesTable extends RegionalOffices
    with TableInfo<$RegionalOfficesTable, RegionalOffice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RegionalOfficesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    description,
    address,
    latitude,
    longitude,
    phone,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'regional_offices';
  @override
  VerificationContext validateIntegrity(
    Insertable<RegionalOffice> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RegionalOffice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RegionalOffice(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $RegionalOfficesTable createAlias(String alias) {
    return $RegionalOfficesTable(attachedDatabase, alias);
  }
}

class RegionalOffice extends DataClass implements Insertable<RegionalOffice> {
  final String id;
  final String code;
  final String name;
  final String? description;
  final String? address;
  final double? latitude;
  final double? longitude;
  final String? phone;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const RegionalOffice({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    this.address,
    this.latitude,
    this.longitude,
    this.phone,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  RegionalOfficesCompanion toCompanion(bool nullToAbsent) {
    return RegionalOfficesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory RegionalOffice.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RegionalOffice(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      address: serializer.fromJson<String?>(json['address']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      phone: serializer.fromJson<String?>(json['phone']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'address': serializer.toJson<String?>(address),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'phone': serializer.toJson<String?>(phone),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  RegionalOffice copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    Value<String?> address = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => RegionalOffice(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    address: address.present ? address.value : this.address,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    phone: phone.present ? phone.value : this.phone,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  RegionalOffice copyWithCompanion(RegionalOfficesCompanion data) {
    return RegionalOffice(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      address: data.address.present ? data.address.value : this.address,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      phone: data.phone.present ? data.phone.value : this.phone,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RegionalOffice(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('address: $address, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    description,
    address,
    latitude,
    longitude,
    phone,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RegionalOffice &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.address == this.address &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.phone == this.phone &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class RegionalOfficesCompanion extends UpdateCompanion<RegionalOffice> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<String?> address;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> phone;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const RegionalOfficesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.address = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RegionalOfficesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.description = const Value.absent(),
    this.address = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<RegionalOffice> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? address,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? phone,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (address != null) 'address': address,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (phone != null) 'phone': phone,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RegionalOfficesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<String?>? address,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String?>? phone,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return RegionalOfficesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      address: address ?? this.address,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      phone: phone ?? this.phone,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RegionalOfficesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('address: $address, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BranchesTable extends Branches with TableInfo<$BranchesTable, Branche> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BranchesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _regionalOfficeIdMeta = const VerificationMeta(
    'regionalOfficeId',
  );
  @override
  late final GeneratedColumn<String> regionalOfficeId = GeneratedColumn<String>(
    'regional_office_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES regional_offices (id)',
    ),
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    regionalOfficeId,
    address,
    latitude,
    longitude,
    phone,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'branches';
  @override
  VerificationContext validateIntegrity(
    Insertable<Branche> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('regional_office_id')) {
      context.handle(
        _regionalOfficeIdMeta,
        regionalOfficeId.isAcceptableOrUnknown(
          data['regional_office_id']!,
          _regionalOfficeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_regionalOfficeIdMeta);
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Branche map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Branche(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      regionalOfficeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}regional_office_id'],
      )!,
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BranchesTable createAlias(String alias) {
    return $BranchesTable(attachedDatabase, alias);
  }
}

class Branche extends DataClass implements Insertable<Branche> {
  final String id;
  final String code;
  final String name;
  final String regionalOfficeId;
  final String? address;
  final double? latitude;
  final double? longitude;
  final String? phone;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Branche({
    required this.id,
    required this.code,
    required this.name,
    required this.regionalOfficeId,
    this.address,
    this.latitude,
    this.longitude,
    this.phone,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['regional_office_id'] = Variable<String>(regionalOfficeId);
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BranchesCompanion toCompanion(bool nullToAbsent) {
    return BranchesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      regionalOfficeId: Value(regionalOfficeId),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Branche.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Branche(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      regionalOfficeId: serializer.fromJson<String>(json['regionalOfficeId']),
      address: serializer.fromJson<String?>(json['address']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      phone: serializer.fromJson<String?>(json['phone']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'regionalOfficeId': serializer.toJson<String>(regionalOfficeId),
      'address': serializer.toJson<String?>(address),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'phone': serializer.toJson<String?>(phone),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Branche copyWith({
    String? id,
    String? code,
    String? name,
    String? regionalOfficeId,
    Value<String?> address = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Branche(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    regionalOfficeId: regionalOfficeId ?? this.regionalOfficeId,
    address: address.present ? address.value : this.address,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    phone: phone.present ? phone.value : this.phone,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Branche copyWithCompanion(BranchesCompanion data) {
    return Branche(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      regionalOfficeId: data.regionalOfficeId.present
          ? data.regionalOfficeId.value
          : this.regionalOfficeId,
      address: data.address.present ? data.address.value : this.address,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      phone: data.phone.present ? data.phone.value : this.phone,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Branche(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('regionalOfficeId: $regionalOfficeId, ')
          ..write('address: $address, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    regionalOfficeId,
    address,
    latitude,
    longitude,
    phone,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Branche &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.regionalOfficeId == this.regionalOfficeId &&
          other.address == this.address &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.phone == this.phone &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BranchesCompanion extends UpdateCompanion<Branche> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String> regionalOfficeId;
  final Value<String?> address;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> phone;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const BranchesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.regionalOfficeId = const Value.absent(),
    this.address = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BranchesCompanion.insert({
    required String id,
    required String code,
    required String name,
    required String regionalOfficeId,
    this.address = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       regionalOfficeId = Value(regionalOfficeId),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Branche> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? regionalOfficeId,
    Expression<String>? address,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? phone,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (regionalOfficeId != null) 'regional_office_id': regionalOfficeId,
      if (address != null) 'address': address,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (phone != null) 'phone': phone,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BranchesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String>? regionalOfficeId,
    Value<String?>? address,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String?>? phone,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return BranchesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      regionalOfficeId: regionalOfficeId ?? this.regionalOfficeId,
      address: address ?? this.address,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      phone: phone ?? this.phone,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (regionalOfficeId.present) {
      map['regional_office_id'] = Variable<String>(regionalOfficeId.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BranchesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('regionalOfficeId: $regionalOfficeId, ')
          ..write('address: $address, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nipMeta = const VerificationMeta('nip');
  @override
  late final GeneratedColumn<String> nip = GeneratedColumn<String>(
    'nip',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
    'role',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentIdMeta = const VerificationMeta(
    'parentId',
  );
  @override
  late final GeneratedColumn<String> parentId = GeneratedColumn<String>(
    'parent_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES branches (id)',
    ),
  );
  static const VerificationMeta _regionalOfficeIdMeta = const VerificationMeta(
    'regionalOfficeId',
  );
  @override
  late final GeneratedColumn<String> regionalOfficeId = GeneratedColumn<String>(
    'regional_office_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES regional_offices (id)',
    ),
  );
  static const VerificationMeta _photoUrlMeta = const VerificationMeta(
    'photoUrl',
  );
  @override
  late final GeneratedColumn<String> photoUrl = GeneratedColumn<String>(
    'photo_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _lastLoginAtMeta = const VerificationMeta(
    'lastLoginAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastLoginAt = GeneratedColumn<DateTime>(
    'last_login_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    email,
    name,
    nip,
    phone,
    role,
    parentId,
    branchId,
    regionalOfficeId,
    photoUrl,
    isActive,
    lastLoginAt,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(
    Insertable<User> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    } else if (isInserting) {
      context.missing(_emailMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('nip')) {
      context.handle(
        _nipMeta,
        nip.isAcceptableOrUnknown(data['nip']!, _nipMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('role')) {
      context.handle(
        _roleMeta,
        role.isAcceptableOrUnknown(data['role']!, _roleMeta),
      );
    } else if (isInserting) {
      context.missing(_roleMeta);
    }
    if (data.containsKey('parent_id')) {
      context.handle(
        _parentIdMeta,
        parentId.isAcceptableOrUnknown(data['parent_id']!, _parentIdMeta),
      );
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('regional_office_id')) {
      context.handle(
        _regionalOfficeIdMeta,
        regionalOfficeId.isAcceptableOrUnknown(
          data['regional_office_id']!,
          _regionalOfficeIdMeta,
        ),
      );
    }
    if (data.containsKey('photo_url')) {
      context.handle(
        _photoUrlMeta,
        photoUrl.isAcceptableOrUnknown(data['photo_url']!, _photoUrlMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('last_login_at')) {
      context.handle(
        _lastLoginAtMeta,
        lastLoginAt.isAcceptableOrUnknown(
          data['last_login_at']!,
          _lastLoginAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      nip: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nip'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      role: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role'],
      )!,
      parentId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_id'],
      ),
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      ),
      regionalOfficeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}regional_office_id'],
      ),
      photoUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}photo_url'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      lastLoginAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_login_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }
}

class User extends DataClass implements Insertable<User> {
  final String id;
  final String email;
  final String name;
  final String? nip;
  final String? phone;
  final String role;
  final String? parentId;
  final String? branchId;
  final String? regionalOfficeId;
  final String? photoUrl;
  final bool isActive;
  final DateTime? lastLoginAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const User({
    required this.id,
    required this.email,
    required this.name,
    this.nip,
    this.phone,
    required this.role,
    this.parentId,
    this.branchId,
    this.regionalOfficeId,
    this.photoUrl,
    required this.isActive,
    this.lastLoginAt,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['email'] = Variable<String>(email);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || nip != null) {
      map['nip'] = Variable<String>(nip);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['role'] = Variable<String>(role);
    if (!nullToAbsent || parentId != null) {
      map['parent_id'] = Variable<String>(parentId);
    }
    if (!nullToAbsent || branchId != null) {
      map['branch_id'] = Variable<String>(branchId);
    }
    if (!nullToAbsent || regionalOfficeId != null) {
      map['regional_office_id'] = Variable<String>(regionalOfficeId);
    }
    if (!nullToAbsent || photoUrl != null) {
      map['photo_url'] = Variable<String>(photoUrl);
    }
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || lastLoginAt != null) {
      map['last_login_at'] = Variable<DateTime>(lastLoginAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      id: Value(id),
      email: Value(email),
      name: Value(name),
      nip: nip == null && nullToAbsent ? const Value.absent() : Value(nip),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      role: Value(role),
      parentId: parentId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentId),
      branchId: branchId == null && nullToAbsent
          ? const Value.absent()
          : Value(branchId),
      regionalOfficeId: regionalOfficeId == null && nullToAbsent
          ? const Value.absent()
          : Value(regionalOfficeId),
      photoUrl: photoUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(photoUrl),
      isActive: Value(isActive),
      lastLoginAt: lastLoginAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLoginAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory User.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      id: serializer.fromJson<String>(json['id']),
      email: serializer.fromJson<String>(json['email']),
      name: serializer.fromJson<String>(json['name']),
      nip: serializer.fromJson<String?>(json['nip']),
      phone: serializer.fromJson<String?>(json['phone']),
      role: serializer.fromJson<String>(json['role']),
      parentId: serializer.fromJson<String?>(json['parentId']),
      branchId: serializer.fromJson<String?>(json['branchId']),
      regionalOfficeId: serializer.fromJson<String?>(json['regionalOfficeId']),
      photoUrl: serializer.fromJson<String?>(json['photoUrl']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      lastLoginAt: serializer.fromJson<DateTime?>(json['lastLoginAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'email': serializer.toJson<String>(email),
      'name': serializer.toJson<String>(name),
      'nip': serializer.toJson<String?>(nip),
      'phone': serializer.toJson<String?>(phone),
      'role': serializer.toJson<String>(role),
      'parentId': serializer.toJson<String?>(parentId),
      'branchId': serializer.toJson<String?>(branchId),
      'regionalOfficeId': serializer.toJson<String?>(regionalOfficeId),
      'photoUrl': serializer.toJson<String?>(photoUrl),
      'isActive': serializer.toJson<bool>(isActive),
      'lastLoginAt': serializer.toJson<DateTime?>(lastLoginAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  User copyWith({
    String? id,
    String? email,
    String? name,
    Value<String?> nip = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    String? role,
    Value<String?> parentId = const Value.absent(),
    Value<String?> branchId = const Value.absent(),
    Value<String?> regionalOfficeId = const Value.absent(),
    Value<String?> photoUrl = const Value.absent(),
    bool? isActive,
    Value<DateTime?> lastLoginAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => User(
    id: id ?? this.id,
    email: email ?? this.email,
    name: name ?? this.name,
    nip: nip.present ? nip.value : this.nip,
    phone: phone.present ? phone.value : this.phone,
    role: role ?? this.role,
    parentId: parentId.present ? parentId.value : this.parentId,
    branchId: branchId.present ? branchId.value : this.branchId,
    regionalOfficeId: regionalOfficeId.present
        ? regionalOfficeId.value
        : this.regionalOfficeId,
    photoUrl: photoUrl.present ? photoUrl.value : this.photoUrl,
    isActive: isActive ?? this.isActive,
    lastLoginAt: lastLoginAt.present ? lastLoginAt.value : this.lastLoginAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  User copyWithCompanion(UsersCompanion data) {
    return User(
      id: data.id.present ? data.id.value : this.id,
      email: data.email.present ? data.email.value : this.email,
      name: data.name.present ? data.name.value : this.name,
      nip: data.nip.present ? data.nip.value : this.nip,
      phone: data.phone.present ? data.phone.value : this.phone,
      role: data.role.present ? data.role.value : this.role,
      parentId: data.parentId.present ? data.parentId.value : this.parentId,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      regionalOfficeId: data.regionalOfficeId.present
          ? data.regionalOfficeId.value
          : this.regionalOfficeId,
      photoUrl: data.photoUrl.present ? data.photoUrl.value : this.photoUrl,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      lastLoginAt: data.lastLoginAt.present
          ? data.lastLoginAt.value
          : this.lastLoginAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('id: $id, ')
          ..write('email: $email, ')
          ..write('name: $name, ')
          ..write('nip: $nip, ')
          ..write('phone: $phone, ')
          ..write('role: $role, ')
          ..write('parentId: $parentId, ')
          ..write('branchId: $branchId, ')
          ..write('regionalOfficeId: $regionalOfficeId, ')
          ..write('photoUrl: $photoUrl, ')
          ..write('isActive: $isActive, ')
          ..write('lastLoginAt: $lastLoginAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    email,
    name,
    nip,
    phone,
    role,
    parentId,
    branchId,
    regionalOfficeId,
    photoUrl,
    isActive,
    lastLoginAt,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.id == this.id &&
          other.email == this.email &&
          other.name == this.name &&
          other.nip == this.nip &&
          other.phone == this.phone &&
          other.role == this.role &&
          other.parentId == this.parentId &&
          other.branchId == this.branchId &&
          other.regionalOfficeId == this.regionalOfficeId &&
          other.photoUrl == this.photoUrl &&
          other.isActive == this.isActive &&
          other.lastLoginAt == this.lastLoginAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<String> id;
  final Value<String> email;
  final Value<String> name;
  final Value<String?> nip;
  final Value<String?> phone;
  final Value<String> role;
  final Value<String?> parentId;
  final Value<String?> branchId;
  final Value<String?> regionalOfficeId;
  final Value<String?> photoUrl;
  final Value<bool> isActive;
  final Value<DateTime?> lastLoginAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const UsersCompanion({
    this.id = const Value.absent(),
    this.email = const Value.absent(),
    this.name = const Value.absent(),
    this.nip = const Value.absent(),
    this.phone = const Value.absent(),
    this.role = const Value.absent(),
    this.parentId = const Value.absent(),
    this.branchId = const Value.absent(),
    this.regionalOfficeId = const Value.absent(),
    this.photoUrl = const Value.absent(),
    this.isActive = const Value.absent(),
    this.lastLoginAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UsersCompanion.insert({
    required String id,
    required String email,
    required String name,
    this.nip = const Value.absent(),
    this.phone = const Value.absent(),
    required String role,
    this.parentId = const Value.absent(),
    this.branchId = const Value.absent(),
    this.regionalOfficeId = const Value.absent(),
    this.photoUrl = const Value.absent(),
    this.isActive = const Value.absent(),
    this.lastLoginAt = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       email = Value(email),
       name = Value(name),
       role = Value(role),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<User> custom({
    Expression<String>? id,
    Expression<String>? email,
    Expression<String>? name,
    Expression<String>? nip,
    Expression<String>? phone,
    Expression<String>? role,
    Expression<String>? parentId,
    Expression<String>? branchId,
    Expression<String>? regionalOfficeId,
    Expression<String>? photoUrl,
    Expression<bool>? isActive,
    Expression<DateTime>? lastLoginAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (email != null) 'email': email,
      if (name != null) 'name': name,
      if (nip != null) 'nip': nip,
      if (phone != null) 'phone': phone,
      if (role != null) 'role': role,
      if (parentId != null) 'parent_id': parentId,
      if (branchId != null) 'branch_id': branchId,
      if (regionalOfficeId != null) 'regional_office_id': regionalOfficeId,
      if (photoUrl != null) 'photo_url': photoUrl,
      if (isActive != null) 'is_active': isActive,
      if (lastLoginAt != null) 'last_login_at': lastLoginAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UsersCompanion copyWith({
    Value<String>? id,
    Value<String>? email,
    Value<String>? name,
    Value<String?>? nip,
    Value<String?>? phone,
    Value<String>? role,
    Value<String?>? parentId,
    Value<String?>? branchId,
    Value<String?>? regionalOfficeId,
    Value<String?>? photoUrl,
    Value<bool>? isActive,
    Value<DateTime?>? lastLoginAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return UsersCompanion(
      id: id ?? this.id,
      email: email ?? this.email,
      name: name ?? this.name,
      nip: nip ?? this.nip,
      phone: phone ?? this.phone,
      role: role ?? this.role,
      parentId: parentId ?? this.parentId,
      branchId: branchId ?? this.branchId,
      regionalOfficeId: regionalOfficeId ?? this.regionalOfficeId,
      photoUrl: photoUrl ?? this.photoUrl,
      isActive: isActive ?? this.isActive,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (nip.present) {
      map['nip'] = Variable<String>(nip.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (parentId.present) {
      map['parent_id'] = Variable<String>(parentId.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (regionalOfficeId.present) {
      map['regional_office_id'] = Variable<String>(regionalOfficeId.value);
    }
    if (photoUrl.present) {
      map['photo_url'] = Variable<String>(photoUrl.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (lastLoginAt.present) {
      map['last_login_at'] = Variable<DateTime>(lastLoginAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('id: $id, ')
          ..write('email: $email, ')
          ..write('name: $name, ')
          ..write('nip: $nip, ')
          ..write('phone: $phone, ')
          ..write('role: $role, ')
          ..write('parentId: $parentId, ')
          ..write('branchId: $branchId, ')
          ..write('regionalOfficeId: $regionalOfficeId, ')
          ..write('photoUrl: $photoUrl, ')
          ..write('isActive: $isActive, ')
          ..write('lastLoginAt: $lastLoginAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserHierarchyTable extends UserHierarchy
    with TableInfo<$UserHierarchyTable, UserHierarchyData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserHierarchyTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _ancestorIdMeta = const VerificationMeta(
    'ancestorId',
  );
  @override
  late final GeneratedColumn<String> ancestorId = GeneratedColumn<String>(
    'ancestor_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _descendantIdMeta = const VerificationMeta(
    'descendantId',
  );
  @override
  late final GeneratedColumn<String> descendantId = GeneratedColumn<String>(
    'descendant_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _depthMeta = const VerificationMeta('depth');
  @override
  late final GeneratedColumn<int> depth = GeneratedColumn<int>(
    'depth',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [ancestorId, descendantId, depth];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_hierarchy';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserHierarchyData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('ancestor_id')) {
      context.handle(
        _ancestorIdMeta,
        ancestorId.isAcceptableOrUnknown(data['ancestor_id']!, _ancestorIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ancestorIdMeta);
    }
    if (data.containsKey('descendant_id')) {
      context.handle(
        _descendantIdMeta,
        descendantId.isAcceptableOrUnknown(
          data['descendant_id']!,
          _descendantIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_descendantIdMeta);
    }
    if (data.containsKey('depth')) {
      context.handle(
        _depthMeta,
        depth.isAcceptableOrUnknown(data['depth']!, _depthMeta),
      );
    } else if (isInserting) {
      context.missing(_depthMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {ancestorId, descendantId};
  @override
  UserHierarchyData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserHierarchyData(
      ancestorId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ancestor_id'],
      )!,
      descendantId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}descendant_id'],
      )!,
      depth: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}depth'],
      )!,
    );
  }

  @override
  $UserHierarchyTable createAlias(String alias) {
    return $UserHierarchyTable(attachedDatabase, alias);
  }
}

class UserHierarchyData extends DataClass
    implements Insertable<UserHierarchyData> {
  final String ancestorId;
  final String descendantId;
  final int depth;
  const UserHierarchyData({
    required this.ancestorId,
    required this.descendantId,
    required this.depth,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['ancestor_id'] = Variable<String>(ancestorId);
    map['descendant_id'] = Variable<String>(descendantId);
    map['depth'] = Variable<int>(depth);
    return map;
  }

  UserHierarchyCompanion toCompanion(bool nullToAbsent) {
    return UserHierarchyCompanion(
      ancestorId: Value(ancestorId),
      descendantId: Value(descendantId),
      depth: Value(depth),
    );
  }

  factory UserHierarchyData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserHierarchyData(
      ancestorId: serializer.fromJson<String>(json['ancestorId']),
      descendantId: serializer.fromJson<String>(json['descendantId']),
      depth: serializer.fromJson<int>(json['depth']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'ancestorId': serializer.toJson<String>(ancestorId),
      'descendantId': serializer.toJson<String>(descendantId),
      'depth': serializer.toJson<int>(depth),
    };
  }

  UserHierarchyData copyWith({
    String? ancestorId,
    String? descendantId,
    int? depth,
  }) => UserHierarchyData(
    ancestorId: ancestorId ?? this.ancestorId,
    descendantId: descendantId ?? this.descendantId,
    depth: depth ?? this.depth,
  );
  UserHierarchyData copyWithCompanion(UserHierarchyCompanion data) {
    return UserHierarchyData(
      ancestorId: data.ancestorId.present
          ? data.ancestorId.value
          : this.ancestorId,
      descendantId: data.descendantId.present
          ? data.descendantId.value
          : this.descendantId,
      depth: data.depth.present ? data.depth.value : this.depth,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserHierarchyData(')
          ..write('ancestorId: $ancestorId, ')
          ..write('descendantId: $descendantId, ')
          ..write('depth: $depth')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(ancestorId, descendantId, depth);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserHierarchyData &&
          other.ancestorId == this.ancestorId &&
          other.descendantId == this.descendantId &&
          other.depth == this.depth);
}

class UserHierarchyCompanion extends UpdateCompanion<UserHierarchyData> {
  final Value<String> ancestorId;
  final Value<String> descendantId;
  final Value<int> depth;
  final Value<int> rowid;
  const UserHierarchyCompanion({
    this.ancestorId = const Value.absent(),
    this.descendantId = const Value.absent(),
    this.depth = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserHierarchyCompanion.insert({
    required String ancestorId,
    required String descendantId,
    required int depth,
    this.rowid = const Value.absent(),
  }) : ancestorId = Value(ancestorId),
       descendantId = Value(descendantId),
       depth = Value(depth);
  static Insertable<UserHierarchyData> custom({
    Expression<String>? ancestorId,
    Expression<String>? descendantId,
    Expression<int>? depth,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (ancestorId != null) 'ancestor_id': ancestorId,
      if (descendantId != null) 'descendant_id': descendantId,
      if (depth != null) 'depth': depth,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserHierarchyCompanion copyWith({
    Value<String>? ancestorId,
    Value<String>? descendantId,
    Value<int>? depth,
    Value<int>? rowid,
  }) {
    return UserHierarchyCompanion(
      ancestorId: ancestorId ?? this.ancestorId,
      descendantId: descendantId ?? this.descendantId,
      depth: depth ?? this.depth,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (ancestorId.present) {
      map['ancestor_id'] = Variable<String>(ancestorId.value);
    }
    if (descendantId.present) {
      map['descendant_id'] = Variable<String>(descendantId.value);
    }
    if (depth.present) {
      map['depth'] = Variable<int>(depth.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserHierarchyCompanion(')
          ..write('ancestorId: $ancestorId, ')
          ..write('descendantId: $descendantId, ')
          ..write('depth: $depth, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProvincesTable extends Provinces
    with TableInfo<$ProvincesTable, Province> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProvincesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [id, code, name, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'provinces';
  @override
  VerificationContext validateIntegrity(
    Insertable<Province> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Province map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Province(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $ProvincesTable createAlias(String alias) {
    return $ProvincesTable(attachedDatabase, alias);
  }
}

class Province extends DataClass implements Insertable<Province> {
  final String id;
  final String code;
  final String name;
  final bool isActive;
  const Province({
    required this.id,
    required this.code,
    required this.name,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  ProvincesCompanion toCompanion(bool nullToAbsent) {
    return ProvincesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      isActive: Value(isActive),
    );
  }

  factory Province.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Province(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  Province copyWith({String? id, String? code, String? name, bool? isActive}) =>
      Province(
        id: id ?? this.id,
        code: code ?? this.code,
        name: name ?? this.name,
        isActive: isActive ?? this.isActive,
      );
  Province copyWithCompanion(ProvincesCompanion data) {
    return Province(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Province(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, code, name, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Province &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.isActive == this.isActive);
}

class ProvincesCompanion extends UpdateCompanion<Province> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<bool> isActive;
  final Value<int> rowid;
  const ProvincesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProvincesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<Province> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProvincesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return ProvincesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProvincesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CitiesTable extends Cities with TableInfo<$CitiesTable, City> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _provinceIdMeta = const VerificationMeta(
    'provinceId',
  );
  @override
  late final GeneratedColumn<String> provinceId = GeneratedColumn<String>(
    'province_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES provinces (id)',
    ),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [id, code, name, provinceId, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cities';
  @override
  VerificationContext validateIntegrity(
    Insertable<City> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('province_id')) {
      context.handle(
        _provinceIdMeta,
        provinceId.isAcceptableOrUnknown(data['province_id']!, _provinceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_provinceIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  City map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return City(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      provinceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}province_id'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $CitiesTable createAlias(String alias) {
    return $CitiesTable(attachedDatabase, alias);
  }
}

class City extends DataClass implements Insertable<City> {
  final String id;
  final String code;
  final String name;
  final String provinceId;
  final bool isActive;
  const City({
    required this.id,
    required this.code,
    required this.name,
    required this.provinceId,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['province_id'] = Variable<String>(provinceId);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  CitiesCompanion toCompanion(bool nullToAbsent) {
    return CitiesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      provinceId: Value(provinceId),
      isActive: Value(isActive),
    );
  }

  factory City.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return City(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      provinceId: serializer.fromJson<String>(json['provinceId']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'provinceId': serializer.toJson<String>(provinceId),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  City copyWith({
    String? id,
    String? code,
    String? name,
    String? provinceId,
    bool? isActive,
  }) => City(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    provinceId: provinceId ?? this.provinceId,
    isActive: isActive ?? this.isActive,
  );
  City copyWithCompanion(CitiesCompanion data) {
    return City(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      provinceId: data.provinceId.present
          ? data.provinceId.value
          : this.provinceId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('City(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('provinceId: $provinceId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, code, name, provinceId, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is City &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.provinceId == this.provinceId &&
          other.isActive == this.isActive);
}

class CitiesCompanion extends UpdateCompanion<City> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String> provinceId;
  final Value<bool> isActive;
  final Value<int> rowid;
  const CitiesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.provinceId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CitiesCompanion.insert({
    required String id,
    required String code,
    required String name,
    required String provinceId,
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       provinceId = Value(provinceId);
  static Insertable<City> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? provinceId,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (provinceId != null) 'province_id': provinceId,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CitiesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String>? provinceId,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return CitiesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      provinceId: provinceId ?? this.provinceId,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (provinceId.present) {
      map['province_id'] = Variable<String>(provinceId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CitiesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('provinceId: $provinceId, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CompanyTypesTable extends CompanyTypes
    with TableInfo<$CompanyTypesTable, CompanyType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CompanyTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [id, code, name, sortOrder, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'company_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<CompanyType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CompanyType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CompanyType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $CompanyTypesTable createAlias(String alias) {
    return $CompanyTypesTable(attachedDatabase, alias);
  }
}

class CompanyType extends DataClass implements Insertable<CompanyType> {
  final String id;
  final String code;
  final String name;
  final int sortOrder;
  final bool isActive;
  const CompanyType({
    required this.id,
    required this.code,
    required this.name,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  CompanyTypesCompanion toCompanion(bool nullToAbsent) {
    return CompanyTypesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory CompanyType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CompanyType(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  CompanyType copyWith({
    String? id,
    String? code,
    String? name,
    int? sortOrder,
    bool? isActive,
  }) => CompanyType(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  CompanyType copyWithCompanion(CompanyTypesCompanion data) {
    return CompanyType(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CompanyType(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, code, name, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CompanyType &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class CompanyTypesCompanion extends UpdateCompanion<CompanyType> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const CompanyTypesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CompanyTypesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<CompanyType> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CompanyTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return CompanyTypesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CompanyTypesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OwnershipTypesTable extends OwnershipTypes
    with TableInfo<$OwnershipTypesTable, OwnershipType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OwnershipTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [id, code, name, sortOrder, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ownership_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<OwnershipType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OwnershipType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OwnershipType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $OwnershipTypesTable createAlias(String alias) {
    return $OwnershipTypesTable(attachedDatabase, alias);
  }
}

class OwnershipType extends DataClass implements Insertable<OwnershipType> {
  final String id;
  final String code;
  final String name;
  final int sortOrder;
  final bool isActive;
  const OwnershipType({
    required this.id,
    required this.code,
    required this.name,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  OwnershipTypesCompanion toCompanion(bool nullToAbsent) {
    return OwnershipTypesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory OwnershipType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OwnershipType(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  OwnershipType copyWith({
    String? id,
    String? code,
    String? name,
    int? sortOrder,
    bool? isActive,
  }) => OwnershipType(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  OwnershipType copyWithCompanion(OwnershipTypesCompanion data) {
    return OwnershipType(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OwnershipType(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, code, name, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OwnershipType &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class OwnershipTypesCompanion extends UpdateCompanion<OwnershipType> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const OwnershipTypesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OwnershipTypesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<OwnershipType> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OwnershipTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return OwnershipTypesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OwnershipTypesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $IndustriesTable extends Industries
    with TableInfo<$IndustriesTable, Industry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IndustriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [id, code, name, sortOrder, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'industries';
  @override
  VerificationContext validateIntegrity(
    Insertable<Industry> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Industry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Industry(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $IndustriesTable createAlias(String alias) {
    return $IndustriesTable(attachedDatabase, alias);
  }
}

class Industry extends DataClass implements Insertable<Industry> {
  final String id;
  final String code;
  final String name;
  final int sortOrder;
  final bool isActive;
  const Industry({
    required this.id,
    required this.code,
    required this.name,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  IndustriesCompanion toCompanion(bool nullToAbsent) {
    return IndustriesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory Industry.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Industry(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  Industry copyWith({
    String? id,
    String? code,
    String? name,
    int? sortOrder,
    bool? isActive,
  }) => Industry(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  Industry copyWithCompanion(IndustriesCompanion data) {
    return Industry(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Industry(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, code, name, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Industry &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class IndustriesCompanion extends UpdateCompanion<Industry> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const IndustriesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IndustriesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<Industry> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IndustriesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return IndustriesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IndustriesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CobsTable extends Cobs with TableInfo<$CobsTable, Cob> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CobsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    description,
    sortOrder,
    isActive,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cobs';
  @override
  VerificationContext validateIntegrity(
    Insertable<Cob> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Cob map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Cob(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $CobsTable createAlias(String alias) {
    return $CobsTable(attachedDatabase, alias);
  }
}

class Cob extends DataClass implements Insertable<Cob> {
  final String id;
  final String code;
  final String name;
  final String? description;
  final int sortOrder;
  final bool isActive;
  const Cob({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  CobsCompanion toCompanion(bool nullToAbsent) {
    return CobsCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory Cob.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Cob(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  Cob copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    int? sortOrder,
    bool? isActive,
  }) => Cob(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  Cob copyWithCompanion(CobsCompanion data) {
    return Cob(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Cob(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, code, name, description, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Cob &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class CobsCompanion extends UpdateCompanion<Cob> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const CobsCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CobsCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<Cob> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CobsCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return CobsCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CobsCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LobsTable extends Lobs with TableInfo<$LobsTable, Lob> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LobsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _cobIdMeta = const VerificationMeta('cobId');
  @override
  late final GeneratedColumn<String> cobId = GeneratedColumn<String>(
    'cob_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES cobs (id)',
    ),
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    cobId,
    code,
    name,
    description,
    sortOrder,
    isActive,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'lobs';
  @override
  VerificationContext validateIntegrity(
    Insertable<Lob> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('cob_id')) {
      context.handle(
        _cobIdMeta,
        cobId.isAcceptableOrUnknown(data['cob_id']!, _cobIdMeta),
      );
    } else if (isInserting) {
      context.missing(_cobIdMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Lob map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Lob(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      cobId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cob_id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $LobsTable createAlias(String alias) {
    return $LobsTable(attachedDatabase, alias);
  }
}

class Lob extends DataClass implements Insertable<Lob> {
  final String id;
  final String cobId;
  final String code;
  final String name;
  final String? description;
  final int sortOrder;
  final bool isActive;
  const Lob({
    required this.id,
    required this.cobId,
    required this.code,
    required this.name,
    this.description,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['cob_id'] = Variable<String>(cobId);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  LobsCompanion toCompanion(bool nullToAbsent) {
    return LobsCompanion(
      id: Value(id),
      cobId: Value(cobId),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory Lob.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Lob(
      id: serializer.fromJson<String>(json['id']),
      cobId: serializer.fromJson<String>(json['cobId']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'cobId': serializer.toJson<String>(cobId),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  Lob copyWith({
    String? id,
    String? cobId,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    int? sortOrder,
    bool? isActive,
  }) => Lob(
    id: id ?? this.id,
    cobId: cobId ?? this.cobId,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  Lob copyWithCompanion(LobsCompanion data) {
    return Lob(
      id: data.id.present ? data.id.value : this.id,
      cobId: data.cobId.present ? data.cobId.value : this.cobId,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Lob(')
          ..write('id: $id, ')
          ..write('cobId: $cobId, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, cobId, code, name, description, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Lob &&
          other.id == this.id &&
          other.cobId == this.cobId &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class LobsCompanion extends UpdateCompanion<Lob> {
  final Value<String> id;
  final Value<String> cobId;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const LobsCompanion({
    this.id = const Value.absent(),
    this.cobId = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LobsCompanion.insert({
    required String id,
    required String cobId,
    required String code,
    required String name,
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       cobId = Value(cobId),
       code = Value(code),
       name = Value(name);
  static Insertable<Lob> custom({
    Expression<String>? id,
    Expression<String>? cobId,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (cobId != null) 'cob_id': cobId,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LobsCompanion copyWith({
    Value<String>? id,
    Value<String>? cobId,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return LobsCompanion(
      id: id ?? this.id,
      cobId: cobId ?? this.cobId,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (cobId.present) {
      map['cob_id'] = Variable<String>(cobId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LobsCompanion(')
          ..write('id: $id, ')
          ..write('cobId: $cobId, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PipelineStagesTable extends PipelineStages
    with TableInfo<$PipelineStagesTable, PipelineStage> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PipelineStagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _probabilityMeta = const VerificationMeta(
    'probability',
  );
  @override
  late final GeneratedColumn<int> probability = GeneratedColumn<int>(
    'probability',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sequenceMeta = const VerificationMeta(
    'sequence',
  );
  @override
  late final GeneratedColumn<int> sequence = GeneratedColumn<int>(
    'sequence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFinalMeta = const VerificationMeta(
    'isFinal',
  );
  @override
  late final GeneratedColumn<bool> isFinal = GeneratedColumn<bool>(
    'is_final',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_final" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isWonMeta = const VerificationMeta('isWon');
  @override
  late final GeneratedColumn<bool> isWon = GeneratedColumn<bool>(
    'is_won',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_won" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    probability,
    sequence,
    color,
    isFinal,
    isWon,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pipeline_stages';
  @override
  VerificationContext validateIntegrity(
    Insertable<PipelineStage> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('probability')) {
      context.handle(
        _probabilityMeta,
        probability.isAcceptableOrUnknown(
          data['probability']!,
          _probabilityMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_probabilityMeta);
    }
    if (data.containsKey('sequence')) {
      context.handle(
        _sequenceMeta,
        sequence.isAcceptableOrUnknown(data['sequence']!, _sequenceMeta),
      );
    } else if (isInserting) {
      context.missing(_sequenceMeta);
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('is_final')) {
      context.handle(
        _isFinalMeta,
        isFinal.isAcceptableOrUnknown(data['is_final']!, _isFinalMeta),
      );
    }
    if (data.containsKey('is_won')) {
      context.handle(
        _isWonMeta,
        isWon.isAcceptableOrUnknown(data['is_won']!, _isWonMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PipelineStage map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PipelineStage(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      probability: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}probability'],
      )!,
      sequence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence'],
      )!,
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      ),
      isFinal: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_final'],
      )!,
      isWon: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_won'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PipelineStagesTable createAlias(String alias) {
    return $PipelineStagesTable(attachedDatabase, alias);
  }
}

class PipelineStage extends DataClass implements Insertable<PipelineStage> {
  final String id;
  final String code;
  final String name;
  final int probability;
  final int sequence;
  final String? color;
  final bool isFinal;
  final bool isWon;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PipelineStage({
    required this.id,
    required this.code,
    required this.name,
    required this.probability,
    required this.sequence,
    this.color,
    required this.isFinal,
    required this.isWon,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['probability'] = Variable<int>(probability);
    map['sequence'] = Variable<int>(sequence);
    if (!nullToAbsent || color != null) {
      map['color'] = Variable<String>(color);
    }
    map['is_final'] = Variable<bool>(isFinal);
    map['is_won'] = Variable<bool>(isWon);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PipelineStagesCompanion toCompanion(bool nullToAbsent) {
    return PipelineStagesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      probability: Value(probability),
      sequence: Value(sequence),
      color: color == null && nullToAbsent
          ? const Value.absent()
          : Value(color),
      isFinal: Value(isFinal),
      isWon: Value(isWon),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PipelineStage.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PipelineStage(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      probability: serializer.fromJson<int>(json['probability']),
      sequence: serializer.fromJson<int>(json['sequence']),
      color: serializer.fromJson<String?>(json['color']),
      isFinal: serializer.fromJson<bool>(json['isFinal']),
      isWon: serializer.fromJson<bool>(json['isWon']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'probability': serializer.toJson<int>(probability),
      'sequence': serializer.toJson<int>(sequence),
      'color': serializer.toJson<String?>(color),
      'isFinal': serializer.toJson<bool>(isFinal),
      'isWon': serializer.toJson<bool>(isWon),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  PipelineStage copyWith({
    String? id,
    String? code,
    String? name,
    int? probability,
    int? sequence,
    Value<String?> color = const Value.absent(),
    bool? isFinal,
    bool? isWon,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => PipelineStage(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    probability: probability ?? this.probability,
    sequence: sequence ?? this.sequence,
    color: color.present ? color.value : this.color,
    isFinal: isFinal ?? this.isFinal,
    isWon: isWon ?? this.isWon,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PipelineStage copyWithCompanion(PipelineStagesCompanion data) {
    return PipelineStage(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      probability: data.probability.present
          ? data.probability.value
          : this.probability,
      sequence: data.sequence.present ? data.sequence.value : this.sequence,
      color: data.color.present ? data.color.value : this.color,
      isFinal: data.isFinal.present ? data.isFinal.value : this.isFinal,
      isWon: data.isWon.present ? data.isWon.value : this.isWon,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PipelineStage(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('probability: $probability, ')
          ..write('sequence: $sequence, ')
          ..write('color: $color, ')
          ..write('isFinal: $isFinal, ')
          ..write('isWon: $isWon, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    probability,
    sequence,
    color,
    isFinal,
    isWon,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PipelineStage &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.probability == this.probability &&
          other.sequence == this.sequence &&
          other.color == this.color &&
          other.isFinal == this.isFinal &&
          other.isWon == this.isWon &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PipelineStagesCompanion extends UpdateCompanion<PipelineStage> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<int> probability;
  final Value<int> sequence;
  final Value<String?> color;
  final Value<bool> isFinal;
  final Value<bool> isWon;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const PipelineStagesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.probability = const Value.absent(),
    this.sequence = const Value.absent(),
    this.color = const Value.absent(),
    this.isFinal = const Value.absent(),
    this.isWon = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PipelineStagesCompanion.insert({
    required String id,
    required String code,
    required String name,
    required int probability,
    required int sequence,
    this.color = const Value.absent(),
    this.isFinal = const Value.absent(),
    this.isWon = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       probability = Value(probability),
       sequence = Value(sequence),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<PipelineStage> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<int>? probability,
    Expression<int>? sequence,
    Expression<String>? color,
    Expression<bool>? isFinal,
    Expression<bool>? isWon,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (probability != null) 'probability': probability,
      if (sequence != null) 'sequence': sequence,
      if (color != null) 'color': color,
      if (isFinal != null) 'is_final': isFinal,
      if (isWon != null) 'is_won': isWon,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PipelineStagesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<int>? probability,
    Value<int>? sequence,
    Value<String?>? color,
    Value<bool>? isFinal,
    Value<bool>? isWon,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return PipelineStagesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      probability: probability ?? this.probability,
      sequence: sequence ?? this.sequence,
      color: color ?? this.color,
      isFinal: isFinal ?? this.isFinal,
      isWon: isWon ?? this.isWon,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (probability.present) {
      map['probability'] = Variable<int>(probability.value);
    }
    if (sequence.present) {
      map['sequence'] = Variable<int>(sequence.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (isFinal.present) {
      map['is_final'] = Variable<bool>(isFinal.value);
    }
    if (isWon.present) {
      map['is_won'] = Variable<bool>(isWon.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PipelineStagesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('probability: $probability, ')
          ..write('sequence: $sequence, ')
          ..write('color: $color, ')
          ..write('isFinal: $isFinal, ')
          ..write('isWon: $isWon, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PipelineStatusesTable extends PipelineStatuses
    with TableInfo<$PipelineStatusesTable, PipelineStatuse> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PipelineStatusesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _stageIdMeta = const VerificationMeta(
    'stageId',
  );
  @override
  late final GeneratedColumn<String> stageId = GeneratedColumn<String>(
    'stage_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES pipeline_stages (id)',
    ),
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sequenceMeta = const VerificationMeta(
    'sequence',
  );
  @override
  late final GeneratedColumn<int> sequence = GeneratedColumn<int>(
    'sequence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    stageId,
    code,
    name,
    description,
    sequence,
    isDefault,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pipeline_statuses';
  @override
  VerificationContext validateIntegrity(
    Insertable<PipelineStatuse> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('stage_id')) {
      context.handle(
        _stageIdMeta,
        stageId.isAcceptableOrUnknown(data['stage_id']!, _stageIdMeta),
      );
    } else if (isInserting) {
      context.missing(_stageIdMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('sequence')) {
      context.handle(
        _sequenceMeta,
        sequence.isAcceptableOrUnknown(data['sequence']!, _sequenceMeta),
      );
    } else if (isInserting) {
      context.missing(_sequenceMeta);
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PipelineStatuse map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PipelineStatuse(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      stageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stage_id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      sequence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence'],
      )!,
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PipelineStatusesTable createAlias(String alias) {
    return $PipelineStatusesTable(attachedDatabase, alias);
  }
}

class PipelineStatuse extends DataClass implements Insertable<PipelineStatuse> {
  final String id;
  final String stageId;
  final String code;
  final String name;
  final String? description;
  final int sequence;
  final bool isDefault;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PipelineStatuse({
    required this.id,
    required this.stageId,
    required this.code,
    required this.name,
    this.description,
    required this.sequence,
    required this.isDefault,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['stage_id'] = Variable<String>(stageId);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['sequence'] = Variable<int>(sequence);
    map['is_default'] = Variable<bool>(isDefault);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PipelineStatusesCompanion toCompanion(bool nullToAbsent) {
    return PipelineStatusesCompanion(
      id: Value(id),
      stageId: Value(stageId),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      sequence: Value(sequence),
      isDefault: Value(isDefault),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PipelineStatuse.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PipelineStatuse(
      id: serializer.fromJson<String>(json['id']),
      stageId: serializer.fromJson<String>(json['stageId']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      sequence: serializer.fromJson<int>(json['sequence']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'stageId': serializer.toJson<String>(stageId),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'sequence': serializer.toJson<int>(sequence),
      'isDefault': serializer.toJson<bool>(isDefault),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  PipelineStatuse copyWith({
    String? id,
    String? stageId,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    int? sequence,
    bool? isDefault,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => PipelineStatuse(
    id: id ?? this.id,
    stageId: stageId ?? this.stageId,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    sequence: sequence ?? this.sequence,
    isDefault: isDefault ?? this.isDefault,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PipelineStatuse copyWithCompanion(PipelineStatusesCompanion data) {
    return PipelineStatuse(
      id: data.id.present ? data.id.value : this.id,
      stageId: data.stageId.present ? data.stageId.value : this.stageId,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      sequence: data.sequence.present ? data.sequence.value : this.sequence,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PipelineStatuse(')
          ..write('id: $id, ')
          ..write('stageId: $stageId, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sequence: $sequence, ')
          ..write('isDefault: $isDefault, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    stageId,
    code,
    name,
    description,
    sequence,
    isDefault,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PipelineStatuse &&
          other.id == this.id &&
          other.stageId == this.stageId &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.sequence == this.sequence &&
          other.isDefault == this.isDefault &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PipelineStatusesCompanion extends UpdateCompanion<PipelineStatuse> {
  final Value<String> id;
  final Value<String> stageId;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> sequence;
  final Value<bool> isDefault;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const PipelineStatusesCompanion({
    this.id = const Value.absent(),
    this.stageId = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.sequence = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PipelineStatusesCompanion.insert({
    required String id,
    required String stageId,
    required String code,
    required String name,
    this.description = const Value.absent(),
    required int sequence,
    this.isDefault = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       stageId = Value(stageId),
       code = Value(code),
       name = Value(name),
       sequence = Value(sequence),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<PipelineStatuse> custom({
    Expression<String>? id,
    Expression<String>? stageId,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? sequence,
    Expression<bool>? isDefault,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (stageId != null) 'stage_id': stageId,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (sequence != null) 'sequence': sequence,
      if (isDefault != null) 'is_default': isDefault,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PipelineStatusesCompanion copyWith({
    Value<String>? id,
    Value<String>? stageId,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? sequence,
    Value<bool>? isDefault,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return PipelineStatusesCompanion(
      id: id ?? this.id,
      stageId: stageId ?? this.stageId,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      sequence: sequence ?? this.sequence,
      isDefault: isDefault ?? this.isDefault,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (stageId.present) {
      map['stage_id'] = Variable<String>(stageId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (sequence.present) {
      map['sequence'] = Variable<int>(sequence.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PipelineStatusesCompanion(')
          ..write('id: $id, ')
          ..write('stageId: $stageId, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sequence: $sequence, ')
          ..write('isDefault: $isDefault, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivityTypesTable extends ActivityTypes
    with TableInfo<$ActivityTypesTable, ActivityType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivityTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _iconMeta = const VerificationMeta('icon');
  @override
  late final GeneratedColumn<String> icon = GeneratedColumn<String>(
    'icon',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _requireLocationMeta = const VerificationMeta(
    'requireLocation',
  );
  @override
  late final GeneratedColumn<bool> requireLocation = GeneratedColumn<bool>(
    'require_location',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("require_location" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _requirePhotoMeta = const VerificationMeta(
    'requirePhoto',
  );
  @override
  late final GeneratedColumn<bool> requirePhoto = GeneratedColumn<bool>(
    'require_photo',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("require_photo" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _requireNotesMeta = const VerificationMeta(
    'requireNotes',
  );
  @override
  late final GeneratedColumn<bool> requireNotes = GeneratedColumn<bool>(
    'require_notes',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("require_notes" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    icon,
    color,
    requireLocation,
    requirePhoto,
    requireNotes,
    sortOrder,
    isActive,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activity_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('icon')) {
      context.handle(
        _iconMeta,
        icon.isAcceptableOrUnknown(data['icon']!, _iconMeta),
      );
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    }
    if (data.containsKey('require_location')) {
      context.handle(
        _requireLocationMeta,
        requireLocation.isAcceptableOrUnknown(
          data['require_location']!,
          _requireLocationMeta,
        ),
      );
    }
    if (data.containsKey('require_photo')) {
      context.handle(
        _requirePhotoMeta,
        requirePhoto.isAcceptableOrUnknown(
          data['require_photo']!,
          _requirePhotoMeta,
        ),
      );
    }
    if (data.containsKey('require_notes')) {
      context.handle(
        _requireNotesMeta,
        requireNotes.isAcceptableOrUnknown(
          data['require_notes']!,
          _requireNotesMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      icon: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon'],
      ),
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      ),
      requireLocation: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}require_location'],
      )!,
      requirePhoto: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}require_photo'],
      )!,
      requireNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}require_notes'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $ActivityTypesTable createAlias(String alias) {
    return $ActivityTypesTable(attachedDatabase, alias);
  }
}

class ActivityType extends DataClass implements Insertable<ActivityType> {
  final String id;
  final String code;
  final String name;
  final String? icon;
  final String? color;
  final bool requireLocation;
  final bool requirePhoto;
  final bool requireNotes;
  final int sortOrder;
  final bool isActive;
  const ActivityType({
    required this.id,
    required this.code,
    required this.name,
    this.icon,
    this.color,
    required this.requireLocation,
    required this.requirePhoto,
    required this.requireNotes,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || icon != null) {
      map['icon'] = Variable<String>(icon);
    }
    if (!nullToAbsent || color != null) {
      map['color'] = Variable<String>(color);
    }
    map['require_location'] = Variable<bool>(requireLocation);
    map['require_photo'] = Variable<bool>(requirePhoto);
    map['require_notes'] = Variable<bool>(requireNotes);
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  ActivityTypesCompanion toCompanion(bool nullToAbsent) {
    return ActivityTypesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      icon: icon == null && nullToAbsent ? const Value.absent() : Value(icon),
      color: color == null && nullToAbsent
          ? const Value.absent()
          : Value(color),
      requireLocation: Value(requireLocation),
      requirePhoto: Value(requirePhoto),
      requireNotes: Value(requireNotes),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory ActivityType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityType(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      icon: serializer.fromJson<String?>(json['icon']),
      color: serializer.fromJson<String?>(json['color']),
      requireLocation: serializer.fromJson<bool>(json['requireLocation']),
      requirePhoto: serializer.fromJson<bool>(json['requirePhoto']),
      requireNotes: serializer.fromJson<bool>(json['requireNotes']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'icon': serializer.toJson<String?>(icon),
      'color': serializer.toJson<String?>(color),
      'requireLocation': serializer.toJson<bool>(requireLocation),
      'requirePhoto': serializer.toJson<bool>(requirePhoto),
      'requireNotes': serializer.toJson<bool>(requireNotes),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  ActivityType copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> icon = const Value.absent(),
    Value<String?> color = const Value.absent(),
    bool? requireLocation,
    bool? requirePhoto,
    bool? requireNotes,
    int? sortOrder,
    bool? isActive,
  }) => ActivityType(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    icon: icon.present ? icon.value : this.icon,
    color: color.present ? color.value : this.color,
    requireLocation: requireLocation ?? this.requireLocation,
    requirePhoto: requirePhoto ?? this.requirePhoto,
    requireNotes: requireNotes ?? this.requireNotes,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  ActivityType copyWithCompanion(ActivityTypesCompanion data) {
    return ActivityType(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      icon: data.icon.present ? data.icon.value : this.icon,
      color: data.color.present ? data.color.value : this.color,
      requireLocation: data.requireLocation.present
          ? data.requireLocation.value
          : this.requireLocation,
      requirePhoto: data.requirePhoto.present
          ? data.requirePhoto.value
          : this.requirePhoto,
      requireNotes: data.requireNotes.present
          ? data.requireNotes.value
          : this.requireNotes,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityType(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('icon: $icon, ')
          ..write('color: $color, ')
          ..write('requireLocation: $requireLocation, ')
          ..write('requirePhoto: $requirePhoto, ')
          ..write('requireNotes: $requireNotes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    icon,
    color,
    requireLocation,
    requirePhoto,
    requireNotes,
    sortOrder,
    isActive,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityType &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.icon == this.icon &&
          other.color == this.color &&
          other.requireLocation == this.requireLocation &&
          other.requirePhoto == this.requirePhoto &&
          other.requireNotes == this.requireNotes &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class ActivityTypesCompanion extends UpdateCompanion<ActivityType> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> icon;
  final Value<String?> color;
  final Value<bool> requireLocation;
  final Value<bool> requirePhoto;
  final Value<bool> requireNotes;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const ActivityTypesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.icon = const Value.absent(),
    this.color = const Value.absent(),
    this.requireLocation = const Value.absent(),
    this.requirePhoto = const Value.absent(),
    this.requireNotes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivityTypesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.icon = const Value.absent(),
    this.color = const Value.absent(),
    this.requireLocation = const Value.absent(),
    this.requirePhoto = const Value.absent(),
    this.requireNotes = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<ActivityType> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? icon,
    Expression<String>? color,
    Expression<bool>? requireLocation,
    Expression<bool>? requirePhoto,
    Expression<bool>? requireNotes,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (icon != null) 'icon': icon,
      if (color != null) 'color': color,
      if (requireLocation != null) 'require_location': requireLocation,
      if (requirePhoto != null) 'require_photo': requirePhoto,
      if (requireNotes != null) 'require_notes': requireNotes,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivityTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? icon,
    Value<String?>? color,
    Value<bool>? requireLocation,
    Value<bool>? requirePhoto,
    Value<bool>? requireNotes,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return ActivityTypesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      color: color ?? this.color,
      requireLocation: requireLocation ?? this.requireLocation,
      requirePhoto: requirePhoto ?? this.requirePhoto,
      requireNotes: requireNotes ?? this.requireNotes,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (icon.present) {
      map['icon'] = Variable<String>(icon.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (requireLocation.present) {
      map['require_location'] = Variable<bool>(requireLocation.value);
    }
    if (requirePhoto.present) {
      map['require_photo'] = Variable<bool>(requirePhoto.value);
    }
    if (requireNotes.present) {
      map['require_notes'] = Variable<bool>(requireNotes.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivityTypesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('icon: $icon, ')
          ..write('color: $color, ')
          ..write('requireLocation: $requireLocation, ')
          ..write('requirePhoto: $requirePhoto, ')
          ..write('requireNotes: $requireNotes, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LeadSourcesTable extends LeadSources
    with TableInfo<$LeadSourcesTable, LeadSource> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LeadSourcesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _requiresReferrerMeta = const VerificationMeta(
    'requiresReferrer',
  );
  @override
  late final GeneratedColumn<bool> requiresReferrer = GeneratedColumn<bool>(
    'requires_referrer',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("requires_referrer" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _requiresBrokerMeta = const VerificationMeta(
    'requiresBroker',
  );
  @override
  late final GeneratedColumn<bool> requiresBroker = GeneratedColumn<bool>(
    'requires_broker',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("requires_broker" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    requiresReferrer,
    requiresBroker,
    isActive,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'lead_sources';
  @override
  VerificationContext validateIntegrity(
    Insertable<LeadSource> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('requires_referrer')) {
      context.handle(
        _requiresReferrerMeta,
        requiresReferrer.isAcceptableOrUnknown(
          data['requires_referrer']!,
          _requiresReferrerMeta,
        ),
      );
    }
    if (data.containsKey('requires_broker')) {
      context.handle(
        _requiresBrokerMeta,
        requiresBroker.isAcceptableOrUnknown(
          data['requires_broker']!,
          _requiresBrokerMeta,
        ),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LeadSource map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LeadSource(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      requiresReferrer: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}requires_referrer'],
      )!,
      requiresBroker: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}requires_broker'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $LeadSourcesTable createAlias(String alias) {
    return $LeadSourcesTable(attachedDatabase, alias);
  }
}

class LeadSource extends DataClass implements Insertable<LeadSource> {
  final String id;
  final String code;
  final String name;
  final bool requiresReferrer;
  final bool requiresBroker;
  final bool isActive;
  const LeadSource({
    required this.id,
    required this.code,
    required this.name,
    required this.requiresReferrer,
    required this.requiresBroker,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['requires_referrer'] = Variable<bool>(requiresReferrer);
    map['requires_broker'] = Variable<bool>(requiresBroker);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  LeadSourcesCompanion toCompanion(bool nullToAbsent) {
    return LeadSourcesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      requiresReferrer: Value(requiresReferrer),
      requiresBroker: Value(requiresBroker),
      isActive: Value(isActive),
    );
  }

  factory LeadSource.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LeadSource(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      requiresReferrer: serializer.fromJson<bool>(json['requiresReferrer']),
      requiresBroker: serializer.fromJson<bool>(json['requiresBroker']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'requiresReferrer': serializer.toJson<bool>(requiresReferrer),
      'requiresBroker': serializer.toJson<bool>(requiresBroker),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  LeadSource copyWith({
    String? id,
    String? code,
    String? name,
    bool? requiresReferrer,
    bool? requiresBroker,
    bool? isActive,
  }) => LeadSource(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    requiresReferrer: requiresReferrer ?? this.requiresReferrer,
    requiresBroker: requiresBroker ?? this.requiresBroker,
    isActive: isActive ?? this.isActive,
  );
  LeadSource copyWithCompanion(LeadSourcesCompanion data) {
    return LeadSource(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      requiresReferrer: data.requiresReferrer.present
          ? data.requiresReferrer.value
          : this.requiresReferrer,
      requiresBroker: data.requiresBroker.present
          ? data.requiresBroker.value
          : this.requiresBroker,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LeadSource(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('requiresReferrer: $requiresReferrer, ')
          ..write('requiresBroker: $requiresBroker, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, code, name, requiresReferrer, requiresBroker, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LeadSource &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.requiresReferrer == this.requiresReferrer &&
          other.requiresBroker == this.requiresBroker &&
          other.isActive == this.isActive);
}

class LeadSourcesCompanion extends UpdateCompanion<LeadSource> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<bool> requiresReferrer;
  final Value<bool> requiresBroker;
  final Value<bool> isActive;
  final Value<int> rowid;
  const LeadSourcesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.requiresReferrer = const Value.absent(),
    this.requiresBroker = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LeadSourcesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.requiresReferrer = const Value.absent(),
    this.requiresBroker = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<LeadSource> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<bool>? requiresReferrer,
    Expression<bool>? requiresBroker,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (requiresReferrer != null) 'requires_referrer': requiresReferrer,
      if (requiresBroker != null) 'requires_broker': requiresBroker,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LeadSourcesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<bool>? requiresReferrer,
    Value<bool>? requiresBroker,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return LeadSourcesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      requiresReferrer: requiresReferrer ?? this.requiresReferrer,
      requiresBroker: requiresBroker ?? this.requiresBroker,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (requiresReferrer.present) {
      map['requires_referrer'] = Variable<bool>(requiresReferrer.value);
    }
    if (requiresBroker.present) {
      map['requires_broker'] = Variable<bool>(requiresBroker.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LeadSourcesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('requiresReferrer: $requiresReferrer, ')
          ..write('requiresBroker: $requiresBroker, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DeclineReasonsTable extends DeclineReasons
    with TableInfo<$DeclineReasonsTable, DeclineReason> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DeclineReasonsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    description,
    sortOrder,
    isActive,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'decline_reasons';
  @override
  VerificationContext validateIntegrity(
    Insertable<DeclineReason> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DeclineReason map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DeclineReason(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $DeclineReasonsTable createAlias(String alias) {
    return $DeclineReasonsTable(attachedDatabase, alias);
  }
}

class DeclineReason extends DataClass implements Insertable<DeclineReason> {
  final String id;
  final String code;
  final String name;
  final String? description;
  final int sortOrder;
  final bool isActive;
  const DeclineReason({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  DeclineReasonsCompanion toCompanion(bool nullToAbsent) {
    return DeclineReasonsCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory DeclineReason.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DeclineReason(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  DeclineReason copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    int? sortOrder,
    bool? isActive,
  }) => DeclineReason(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  DeclineReason copyWithCompanion(DeclineReasonsCompanion data) {
    return DeclineReason(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DeclineReason(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, code, name, description, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DeclineReason &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class DeclineReasonsCompanion extends UpdateCompanion<DeclineReason> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const DeclineReasonsCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DeclineReasonsCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<DeclineReason> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DeclineReasonsCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return DeclineReasonsCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DeclineReasonsCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CustomersTable extends Customers
    with TableInfo<$CustomersTable, Customer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _provinceIdMeta = const VerificationMeta(
    'provinceId',
  );
  @override
  late final GeneratedColumn<String> provinceId = GeneratedColumn<String>(
    'province_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _cityIdMeta = const VerificationMeta('cityId');
  @override
  late final GeneratedColumn<String> cityId = GeneratedColumn<String>(
    'city_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _postalCodeMeta = const VerificationMeta(
    'postalCode',
  );
  @override
  late final GeneratedColumn<String> postalCode = GeneratedColumn<String>(
    'postal_code',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _websiteMeta = const VerificationMeta(
    'website',
  );
  @override
  late final GeneratedColumn<String> website = GeneratedColumn<String>(
    'website',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _companyTypeIdMeta = const VerificationMeta(
    'companyTypeId',
  );
  @override
  late final GeneratedColumn<String> companyTypeId = GeneratedColumn<String>(
    'company_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownershipTypeIdMeta = const VerificationMeta(
    'ownershipTypeId',
  );
  @override
  late final GeneratedColumn<String> ownershipTypeId = GeneratedColumn<String>(
    'ownership_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _industryIdMeta = const VerificationMeta(
    'industryId',
  );
  @override
  late final GeneratedColumn<String> industryId = GeneratedColumn<String>(
    'industry_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _npwpMeta = const VerificationMeta('npwp');
  @override
  late final GeneratedColumn<String> npwp = GeneratedColumn<String>(
    'npwp',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _assignedRmIdMeta = const VerificationMeta(
    'assignedRmId',
  );
  @override
  late final GeneratedColumn<String> assignedRmId = GeneratedColumn<String>(
    'assigned_rm_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    address,
    provinceId,
    cityId,
    postalCode,
    latitude,
    longitude,
    phone,
    email,
    website,
    companyTypeId,
    ownershipTypeId,
    industryId,
    npwp,
    assignedRmId,
    imageUrl,
    notes,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Customer> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    } else if (isInserting) {
      context.missing(_addressMeta);
    }
    if (data.containsKey('province_id')) {
      context.handle(
        _provinceIdMeta,
        provinceId.isAcceptableOrUnknown(data['province_id']!, _provinceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_provinceIdMeta);
    }
    if (data.containsKey('city_id')) {
      context.handle(
        _cityIdMeta,
        cityId.isAcceptableOrUnknown(data['city_id']!, _cityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_cityIdMeta);
    }
    if (data.containsKey('postal_code')) {
      context.handle(
        _postalCodeMeta,
        postalCode.isAcceptableOrUnknown(data['postal_code']!, _postalCodeMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('website')) {
      context.handle(
        _websiteMeta,
        website.isAcceptableOrUnknown(data['website']!, _websiteMeta),
      );
    }
    if (data.containsKey('company_type_id')) {
      context.handle(
        _companyTypeIdMeta,
        companyTypeId.isAcceptableOrUnknown(
          data['company_type_id']!,
          _companyTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_companyTypeIdMeta);
    }
    if (data.containsKey('ownership_type_id')) {
      context.handle(
        _ownershipTypeIdMeta,
        ownershipTypeId.isAcceptableOrUnknown(
          data['ownership_type_id']!,
          _ownershipTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_ownershipTypeIdMeta);
    }
    if (data.containsKey('industry_id')) {
      context.handle(
        _industryIdMeta,
        industryId.isAcceptableOrUnknown(data['industry_id']!, _industryIdMeta),
      );
    } else if (isInserting) {
      context.missing(_industryIdMeta);
    }
    if (data.containsKey('npwp')) {
      context.handle(
        _npwpMeta,
        npwp.isAcceptableOrUnknown(data['npwp']!, _npwpMeta),
      );
    }
    if (data.containsKey('assigned_rm_id')) {
      context.handle(
        _assignedRmIdMeta,
        assignedRmId.isAcceptableOrUnknown(
          data['assigned_rm_id']!,
          _assignedRmIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_assignedRmIdMeta);
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Customer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Customer(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      )!,
      provinceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}province_id'],
      )!,
      cityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}city_id'],
      )!,
      postalCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}postal_code'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      website: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}website'],
      ),
      companyTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}company_type_id'],
      )!,
      ownershipTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ownership_type_id'],
      )!,
      industryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}industry_id'],
      )!,
      npwp: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}npwp'],
      ),
      assignedRmId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}assigned_rm_id'],
      )!,
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $CustomersTable createAlias(String alias) {
    return $CustomersTable(attachedDatabase, alias);
  }
}

class Customer extends DataClass implements Insertable<Customer> {
  final String id;
  final String code;
  final String name;
  final String address;
  final String provinceId;
  final String cityId;
  final String? postalCode;
  final double? latitude;
  final double? longitude;
  final String? phone;
  final String? email;
  final String? website;
  final String companyTypeId;
  final String ownershipTypeId;
  final String industryId;
  final String? npwp;
  final String assignedRmId;
  final String? imageUrl;
  final String? notes;
  final bool isActive;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const Customer({
    required this.id,
    required this.code,
    required this.name,
    required this.address,
    required this.provinceId,
    required this.cityId,
    this.postalCode,
    this.latitude,
    this.longitude,
    this.phone,
    this.email,
    this.website,
    required this.companyTypeId,
    required this.ownershipTypeId,
    required this.industryId,
    this.npwp,
    required this.assignedRmId,
    this.imageUrl,
    this.notes,
    required this.isActive,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['address'] = Variable<String>(address);
    map['province_id'] = Variable<String>(provinceId);
    map['city_id'] = Variable<String>(cityId);
    if (!nullToAbsent || postalCode != null) {
      map['postal_code'] = Variable<String>(postalCode);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || website != null) {
      map['website'] = Variable<String>(website);
    }
    map['company_type_id'] = Variable<String>(companyTypeId);
    map['ownership_type_id'] = Variable<String>(ownershipTypeId);
    map['industry_id'] = Variable<String>(industryId);
    if (!nullToAbsent || npwp != null) {
      map['npwp'] = Variable<String>(npwp);
    }
    map['assigned_rm_id'] = Variable<String>(assignedRmId);
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  CustomersCompanion toCompanion(bool nullToAbsent) {
    return CustomersCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      address: Value(address),
      provinceId: Value(provinceId),
      cityId: Value(cityId),
      postalCode: postalCode == null && nullToAbsent
          ? const Value.absent()
          : Value(postalCode),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      website: website == null && nullToAbsent
          ? const Value.absent()
          : Value(website),
      companyTypeId: Value(companyTypeId),
      ownershipTypeId: Value(ownershipTypeId),
      industryId: Value(industryId),
      npwp: npwp == null && nullToAbsent ? const Value.absent() : Value(npwp),
      assignedRmId: Value(assignedRmId),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isActive: Value(isActive),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory Customer.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Customer(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      address: serializer.fromJson<String>(json['address']),
      provinceId: serializer.fromJson<String>(json['provinceId']),
      cityId: serializer.fromJson<String>(json['cityId']),
      postalCode: serializer.fromJson<String?>(json['postalCode']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      website: serializer.fromJson<String?>(json['website']),
      companyTypeId: serializer.fromJson<String>(json['companyTypeId']),
      ownershipTypeId: serializer.fromJson<String>(json['ownershipTypeId']),
      industryId: serializer.fromJson<String>(json['industryId']),
      npwp: serializer.fromJson<String?>(json['npwp']),
      assignedRmId: serializer.fromJson<String>(json['assignedRmId']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      notes: serializer.fromJson<String?>(json['notes']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'address': serializer.toJson<String>(address),
      'provinceId': serializer.toJson<String>(provinceId),
      'cityId': serializer.toJson<String>(cityId),
      'postalCode': serializer.toJson<String?>(postalCode),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'website': serializer.toJson<String?>(website),
      'companyTypeId': serializer.toJson<String>(companyTypeId),
      'ownershipTypeId': serializer.toJson<String>(ownershipTypeId),
      'industryId': serializer.toJson<String>(industryId),
      'npwp': serializer.toJson<String?>(npwp),
      'assignedRmId': serializer.toJson<String>(assignedRmId),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'notes': serializer.toJson<String?>(notes),
      'isActive': serializer.toJson<bool>(isActive),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  Customer copyWith({
    String? id,
    String? code,
    String? name,
    String? address,
    String? provinceId,
    String? cityId,
    Value<String?> postalCode = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> email = const Value.absent(),
    Value<String?> website = const Value.absent(),
    String? companyTypeId,
    String? ownershipTypeId,
    String? industryId,
    Value<String?> npwp = const Value.absent(),
    String? assignedRmId,
    Value<String?> imageUrl = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    bool? isActive,
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => Customer(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    address: address ?? this.address,
    provinceId: provinceId ?? this.provinceId,
    cityId: cityId ?? this.cityId,
    postalCode: postalCode.present ? postalCode.value : this.postalCode,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    phone: phone.present ? phone.value : this.phone,
    email: email.present ? email.value : this.email,
    website: website.present ? website.value : this.website,
    companyTypeId: companyTypeId ?? this.companyTypeId,
    ownershipTypeId: ownershipTypeId ?? this.ownershipTypeId,
    industryId: industryId ?? this.industryId,
    npwp: npwp.present ? npwp.value : this.npwp,
    assignedRmId: assignedRmId ?? this.assignedRmId,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    notes: notes.present ? notes.value : this.notes,
    isActive: isActive ?? this.isActive,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  Customer copyWithCompanion(CustomersCompanion data) {
    return Customer(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      address: data.address.present ? data.address.value : this.address,
      provinceId: data.provinceId.present
          ? data.provinceId.value
          : this.provinceId,
      cityId: data.cityId.present ? data.cityId.value : this.cityId,
      postalCode: data.postalCode.present
          ? data.postalCode.value
          : this.postalCode,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      website: data.website.present ? data.website.value : this.website,
      companyTypeId: data.companyTypeId.present
          ? data.companyTypeId.value
          : this.companyTypeId,
      ownershipTypeId: data.ownershipTypeId.present
          ? data.ownershipTypeId.value
          : this.ownershipTypeId,
      industryId: data.industryId.present
          ? data.industryId.value
          : this.industryId,
      npwp: data.npwp.present ? data.npwp.value : this.npwp,
      assignedRmId: data.assignedRmId.present
          ? data.assignedRmId.value
          : this.assignedRmId,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      notes: data.notes.present ? data.notes.value : this.notes,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Customer(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('address: $address, ')
          ..write('provinceId: $provinceId, ')
          ..write('cityId: $cityId, ')
          ..write('postalCode: $postalCode, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('website: $website, ')
          ..write('companyTypeId: $companyTypeId, ')
          ..write('ownershipTypeId: $ownershipTypeId, ')
          ..write('industryId: $industryId, ')
          ..write('npwp: $npwp, ')
          ..write('assignedRmId: $assignedRmId, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('notes: $notes, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    code,
    name,
    address,
    provinceId,
    cityId,
    postalCode,
    latitude,
    longitude,
    phone,
    email,
    website,
    companyTypeId,
    ownershipTypeId,
    industryId,
    npwp,
    assignedRmId,
    imageUrl,
    notes,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Customer &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.address == this.address &&
          other.provinceId == this.provinceId &&
          other.cityId == this.cityId &&
          other.postalCode == this.postalCode &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.website == this.website &&
          other.companyTypeId == this.companyTypeId &&
          other.ownershipTypeId == this.ownershipTypeId &&
          other.industryId == this.industryId &&
          other.npwp == this.npwp &&
          other.assignedRmId == this.assignedRmId &&
          other.imageUrl == this.imageUrl &&
          other.notes == this.notes &&
          other.isActive == this.isActive &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class CustomersCompanion extends UpdateCompanion<Customer> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String> address;
  final Value<String> provinceId;
  final Value<String> cityId;
  final Value<String?> postalCode;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<String?> website;
  final Value<String> companyTypeId;
  final Value<String> ownershipTypeId;
  final Value<String> industryId;
  final Value<String?> npwp;
  final Value<String> assignedRmId;
  final Value<String?> imageUrl;
  final Value<String?> notes;
  final Value<bool> isActive;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const CustomersCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.address = const Value.absent(),
    this.provinceId = const Value.absent(),
    this.cityId = const Value.absent(),
    this.postalCode = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.website = const Value.absent(),
    this.companyTypeId = const Value.absent(),
    this.ownershipTypeId = const Value.absent(),
    this.industryId = const Value.absent(),
    this.npwp = const Value.absent(),
    this.assignedRmId = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.notes = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CustomersCompanion.insert({
    required String id,
    required String code,
    required String name,
    required String address,
    required String provinceId,
    required String cityId,
    this.postalCode = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.website = const Value.absent(),
    required String companyTypeId,
    required String ownershipTypeId,
    required String industryId,
    this.npwp = const Value.absent(),
    required String assignedRmId,
    this.imageUrl = const Value.absent(),
    this.notes = const Value.absent(),
    this.isActive = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       address = Value(address),
       provinceId = Value(provinceId),
       cityId = Value(cityId),
       companyTypeId = Value(companyTypeId),
       ownershipTypeId = Value(ownershipTypeId),
       industryId = Value(industryId),
       assignedRmId = Value(assignedRmId),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Customer> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? address,
    Expression<String>? provinceId,
    Expression<String>? cityId,
    Expression<String>? postalCode,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<String>? website,
    Expression<String>? companyTypeId,
    Expression<String>? ownershipTypeId,
    Expression<String>? industryId,
    Expression<String>? npwp,
    Expression<String>? assignedRmId,
    Expression<String>? imageUrl,
    Expression<String>? notes,
    Expression<bool>? isActive,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (address != null) 'address': address,
      if (provinceId != null) 'province_id': provinceId,
      if (cityId != null) 'city_id': cityId,
      if (postalCode != null) 'postal_code': postalCode,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (website != null) 'website': website,
      if (companyTypeId != null) 'company_type_id': companyTypeId,
      if (ownershipTypeId != null) 'ownership_type_id': ownershipTypeId,
      if (industryId != null) 'industry_id': industryId,
      if (npwp != null) 'npwp': npwp,
      if (assignedRmId != null) 'assigned_rm_id': assignedRmId,
      if (imageUrl != null) 'image_url': imageUrl,
      if (notes != null) 'notes': notes,
      if (isActive != null) 'is_active': isActive,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CustomersCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String>? address,
    Value<String>? provinceId,
    Value<String>? cityId,
    Value<String?>? postalCode,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String?>? phone,
    Value<String?>? email,
    Value<String?>? website,
    Value<String>? companyTypeId,
    Value<String>? ownershipTypeId,
    Value<String>? industryId,
    Value<String?>? npwp,
    Value<String>? assignedRmId,
    Value<String?>? imageUrl,
    Value<String?>? notes,
    Value<bool>? isActive,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return CustomersCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      address: address ?? this.address,
      provinceId: provinceId ?? this.provinceId,
      cityId: cityId ?? this.cityId,
      postalCode: postalCode ?? this.postalCode,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      website: website ?? this.website,
      companyTypeId: companyTypeId ?? this.companyTypeId,
      ownershipTypeId: ownershipTypeId ?? this.ownershipTypeId,
      industryId: industryId ?? this.industryId,
      npwp: npwp ?? this.npwp,
      assignedRmId: assignedRmId ?? this.assignedRmId,
      imageUrl: imageUrl ?? this.imageUrl,
      notes: notes ?? this.notes,
      isActive: isActive ?? this.isActive,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (provinceId.present) {
      map['province_id'] = Variable<String>(provinceId.value);
    }
    if (cityId.present) {
      map['city_id'] = Variable<String>(cityId.value);
    }
    if (postalCode.present) {
      map['postal_code'] = Variable<String>(postalCode.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (website.present) {
      map['website'] = Variable<String>(website.value);
    }
    if (companyTypeId.present) {
      map['company_type_id'] = Variable<String>(companyTypeId.value);
    }
    if (ownershipTypeId.present) {
      map['ownership_type_id'] = Variable<String>(ownershipTypeId.value);
    }
    if (industryId.present) {
      map['industry_id'] = Variable<String>(industryId.value);
    }
    if (npwp.present) {
      map['npwp'] = Variable<String>(npwp.value);
    }
    if (assignedRmId.present) {
      map['assigned_rm_id'] = Variable<String>(assignedRmId.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomersCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('address: $address, ')
          ..write('provinceId: $provinceId, ')
          ..write('cityId: $cityId, ')
          ..write('postalCode: $postalCode, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('website: $website, ')
          ..write('companyTypeId: $companyTypeId, ')
          ..write('ownershipTypeId: $ownershipTypeId, ')
          ..write('industryId: $industryId, ')
          ..write('npwp: $npwp, ')
          ..write('assignedRmId: $assignedRmId, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('notes: $notes, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $KeyPersonsTable extends KeyPersons
    with TableInfo<$KeyPersonsTable, KeyPerson> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $KeyPersonsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownerTypeMeta = const VerificationMeta(
    'ownerType',
  );
  @override
  late final GeneratedColumn<String> ownerType = GeneratedColumn<String>(
    'owner_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brokerIdMeta = const VerificationMeta(
    'brokerId',
  );
  @override
  late final GeneratedColumn<String> brokerId = GeneratedColumn<String>(
    'broker_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _hvcIdMeta = const VerificationMeta('hvcId');
  @override
  late final GeneratedColumn<String> hvcId = GeneratedColumn<String>(
    'hvc_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _positionMeta = const VerificationMeta(
    'position',
  );
  @override
  late final GeneratedColumn<String> position = GeneratedColumn<String>(
    'position',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _departmentMeta = const VerificationMeta(
    'department',
  );
  @override
  late final GeneratedColumn<String> department = GeneratedColumn<String>(
    'department',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPrimaryMeta = const VerificationMeta(
    'isPrimary',
  );
  @override
  late final GeneratedColumn<bool> isPrimary = GeneratedColumn<bool>(
    'is_primary',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_primary" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerType,
    customerId,
    brokerId,
    hvcId,
    name,
    position,
    department,
    phone,
    email,
    isPrimary,
    isActive,
    notes,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'key_persons';
  @override
  VerificationContext validateIntegrity(
    Insertable<KeyPerson> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('owner_type')) {
      context.handle(
        _ownerTypeMeta,
        ownerType.isAcceptableOrUnknown(data['owner_type']!, _ownerTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerTypeMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    }
    if (data.containsKey('broker_id')) {
      context.handle(
        _brokerIdMeta,
        brokerId.isAcceptableOrUnknown(data['broker_id']!, _brokerIdMeta),
      );
    }
    if (data.containsKey('hvc_id')) {
      context.handle(
        _hvcIdMeta,
        hvcId.isAcceptableOrUnknown(data['hvc_id']!, _hvcIdMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('position')) {
      context.handle(
        _positionMeta,
        position.isAcceptableOrUnknown(data['position']!, _positionMeta),
      );
    }
    if (data.containsKey('department')) {
      context.handle(
        _departmentMeta,
        department.isAcceptableOrUnknown(data['department']!, _departmentMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('is_primary')) {
      context.handle(
        _isPrimaryMeta,
        isPrimary.isAcceptableOrUnknown(data['is_primary']!, _isPrimaryMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  KeyPerson map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return KeyPerson(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      ownerType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_type'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      ),
      brokerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}broker_id'],
      ),
      hvcId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}hvc_id'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      position: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}position'],
      ),
      department: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}department'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      isPrimary: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_primary'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $KeyPersonsTable createAlias(String alias) {
    return $KeyPersonsTable(attachedDatabase, alias);
  }
}

class KeyPerson extends DataClass implements Insertable<KeyPerson> {
  final String id;
  final String ownerType;
  final String? customerId;
  final String? brokerId;
  final String? hvcId;
  final String name;
  final String? position;
  final String? department;
  final String? phone;
  final String? email;
  final bool isPrimary;
  final bool isActive;
  final String? notes;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const KeyPerson({
    required this.id,
    required this.ownerType,
    this.customerId,
    this.brokerId,
    this.hvcId,
    required this.name,
    this.position,
    this.department,
    this.phone,
    this.email,
    required this.isPrimary,
    required this.isActive,
    this.notes,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['owner_type'] = Variable<String>(ownerType);
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || brokerId != null) {
      map['broker_id'] = Variable<String>(brokerId);
    }
    if (!nullToAbsent || hvcId != null) {
      map['hvc_id'] = Variable<String>(hvcId);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || position != null) {
      map['position'] = Variable<String>(position);
    }
    if (!nullToAbsent || department != null) {
      map['department'] = Variable<String>(department);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    map['is_primary'] = Variable<bool>(isPrimary);
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  KeyPersonsCompanion toCompanion(bool nullToAbsent) {
    return KeyPersonsCompanion(
      id: Value(id),
      ownerType: Value(ownerType),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      brokerId: brokerId == null && nullToAbsent
          ? const Value.absent()
          : Value(brokerId),
      hvcId: hvcId == null && nullToAbsent
          ? const Value.absent()
          : Value(hvcId),
      name: Value(name),
      position: position == null && nullToAbsent
          ? const Value.absent()
          : Value(position),
      department: department == null && nullToAbsent
          ? const Value.absent()
          : Value(department),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      isPrimary: Value(isPrimary),
      isActive: Value(isActive),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory KeyPerson.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return KeyPerson(
      id: serializer.fromJson<String>(json['id']),
      ownerType: serializer.fromJson<String>(json['ownerType']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      brokerId: serializer.fromJson<String?>(json['brokerId']),
      hvcId: serializer.fromJson<String?>(json['hvcId']),
      name: serializer.fromJson<String>(json['name']),
      position: serializer.fromJson<String?>(json['position']),
      department: serializer.fromJson<String?>(json['department']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      isPrimary: serializer.fromJson<bool>(json['isPrimary']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'ownerType': serializer.toJson<String>(ownerType),
      'customerId': serializer.toJson<String?>(customerId),
      'brokerId': serializer.toJson<String?>(brokerId),
      'hvcId': serializer.toJson<String?>(hvcId),
      'name': serializer.toJson<String>(name),
      'position': serializer.toJson<String?>(position),
      'department': serializer.toJson<String?>(department),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'isPrimary': serializer.toJson<bool>(isPrimary),
      'isActive': serializer.toJson<bool>(isActive),
      'notes': serializer.toJson<String?>(notes),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  KeyPerson copyWith({
    String? id,
    String? ownerType,
    Value<String?> customerId = const Value.absent(),
    Value<String?> brokerId = const Value.absent(),
    Value<String?> hvcId = const Value.absent(),
    String? name,
    Value<String?> position = const Value.absent(),
    Value<String?> department = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> email = const Value.absent(),
    bool? isPrimary,
    bool? isActive,
    Value<String?> notes = const Value.absent(),
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => KeyPerson(
    id: id ?? this.id,
    ownerType: ownerType ?? this.ownerType,
    customerId: customerId.present ? customerId.value : this.customerId,
    brokerId: brokerId.present ? brokerId.value : this.brokerId,
    hvcId: hvcId.present ? hvcId.value : this.hvcId,
    name: name ?? this.name,
    position: position.present ? position.value : this.position,
    department: department.present ? department.value : this.department,
    phone: phone.present ? phone.value : this.phone,
    email: email.present ? email.value : this.email,
    isPrimary: isPrimary ?? this.isPrimary,
    isActive: isActive ?? this.isActive,
    notes: notes.present ? notes.value : this.notes,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  KeyPerson copyWithCompanion(KeyPersonsCompanion data) {
    return KeyPerson(
      id: data.id.present ? data.id.value : this.id,
      ownerType: data.ownerType.present ? data.ownerType.value : this.ownerType,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      brokerId: data.brokerId.present ? data.brokerId.value : this.brokerId,
      hvcId: data.hvcId.present ? data.hvcId.value : this.hvcId,
      name: data.name.present ? data.name.value : this.name,
      position: data.position.present ? data.position.value : this.position,
      department: data.department.present
          ? data.department.value
          : this.department,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      isPrimary: data.isPrimary.present ? data.isPrimary.value : this.isPrimary,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('KeyPerson(')
          ..write('id: $id, ')
          ..write('ownerType: $ownerType, ')
          ..write('customerId: $customerId, ')
          ..write('brokerId: $brokerId, ')
          ..write('hvcId: $hvcId, ')
          ..write('name: $name, ')
          ..write('position: $position, ')
          ..write('department: $department, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('isActive: $isActive, ')
          ..write('notes: $notes, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    ownerType,
    customerId,
    brokerId,
    hvcId,
    name,
    position,
    department,
    phone,
    email,
    isPrimary,
    isActive,
    notes,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is KeyPerson &&
          other.id == this.id &&
          other.ownerType == this.ownerType &&
          other.customerId == this.customerId &&
          other.brokerId == this.brokerId &&
          other.hvcId == this.hvcId &&
          other.name == this.name &&
          other.position == this.position &&
          other.department == this.department &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.isPrimary == this.isPrimary &&
          other.isActive == this.isActive &&
          other.notes == this.notes &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class KeyPersonsCompanion extends UpdateCompanion<KeyPerson> {
  final Value<String> id;
  final Value<String> ownerType;
  final Value<String?> customerId;
  final Value<String?> brokerId;
  final Value<String?> hvcId;
  final Value<String> name;
  final Value<String?> position;
  final Value<String?> department;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<bool> isPrimary;
  final Value<bool> isActive;
  final Value<String?> notes;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const KeyPersonsCompanion({
    this.id = const Value.absent(),
    this.ownerType = const Value.absent(),
    this.customerId = const Value.absent(),
    this.brokerId = const Value.absent(),
    this.hvcId = const Value.absent(),
    this.name = const Value.absent(),
    this.position = const Value.absent(),
    this.department = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.isActive = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  KeyPersonsCompanion.insert({
    required String id,
    required String ownerType,
    this.customerId = const Value.absent(),
    this.brokerId = const Value.absent(),
    this.hvcId = const Value.absent(),
    required String name,
    this.position = const Value.absent(),
    this.department = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.isActive = const Value.absent(),
    this.notes = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       ownerType = Value(ownerType),
       name = Value(name),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<KeyPerson> custom({
    Expression<String>? id,
    Expression<String>? ownerType,
    Expression<String>? customerId,
    Expression<String>? brokerId,
    Expression<String>? hvcId,
    Expression<String>? name,
    Expression<String>? position,
    Expression<String>? department,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<bool>? isPrimary,
    Expression<bool>? isActive,
    Expression<String>? notes,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerType != null) 'owner_type': ownerType,
      if (customerId != null) 'customer_id': customerId,
      if (brokerId != null) 'broker_id': brokerId,
      if (hvcId != null) 'hvc_id': hvcId,
      if (name != null) 'name': name,
      if (position != null) 'position': position,
      if (department != null) 'department': department,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (isPrimary != null) 'is_primary': isPrimary,
      if (isActive != null) 'is_active': isActive,
      if (notes != null) 'notes': notes,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  KeyPersonsCompanion copyWith({
    Value<String>? id,
    Value<String>? ownerType,
    Value<String?>? customerId,
    Value<String?>? brokerId,
    Value<String?>? hvcId,
    Value<String>? name,
    Value<String?>? position,
    Value<String?>? department,
    Value<String?>? phone,
    Value<String?>? email,
    Value<bool>? isPrimary,
    Value<bool>? isActive,
    Value<String?>? notes,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return KeyPersonsCompanion(
      id: id ?? this.id,
      ownerType: ownerType ?? this.ownerType,
      customerId: customerId ?? this.customerId,
      brokerId: brokerId ?? this.brokerId,
      hvcId: hvcId ?? this.hvcId,
      name: name ?? this.name,
      position: position ?? this.position,
      department: department ?? this.department,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      isPrimary: isPrimary ?? this.isPrimary,
      isActive: isActive ?? this.isActive,
      notes: notes ?? this.notes,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (ownerType.present) {
      map['owner_type'] = Variable<String>(ownerType.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (brokerId.present) {
      map['broker_id'] = Variable<String>(brokerId.value);
    }
    if (hvcId.present) {
      map['hvc_id'] = Variable<String>(hvcId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (position.present) {
      map['position'] = Variable<String>(position.value);
    }
    if (department.present) {
      map['department'] = Variable<String>(department.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (isPrimary.present) {
      map['is_primary'] = Variable<bool>(isPrimary.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('KeyPersonsCompanion(')
          ..write('id: $id, ')
          ..write('ownerType: $ownerType, ')
          ..write('customerId: $customerId, ')
          ..write('brokerId: $brokerId, ')
          ..write('hvcId: $hvcId, ')
          ..write('name: $name, ')
          ..write('position: $position, ')
          ..write('department: $department, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('isActive: $isActive, ')
          ..write('notes: $notes, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PipelinesTable extends Pipelines
    with TableInfo<$PipelinesTable, Pipeline> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PipelinesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (id)',
    ),
  );
  static const VerificationMeta _stageIdMeta = const VerificationMeta(
    'stageId',
  );
  @override
  late final GeneratedColumn<String> stageId = GeneratedColumn<String>(
    'stage_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusIdMeta = const VerificationMeta(
    'statusId',
  );
  @override
  late final GeneratedColumn<String> statusId = GeneratedColumn<String>(
    'status_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _cobIdMeta = const VerificationMeta('cobId');
  @override
  late final GeneratedColumn<String> cobId = GeneratedColumn<String>(
    'cob_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lobIdMeta = const VerificationMeta('lobId');
  @override
  late final GeneratedColumn<String> lobId = GeneratedColumn<String>(
    'lob_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _leadSourceIdMeta = const VerificationMeta(
    'leadSourceId',
  );
  @override
  late final GeneratedColumn<String> leadSourceId = GeneratedColumn<String>(
    'lead_source_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _brokerIdMeta = const VerificationMeta(
    'brokerId',
  );
  @override
  late final GeneratedColumn<String> brokerId = GeneratedColumn<String>(
    'broker_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brokerPicIdMeta = const VerificationMeta(
    'brokerPicId',
  );
  @override
  late final GeneratedColumn<String> brokerPicId = GeneratedColumn<String>(
    'broker_pic_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _customerContactIdMeta = const VerificationMeta(
    'customerContactId',
  );
  @override
  late final GeneratedColumn<String> customerContactId =
      GeneratedColumn<String>(
        'customer_contact_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _tsiMeta = const VerificationMeta('tsi');
  @override
  late final GeneratedColumn<double> tsi = GeneratedColumn<double>(
    'tsi',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _potentialPremiumMeta = const VerificationMeta(
    'potentialPremium',
  );
  @override
  late final GeneratedColumn<double> potentialPremium = GeneratedColumn<double>(
    'potential_premium',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _finalPremiumMeta = const VerificationMeta(
    'finalPremium',
  );
  @override
  late final GeneratedColumn<double> finalPremium = GeneratedColumn<double>(
    'final_premium',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _weightedValueMeta = const VerificationMeta(
    'weightedValue',
  );
  @override
  late final GeneratedColumn<double> weightedValue = GeneratedColumn<double>(
    'weighted_value',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expectedCloseDateMeta = const VerificationMeta(
    'expectedCloseDate',
  );
  @override
  late final GeneratedColumn<DateTime> expectedCloseDate =
      GeneratedColumn<DateTime>(
        'expected_close_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _policyNumberMeta = const VerificationMeta(
    'policyNumber',
  );
  @override
  late final GeneratedColumn<String> policyNumber = GeneratedColumn<String>(
    'policy_number',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _declineReasonMeta = const VerificationMeta(
    'declineReason',
  );
  @override
  late final GeneratedColumn<String> declineReason = GeneratedColumn<String>(
    'decline_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isTenderMeta = const VerificationMeta(
    'isTender',
  );
  @override
  late final GeneratedColumn<bool> isTender = GeneratedColumn<bool>(
    'is_tender',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_tender" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _referredByUserIdMeta = const VerificationMeta(
    'referredByUserId',
  );
  @override
  late final GeneratedColumn<String> referredByUserId = GeneratedColumn<String>(
    'referred_by_user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _referralIdMeta = const VerificationMeta(
    'referralId',
  );
  @override
  late final GeneratedColumn<String> referralId = GeneratedColumn<String>(
    'referral_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _assignedRmIdMeta = const VerificationMeta(
    'assignedRmId',
  );
  @override
  late final GeneratedColumn<String> assignedRmId = GeneratedColumn<String>(
    'assigned_rm_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _scoredToUserIdMeta = const VerificationMeta(
    'scoredToUserId',
  );
  @override
  late final GeneratedColumn<String> scoredToUserId = GeneratedColumn<String>(
    'scored_to_user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _closedAtMeta = const VerificationMeta(
    'closedAt',
  );
  @override
  late final GeneratedColumn<DateTime> closedAt = GeneratedColumn<DateTime>(
    'closed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    customerId,
    stageId,
    statusId,
    cobId,
    lobId,
    leadSourceId,
    brokerId,
    brokerPicId,
    customerContactId,
    tsi,
    potentialPremium,
    finalPremium,
    weightedValue,
    expectedCloseDate,
    policyNumber,
    declineReason,
    notes,
    isTender,
    referredByUserId,
    referralId,
    assignedRmId,
    scoredToUserId,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    closedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pipelines';
  @override
  VerificationContext validateIntegrity(
    Insertable<Pipeline> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('stage_id')) {
      context.handle(
        _stageIdMeta,
        stageId.isAcceptableOrUnknown(data['stage_id']!, _stageIdMeta),
      );
    } else if (isInserting) {
      context.missing(_stageIdMeta);
    }
    if (data.containsKey('status_id')) {
      context.handle(
        _statusIdMeta,
        statusId.isAcceptableOrUnknown(data['status_id']!, _statusIdMeta),
      );
    } else if (isInserting) {
      context.missing(_statusIdMeta);
    }
    if (data.containsKey('cob_id')) {
      context.handle(
        _cobIdMeta,
        cobId.isAcceptableOrUnknown(data['cob_id']!, _cobIdMeta),
      );
    } else if (isInserting) {
      context.missing(_cobIdMeta);
    }
    if (data.containsKey('lob_id')) {
      context.handle(
        _lobIdMeta,
        lobId.isAcceptableOrUnknown(data['lob_id']!, _lobIdMeta),
      );
    } else if (isInserting) {
      context.missing(_lobIdMeta);
    }
    if (data.containsKey('lead_source_id')) {
      context.handle(
        _leadSourceIdMeta,
        leadSourceId.isAcceptableOrUnknown(
          data['lead_source_id']!,
          _leadSourceIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_leadSourceIdMeta);
    }
    if (data.containsKey('broker_id')) {
      context.handle(
        _brokerIdMeta,
        brokerId.isAcceptableOrUnknown(data['broker_id']!, _brokerIdMeta),
      );
    }
    if (data.containsKey('broker_pic_id')) {
      context.handle(
        _brokerPicIdMeta,
        brokerPicId.isAcceptableOrUnknown(
          data['broker_pic_id']!,
          _brokerPicIdMeta,
        ),
      );
    }
    if (data.containsKey('customer_contact_id')) {
      context.handle(
        _customerContactIdMeta,
        customerContactId.isAcceptableOrUnknown(
          data['customer_contact_id']!,
          _customerContactIdMeta,
        ),
      );
    }
    if (data.containsKey('tsi')) {
      context.handle(
        _tsiMeta,
        tsi.isAcceptableOrUnknown(data['tsi']!, _tsiMeta),
      );
    }
    if (data.containsKey('potential_premium')) {
      context.handle(
        _potentialPremiumMeta,
        potentialPremium.isAcceptableOrUnknown(
          data['potential_premium']!,
          _potentialPremiumMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_potentialPremiumMeta);
    }
    if (data.containsKey('final_premium')) {
      context.handle(
        _finalPremiumMeta,
        finalPremium.isAcceptableOrUnknown(
          data['final_premium']!,
          _finalPremiumMeta,
        ),
      );
    }
    if (data.containsKey('weighted_value')) {
      context.handle(
        _weightedValueMeta,
        weightedValue.isAcceptableOrUnknown(
          data['weighted_value']!,
          _weightedValueMeta,
        ),
      );
    }
    if (data.containsKey('expected_close_date')) {
      context.handle(
        _expectedCloseDateMeta,
        expectedCloseDate.isAcceptableOrUnknown(
          data['expected_close_date']!,
          _expectedCloseDateMeta,
        ),
      );
    }
    if (data.containsKey('policy_number')) {
      context.handle(
        _policyNumberMeta,
        policyNumber.isAcceptableOrUnknown(
          data['policy_number']!,
          _policyNumberMeta,
        ),
      );
    }
    if (data.containsKey('decline_reason')) {
      context.handle(
        _declineReasonMeta,
        declineReason.isAcceptableOrUnknown(
          data['decline_reason']!,
          _declineReasonMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_tender')) {
      context.handle(
        _isTenderMeta,
        isTender.isAcceptableOrUnknown(data['is_tender']!, _isTenderMeta),
      );
    }
    if (data.containsKey('referred_by_user_id')) {
      context.handle(
        _referredByUserIdMeta,
        referredByUserId.isAcceptableOrUnknown(
          data['referred_by_user_id']!,
          _referredByUserIdMeta,
        ),
      );
    }
    if (data.containsKey('referral_id')) {
      context.handle(
        _referralIdMeta,
        referralId.isAcceptableOrUnknown(data['referral_id']!, _referralIdMeta),
      );
    }
    if (data.containsKey('assigned_rm_id')) {
      context.handle(
        _assignedRmIdMeta,
        assignedRmId.isAcceptableOrUnknown(
          data['assigned_rm_id']!,
          _assignedRmIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_assignedRmIdMeta);
    }
    if (data.containsKey('scored_to_user_id')) {
      context.handle(
        _scoredToUserIdMeta,
        scoredToUserId.isAcceptableOrUnknown(
          data['scored_to_user_id']!,
          _scoredToUserIdMeta,
        ),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('closed_at')) {
      context.handle(
        _closedAtMeta,
        closedAt.isAcceptableOrUnknown(data['closed_at']!, _closedAtMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Pipeline map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Pipeline(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      )!,
      stageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stage_id'],
      )!,
      statusId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status_id'],
      )!,
      cobId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cob_id'],
      )!,
      lobId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}lob_id'],
      )!,
      leadSourceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}lead_source_id'],
      )!,
      brokerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}broker_id'],
      ),
      brokerPicId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}broker_pic_id'],
      ),
      customerContactId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_contact_id'],
      ),
      tsi: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}tsi'],
      ),
      potentialPremium: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}potential_premium'],
      )!,
      finalPremium: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}final_premium'],
      ),
      weightedValue: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}weighted_value'],
      ),
      expectedCloseDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expected_close_date'],
      ),
      policyNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}policy_number'],
      ),
      declineReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}decline_reason'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isTender: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_tender'],
      )!,
      referredByUserId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}referred_by_user_id'],
      ),
      referralId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}referral_id'],
      ),
      assignedRmId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}assigned_rm_id'],
      )!,
      scoredToUserId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}scored_to_user_id'],
      ),
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      closedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}closed_at'],
      ),
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $PipelinesTable createAlias(String alias) {
    return $PipelinesTable(attachedDatabase, alias);
  }
}

class Pipeline extends DataClass implements Insertable<Pipeline> {
  final String id;
  final String code;
  final String customerId;
  final String stageId;
  final String statusId;
  final String cobId;
  final String lobId;
  final String leadSourceId;
  final String? brokerId;
  final String? brokerPicId;
  final String? customerContactId;
  final double? tsi;
  final double potentialPremium;
  final double? finalPremium;
  final double? weightedValue;
  final DateTime? expectedCloseDate;
  final String? policyNumber;
  final String? declineReason;
  final String? notes;
  final bool isTender;
  final String? referredByUserId;
  final String? referralId;
  final String assignedRmId;

  /// User who receives 4DX lag measure credit. Set when pipeline reaches WON stage, never changes after.
  final String? scoredToUserId;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? closedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const Pipeline({
    required this.id,
    required this.code,
    required this.customerId,
    required this.stageId,
    required this.statusId,
    required this.cobId,
    required this.lobId,
    required this.leadSourceId,
    this.brokerId,
    this.brokerPicId,
    this.customerContactId,
    this.tsi,
    required this.potentialPremium,
    this.finalPremium,
    this.weightedValue,
    this.expectedCloseDate,
    this.policyNumber,
    this.declineReason,
    this.notes,
    required this.isTender,
    this.referredByUserId,
    this.referralId,
    required this.assignedRmId,
    this.scoredToUserId,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.closedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['customer_id'] = Variable<String>(customerId);
    map['stage_id'] = Variable<String>(stageId);
    map['status_id'] = Variable<String>(statusId);
    map['cob_id'] = Variable<String>(cobId);
    map['lob_id'] = Variable<String>(lobId);
    map['lead_source_id'] = Variable<String>(leadSourceId);
    if (!nullToAbsent || brokerId != null) {
      map['broker_id'] = Variable<String>(brokerId);
    }
    if (!nullToAbsent || brokerPicId != null) {
      map['broker_pic_id'] = Variable<String>(brokerPicId);
    }
    if (!nullToAbsent || customerContactId != null) {
      map['customer_contact_id'] = Variable<String>(customerContactId);
    }
    if (!nullToAbsent || tsi != null) {
      map['tsi'] = Variable<double>(tsi);
    }
    map['potential_premium'] = Variable<double>(potentialPremium);
    if (!nullToAbsent || finalPremium != null) {
      map['final_premium'] = Variable<double>(finalPremium);
    }
    if (!nullToAbsent || weightedValue != null) {
      map['weighted_value'] = Variable<double>(weightedValue);
    }
    if (!nullToAbsent || expectedCloseDate != null) {
      map['expected_close_date'] = Variable<DateTime>(expectedCloseDate);
    }
    if (!nullToAbsent || policyNumber != null) {
      map['policy_number'] = Variable<String>(policyNumber);
    }
    if (!nullToAbsent || declineReason != null) {
      map['decline_reason'] = Variable<String>(declineReason);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_tender'] = Variable<bool>(isTender);
    if (!nullToAbsent || referredByUserId != null) {
      map['referred_by_user_id'] = Variable<String>(referredByUserId);
    }
    if (!nullToAbsent || referralId != null) {
      map['referral_id'] = Variable<String>(referralId);
    }
    map['assigned_rm_id'] = Variable<String>(assignedRmId);
    if (!nullToAbsent || scoredToUserId != null) {
      map['scored_to_user_id'] = Variable<String>(scoredToUserId);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || closedAt != null) {
      map['closed_at'] = Variable<DateTime>(closedAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  PipelinesCompanion toCompanion(bool nullToAbsent) {
    return PipelinesCompanion(
      id: Value(id),
      code: Value(code),
      customerId: Value(customerId),
      stageId: Value(stageId),
      statusId: Value(statusId),
      cobId: Value(cobId),
      lobId: Value(lobId),
      leadSourceId: Value(leadSourceId),
      brokerId: brokerId == null && nullToAbsent
          ? const Value.absent()
          : Value(brokerId),
      brokerPicId: brokerPicId == null && nullToAbsent
          ? const Value.absent()
          : Value(brokerPicId),
      customerContactId: customerContactId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerContactId),
      tsi: tsi == null && nullToAbsent ? const Value.absent() : Value(tsi),
      potentialPremium: Value(potentialPremium),
      finalPremium: finalPremium == null && nullToAbsent
          ? const Value.absent()
          : Value(finalPremium),
      weightedValue: weightedValue == null && nullToAbsent
          ? const Value.absent()
          : Value(weightedValue),
      expectedCloseDate: expectedCloseDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expectedCloseDate),
      policyNumber: policyNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(policyNumber),
      declineReason: declineReason == null && nullToAbsent
          ? const Value.absent()
          : Value(declineReason),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isTender: Value(isTender),
      referredByUserId: referredByUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(referredByUserId),
      referralId: referralId == null && nullToAbsent
          ? const Value.absent()
          : Value(referralId),
      assignedRmId: Value(assignedRmId),
      scoredToUserId: scoredToUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(scoredToUserId),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      closedAt: closedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(closedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory Pipeline.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Pipeline(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      customerId: serializer.fromJson<String>(json['customerId']),
      stageId: serializer.fromJson<String>(json['stageId']),
      statusId: serializer.fromJson<String>(json['statusId']),
      cobId: serializer.fromJson<String>(json['cobId']),
      lobId: serializer.fromJson<String>(json['lobId']),
      leadSourceId: serializer.fromJson<String>(json['leadSourceId']),
      brokerId: serializer.fromJson<String?>(json['brokerId']),
      brokerPicId: serializer.fromJson<String?>(json['brokerPicId']),
      customerContactId: serializer.fromJson<String?>(
        json['customerContactId'],
      ),
      tsi: serializer.fromJson<double?>(json['tsi']),
      potentialPremium: serializer.fromJson<double>(json['potentialPremium']),
      finalPremium: serializer.fromJson<double?>(json['finalPremium']),
      weightedValue: serializer.fromJson<double?>(json['weightedValue']),
      expectedCloseDate: serializer.fromJson<DateTime?>(
        json['expectedCloseDate'],
      ),
      policyNumber: serializer.fromJson<String?>(json['policyNumber']),
      declineReason: serializer.fromJson<String?>(json['declineReason']),
      notes: serializer.fromJson<String?>(json['notes']),
      isTender: serializer.fromJson<bool>(json['isTender']),
      referredByUserId: serializer.fromJson<String?>(json['referredByUserId']),
      referralId: serializer.fromJson<String?>(json['referralId']),
      assignedRmId: serializer.fromJson<String>(json['assignedRmId']),
      scoredToUserId: serializer.fromJson<String?>(json['scoredToUserId']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      closedAt: serializer.fromJson<DateTime?>(json['closedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'customerId': serializer.toJson<String>(customerId),
      'stageId': serializer.toJson<String>(stageId),
      'statusId': serializer.toJson<String>(statusId),
      'cobId': serializer.toJson<String>(cobId),
      'lobId': serializer.toJson<String>(lobId),
      'leadSourceId': serializer.toJson<String>(leadSourceId),
      'brokerId': serializer.toJson<String?>(brokerId),
      'brokerPicId': serializer.toJson<String?>(brokerPicId),
      'customerContactId': serializer.toJson<String?>(customerContactId),
      'tsi': serializer.toJson<double?>(tsi),
      'potentialPremium': serializer.toJson<double>(potentialPremium),
      'finalPremium': serializer.toJson<double?>(finalPremium),
      'weightedValue': serializer.toJson<double?>(weightedValue),
      'expectedCloseDate': serializer.toJson<DateTime?>(expectedCloseDate),
      'policyNumber': serializer.toJson<String?>(policyNumber),
      'declineReason': serializer.toJson<String?>(declineReason),
      'notes': serializer.toJson<String?>(notes),
      'isTender': serializer.toJson<bool>(isTender),
      'referredByUserId': serializer.toJson<String?>(referredByUserId),
      'referralId': serializer.toJson<String?>(referralId),
      'assignedRmId': serializer.toJson<String>(assignedRmId),
      'scoredToUserId': serializer.toJson<String?>(scoredToUserId),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'closedAt': serializer.toJson<DateTime?>(closedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  Pipeline copyWith({
    String? id,
    String? code,
    String? customerId,
    String? stageId,
    String? statusId,
    String? cobId,
    String? lobId,
    String? leadSourceId,
    Value<String?> brokerId = const Value.absent(),
    Value<String?> brokerPicId = const Value.absent(),
    Value<String?> customerContactId = const Value.absent(),
    Value<double?> tsi = const Value.absent(),
    double? potentialPremium,
    Value<double?> finalPremium = const Value.absent(),
    Value<double?> weightedValue = const Value.absent(),
    Value<DateTime?> expectedCloseDate = const Value.absent(),
    Value<String?> policyNumber = const Value.absent(),
    Value<String?> declineReason = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    bool? isTender,
    Value<String?> referredByUserId = const Value.absent(),
    Value<String?> referralId = const Value.absent(),
    String? assignedRmId,
    Value<String?> scoredToUserId = const Value.absent(),
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> closedAt = const Value.absent(),
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => Pipeline(
    id: id ?? this.id,
    code: code ?? this.code,
    customerId: customerId ?? this.customerId,
    stageId: stageId ?? this.stageId,
    statusId: statusId ?? this.statusId,
    cobId: cobId ?? this.cobId,
    lobId: lobId ?? this.lobId,
    leadSourceId: leadSourceId ?? this.leadSourceId,
    brokerId: brokerId.present ? brokerId.value : this.brokerId,
    brokerPicId: brokerPicId.present ? brokerPicId.value : this.brokerPicId,
    customerContactId: customerContactId.present
        ? customerContactId.value
        : this.customerContactId,
    tsi: tsi.present ? tsi.value : this.tsi,
    potentialPremium: potentialPremium ?? this.potentialPremium,
    finalPremium: finalPremium.present ? finalPremium.value : this.finalPremium,
    weightedValue: weightedValue.present
        ? weightedValue.value
        : this.weightedValue,
    expectedCloseDate: expectedCloseDate.present
        ? expectedCloseDate.value
        : this.expectedCloseDate,
    policyNumber: policyNumber.present ? policyNumber.value : this.policyNumber,
    declineReason: declineReason.present
        ? declineReason.value
        : this.declineReason,
    notes: notes.present ? notes.value : this.notes,
    isTender: isTender ?? this.isTender,
    referredByUserId: referredByUserId.present
        ? referredByUserId.value
        : this.referredByUserId,
    referralId: referralId.present ? referralId.value : this.referralId,
    assignedRmId: assignedRmId ?? this.assignedRmId,
    scoredToUserId: scoredToUserId.present
        ? scoredToUserId.value
        : this.scoredToUserId,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    closedAt: closedAt.present ? closedAt.value : this.closedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  Pipeline copyWithCompanion(PipelinesCompanion data) {
    return Pipeline(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      stageId: data.stageId.present ? data.stageId.value : this.stageId,
      statusId: data.statusId.present ? data.statusId.value : this.statusId,
      cobId: data.cobId.present ? data.cobId.value : this.cobId,
      lobId: data.lobId.present ? data.lobId.value : this.lobId,
      leadSourceId: data.leadSourceId.present
          ? data.leadSourceId.value
          : this.leadSourceId,
      brokerId: data.brokerId.present ? data.brokerId.value : this.brokerId,
      brokerPicId: data.brokerPicId.present
          ? data.brokerPicId.value
          : this.brokerPicId,
      customerContactId: data.customerContactId.present
          ? data.customerContactId.value
          : this.customerContactId,
      tsi: data.tsi.present ? data.tsi.value : this.tsi,
      potentialPremium: data.potentialPremium.present
          ? data.potentialPremium.value
          : this.potentialPremium,
      finalPremium: data.finalPremium.present
          ? data.finalPremium.value
          : this.finalPremium,
      weightedValue: data.weightedValue.present
          ? data.weightedValue.value
          : this.weightedValue,
      expectedCloseDate: data.expectedCloseDate.present
          ? data.expectedCloseDate.value
          : this.expectedCloseDate,
      policyNumber: data.policyNumber.present
          ? data.policyNumber.value
          : this.policyNumber,
      declineReason: data.declineReason.present
          ? data.declineReason.value
          : this.declineReason,
      notes: data.notes.present ? data.notes.value : this.notes,
      isTender: data.isTender.present ? data.isTender.value : this.isTender,
      referredByUserId: data.referredByUserId.present
          ? data.referredByUserId.value
          : this.referredByUserId,
      referralId: data.referralId.present
          ? data.referralId.value
          : this.referralId,
      assignedRmId: data.assignedRmId.present
          ? data.assignedRmId.value
          : this.assignedRmId,
      scoredToUserId: data.scoredToUserId.present
          ? data.scoredToUserId.value
          : this.scoredToUserId,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      closedAt: data.closedAt.present ? data.closedAt.value : this.closedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Pipeline(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('customerId: $customerId, ')
          ..write('stageId: $stageId, ')
          ..write('statusId: $statusId, ')
          ..write('cobId: $cobId, ')
          ..write('lobId: $lobId, ')
          ..write('leadSourceId: $leadSourceId, ')
          ..write('brokerId: $brokerId, ')
          ..write('brokerPicId: $brokerPicId, ')
          ..write('customerContactId: $customerContactId, ')
          ..write('tsi: $tsi, ')
          ..write('potentialPremium: $potentialPremium, ')
          ..write('finalPremium: $finalPremium, ')
          ..write('weightedValue: $weightedValue, ')
          ..write('expectedCloseDate: $expectedCloseDate, ')
          ..write('policyNumber: $policyNumber, ')
          ..write('declineReason: $declineReason, ')
          ..write('notes: $notes, ')
          ..write('isTender: $isTender, ')
          ..write('referredByUserId: $referredByUserId, ')
          ..write('referralId: $referralId, ')
          ..write('assignedRmId: $assignedRmId, ')
          ..write('scoredToUserId: $scoredToUserId, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('closedAt: $closedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    code,
    customerId,
    stageId,
    statusId,
    cobId,
    lobId,
    leadSourceId,
    brokerId,
    brokerPicId,
    customerContactId,
    tsi,
    potentialPremium,
    finalPremium,
    weightedValue,
    expectedCloseDate,
    policyNumber,
    declineReason,
    notes,
    isTender,
    referredByUserId,
    referralId,
    assignedRmId,
    scoredToUserId,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    closedAt,
    deletedAt,
    lastSyncAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Pipeline &&
          other.id == this.id &&
          other.code == this.code &&
          other.customerId == this.customerId &&
          other.stageId == this.stageId &&
          other.statusId == this.statusId &&
          other.cobId == this.cobId &&
          other.lobId == this.lobId &&
          other.leadSourceId == this.leadSourceId &&
          other.brokerId == this.brokerId &&
          other.brokerPicId == this.brokerPicId &&
          other.customerContactId == this.customerContactId &&
          other.tsi == this.tsi &&
          other.potentialPremium == this.potentialPremium &&
          other.finalPremium == this.finalPremium &&
          other.weightedValue == this.weightedValue &&
          other.expectedCloseDate == this.expectedCloseDate &&
          other.policyNumber == this.policyNumber &&
          other.declineReason == this.declineReason &&
          other.notes == this.notes &&
          other.isTender == this.isTender &&
          other.referredByUserId == this.referredByUserId &&
          other.referralId == this.referralId &&
          other.assignedRmId == this.assignedRmId &&
          other.scoredToUserId == this.scoredToUserId &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.closedAt == this.closedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class PipelinesCompanion extends UpdateCompanion<Pipeline> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> customerId;
  final Value<String> stageId;
  final Value<String> statusId;
  final Value<String> cobId;
  final Value<String> lobId;
  final Value<String> leadSourceId;
  final Value<String?> brokerId;
  final Value<String?> brokerPicId;
  final Value<String?> customerContactId;
  final Value<double?> tsi;
  final Value<double> potentialPremium;
  final Value<double?> finalPremium;
  final Value<double?> weightedValue;
  final Value<DateTime?> expectedCloseDate;
  final Value<String?> policyNumber;
  final Value<String?> declineReason;
  final Value<String?> notes;
  final Value<bool> isTender;
  final Value<String?> referredByUserId;
  final Value<String?> referralId;
  final Value<String> assignedRmId;
  final Value<String?> scoredToUserId;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> closedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const PipelinesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.customerId = const Value.absent(),
    this.stageId = const Value.absent(),
    this.statusId = const Value.absent(),
    this.cobId = const Value.absent(),
    this.lobId = const Value.absent(),
    this.leadSourceId = const Value.absent(),
    this.brokerId = const Value.absent(),
    this.brokerPicId = const Value.absent(),
    this.customerContactId = const Value.absent(),
    this.tsi = const Value.absent(),
    this.potentialPremium = const Value.absent(),
    this.finalPremium = const Value.absent(),
    this.weightedValue = const Value.absent(),
    this.expectedCloseDate = const Value.absent(),
    this.policyNumber = const Value.absent(),
    this.declineReason = const Value.absent(),
    this.notes = const Value.absent(),
    this.isTender = const Value.absent(),
    this.referredByUserId = const Value.absent(),
    this.referralId = const Value.absent(),
    this.assignedRmId = const Value.absent(),
    this.scoredToUserId = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.closedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PipelinesCompanion.insert({
    required String id,
    required String code,
    required String customerId,
    required String stageId,
    required String statusId,
    required String cobId,
    required String lobId,
    required String leadSourceId,
    this.brokerId = const Value.absent(),
    this.brokerPicId = const Value.absent(),
    this.customerContactId = const Value.absent(),
    this.tsi = const Value.absent(),
    required double potentialPremium,
    this.finalPremium = const Value.absent(),
    this.weightedValue = const Value.absent(),
    this.expectedCloseDate = const Value.absent(),
    this.policyNumber = const Value.absent(),
    this.declineReason = const Value.absent(),
    this.notes = const Value.absent(),
    this.isTender = const Value.absent(),
    this.referredByUserId = const Value.absent(),
    this.referralId = const Value.absent(),
    required String assignedRmId,
    this.scoredToUserId = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.closedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       customerId = Value(customerId),
       stageId = Value(stageId),
       statusId = Value(statusId),
       cobId = Value(cobId),
       lobId = Value(lobId),
       leadSourceId = Value(leadSourceId),
       potentialPremium = Value(potentialPremium),
       assignedRmId = Value(assignedRmId),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Pipeline> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? customerId,
    Expression<String>? stageId,
    Expression<String>? statusId,
    Expression<String>? cobId,
    Expression<String>? lobId,
    Expression<String>? leadSourceId,
    Expression<String>? brokerId,
    Expression<String>? brokerPicId,
    Expression<String>? customerContactId,
    Expression<double>? tsi,
    Expression<double>? potentialPremium,
    Expression<double>? finalPremium,
    Expression<double>? weightedValue,
    Expression<DateTime>? expectedCloseDate,
    Expression<String>? policyNumber,
    Expression<String>? declineReason,
    Expression<String>? notes,
    Expression<bool>? isTender,
    Expression<String>? referredByUserId,
    Expression<String>? referralId,
    Expression<String>? assignedRmId,
    Expression<String>? scoredToUserId,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? closedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (customerId != null) 'customer_id': customerId,
      if (stageId != null) 'stage_id': stageId,
      if (statusId != null) 'status_id': statusId,
      if (cobId != null) 'cob_id': cobId,
      if (lobId != null) 'lob_id': lobId,
      if (leadSourceId != null) 'lead_source_id': leadSourceId,
      if (brokerId != null) 'broker_id': brokerId,
      if (brokerPicId != null) 'broker_pic_id': brokerPicId,
      if (customerContactId != null) 'customer_contact_id': customerContactId,
      if (tsi != null) 'tsi': tsi,
      if (potentialPremium != null) 'potential_premium': potentialPremium,
      if (finalPremium != null) 'final_premium': finalPremium,
      if (weightedValue != null) 'weighted_value': weightedValue,
      if (expectedCloseDate != null) 'expected_close_date': expectedCloseDate,
      if (policyNumber != null) 'policy_number': policyNumber,
      if (declineReason != null) 'decline_reason': declineReason,
      if (notes != null) 'notes': notes,
      if (isTender != null) 'is_tender': isTender,
      if (referredByUserId != null) 'referred_by_user_id': referredByUserId,
      if (referralId != null) 'referral_id': referralId,
      if (assignedRmId != null) 'assigned_rm_id': assignedRmId,
      if (scoredToUserId != null) 'scored_to_user_id': scoredToUserId,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (closedAt != null) 'closed_at': closedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PipelinesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? customerId,
    Value<String>? stageId,
    Value<String>? statusId,
    Value<String>? cobId,
    Value<String>? lobId,
    Value<String>? leadSourceId,
    Value<String?>? brokerId,
    Value<String?>? brokerPicId,
    Value<String?>? customerContactId,
    Value<double?>? tsi,
    Value<double>? potentialPremium,
    Value<double?>? finalPremium,
    Value<double?>? weightedValue,
    Value<DateTime?>? expectedCloseDate,
    Value<String?>? policyNumber,
    Value<String?>? declineReason,
    Value<String?>? notes,
    Value<bool>? isTender,
    Value<String?>? referredByUserId,
    Value<String?>? referralId,
    Value<String>? assignedRmId,
    Value<String?>? scoredToUserId,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? closedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return PipelinesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      customerId: customerId ?? this.customerId,
      stageId: stageId ?? this.stageId,
      statusId: statusId ?? this.statusId,
      cobId: cobId ?? this.cobId,
      lobId: lobId ?? this.lobId,
      leadSourceId: leadSourceId ?? this.leadSourceId,
      brokerId: brokerId ?? this.brokerId,
      brokerPicId: brokerPicId ?? this.brokerPicId,
      customerContactId: customerContactId ?? this.customerContactId,
      tsi: tsi ?? this.tsi,
      potentialPremium: potentialPremium ?? this.potentialPremium,
      finalPremium: finalPremium ?? this.finalPremium,
      weightedValue: weightedValue ?? this.weightedValue,
      expectedCloseDate: expectedCloseDate ?? this.expectedCloseDate,
      policyNumber: policyNumber ?? this.policyNumber,
      declineReason: declineReason ?? this.declineReason,
      notes: notes ?? this.notes,
      isTender: isTender ?? this.isTender,
      referredByUserId: referredByUserId ?? this.referredByUserId,
      referralId: referralId ?? this.referralId,
      assignedRmId: assignedRmId ?? this.assignedRmId,
      scoredToUserId: scoredToUserId ?? this.scoredToUserId,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      closedAt: closedAt ?? this.closedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (stageId.present) {
      map['stage_id'] = Variable<String>(stageId.value);
    }
    if (statusId.present) {
      map['status_id'] = Variable<String>(statusId.value);
    }
    if (cobId.present) {
      map['cob_id'] = Variable<String>(cobId.value);
    }
    if (lobId.present) {
      map['lob_id'] = Variable<String>(lobId.value);
    }
    if (leadSourceId.present) {
      map['lead_source_id'] = Variable<String>(leadSourceId.value);
    }
    if (brokerId.present) {
      map['broker_id'] = Variable<String>(brokerId.value);
    }
    if (brokerPicId.present) {
      map['broker_pic_id'] = Variable<String>(brokerPicId.value);
    }
    if (customerContactId.present) {
      map['customer_contact_id'] = Variable<String>(customerContactId.value);
    }
    if (tsi.present) {
      map['tsi'] = Variable<double>(tsi.value);
    }
    if (potentialPremium.present) {
      map['potential_premium'] = Variable<double>(potentialPremium.value);
    }
    if (finalPremium.present) {
      map['final_premium'] = Variable<double>(finalPremium.value);
    }
    if (weightedValue.present) {
      map['weighted_value'] = Variable<double>(weightedValue.value);
    }
    if (expectedCloseDate.present) {
      map['expected_close_date'] = Variable<DateTime>(expectedCloseDate.value);
    }
    if (policyNumber.present) {
      map['policy_number'] = Variable<String>(policyNumber.value);
    }
    if (declineReason.present) {
      map['decline_reason'] = Variable<String>(declineReason.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isTender.present) {
      map['is_tender'] = Variable<bool>(isTender.value);
    }
    if (referredByUserId.present) {
      map['referred_by_user_id'] = Variable<String>(referredByUserId.value);
    }
    if (referralId.present) {
      map['referral_id'] = Variable<String>(referralId.value);
    }
    if (assignedRmId.present) {
      map['assigned_rm_id'] = Variable<String>(assignedRmId.value);
    }
    if (scoredToUserId.present) {
      map['scored_to_user_id'] = Variable<String>(scoredToUserId.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (closedAt.present) {
      map['closed_at'] = Variable<DateTime>(closedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PipelinesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('customerId: $customerId, ')
          ..write('stageId: $stageId, ')
          ..write('statusId: $statusId, ')
          ..write('cobId: $cobId, ')
          ..write('lobId: $lobId, ')
          ..write('leadSourceId: $leadSourceId, ')
          ..write('brokerId: $brokerId, ')
          ..write('brokerPicId: $brokerPicId, ')
          ..write('customerContactId: $customerContactId, ')
          ..write('tsi: $tsi, ')
          ..write('potentialPremium: $potentialPremium, ')
          ..write('finalPremium: $finalPremium, ')
          ..write('weightedValue: $weightedValue, ')
          ..write('expectedCloseDate: $expectedCloseDate, ')
          ..write('policyNumber: $policyNumber, ')
          ..write('declineReason: $declineReason, ')
          ..write('notes: $notes, ')
          ..write('isTender: $isTender, ')
          ..write('referredByUserId: $referredByUserId, ')
          ..write('referralId: $referralId, ')
          ..write('assignedRmId: $assignedRmId, ')
          ..write('scoredToUserId: $scoredToUserId, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('closedAt: $closedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PipelineReferralsTable extends PipelineReferrals
    with TableInfo<$PipelineReferralsTable, PipelineReferral> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PipelineReferralsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (id)',
    ),
  );
  static const VerificationMeta _referrerRmIdMeta = const VerificationMeta(
    'referrerRmId',
  );
  @override
  late final GeneratedColumn<String> referrerRmId = GeneratedColumn<String>(
    'referrer_rm_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _receiverRmIdMeta = const VerificationMeta(
    'receiverRmId',
  );
  @override
  late final GeneratedColumn<String> receiverRmId = GeneratedColumn<String>(
    'receiver_rm_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _referrerBranchIdMeta = const VerificationMeta(
    'referrerBranchId',
  );
  @override
  late final GeneratedColumn<String> referrerBranchId = GeneratedColumn<String>(
    'referrer_branch_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _receiverBranchIdMeta = const VerificationMeta(
    'receiverBranchId',
  );
  @override
  late final GeneratedColumn<String> receiverBranchId = GeneratedColumn<String>(
    'receiver_branch_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _referrerRegionalOfficeIdMeta =
      const VerificationMeta('referrerRegionalOfficeId');
  @override
  late final GeneratedColumn<String> referrerRegionalOfficeId =
      GeneratedColumn<String>(
        'referrer_regional_office_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _receiverRegionalOfficeIdMeta =
      const VerificationMeta('receiverRegionalOfficeId');
  @override
  late final GeneratedColumn<String> receiverRegionalOfficeId =
      GeneratedColumn<String>(
        'receiver_regional_office_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _approverTypeMeta = const VerificationMeta(
    'approverType',
  );
  @override
  late final GeneratedColumn<String> approverType = GeneratedColumn<String>(
    'approver_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BM'),
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('PENDING_RECEIVER'),
  );
  static const VerificationMeta _receiverAcceptedAtMeta =
      const VerificationMeta('receiverAcceptedAt');
  @override
  late final GeneratedColumn<DateTime> receiverAcceptedAt =
      GeneratedColumn<DateTime>(
        'receiver_accepted_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _receiverRejectedAtMeta =
      const VerificationMeta('receiverRejectedAt');
  @override
  late final GeneratedColumn<DateTime> receiverRejectedAt =
      GeneratedColumn<DateTime>(
        'receiver_rejected_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _receiverRejectReasonMeta =
      const VerificationMeta('receiverRejectReason');
  @override
  late final GeneratedColumn<String> receiverRejectReason =
      GeneratedColumn<String>(
        'receiver_reject_reason',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _receiverNotesMeta = const VerificationMeta(
    'receiverNotes',
  );
  @override
  late final GeneratedColumn<String> receiverNotes = GeneratedColumn<String>(
    'receiver_notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bmApprovedAtMeta = const VerificationMeta(
    'bmApprovedAt',
  );
  @override
  late final GeneratedColumn<DateTime> bmApprovedAt = GeneratedColumn<DateTime>(
    'bm_approved_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bmApprovedByMeta = const VerificationMeta(
    'bmApprovedBy',
  );
  @override
  late final GeneratedColumn<String> bmApprovedBy = GeneratedColumn<String>(
    'bm_approved_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _bmRejectedAtMeta = const VerificationMeta(
    'bmRejectedAt',
  );
  @override
  late final GeneratedColumn<DateTime> bmRejectedAt = GeneratedColumn<DateTime>(
    'bm_rejected_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bmRejectReasonMeta = const VerificationMeta(
    'bmRejectReason',
  );
  @override
  late final GeneratedColumn<String> bmRejectReason = GeneratedColumn<String>(
    'bm_reject_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bmNotesMeta = const VerificationMeta(
    'bmNotes',
  );
  @override
  late final GeneratedColumn<String> bmNotes = GeneratedColumn<String>(
    'bm_notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bonusCalculatedMeta = const VerificationMeta(
    'bonusCalculated',
  );
  @override
  late final GeneratedColumn<bool> bonusCalculated = GeneratedColumn<bool>(
    'bonus_calculated',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("bonus_calculated" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _bonusAmountMeta = const VerificationMeta(
    'bonusAmount',
  );
  @override
  late final GeneratedColumn<double> bonusAmount = GeneratedColumn<double>(
    'bonus_amount',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cancelledAtMeta = const VerificationMeta(
    'cancelledAt',
  );
  @override
  late final GeneratedColumn<DateTime> cancelledAt = GeneratedColumn<DateTime>(
    'cancelled_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cancelReasonMeta = const VerificationMeta(
    'cancelReason',
  );
  @override
  late final GeneratedColumn<String> cancelReason = GeneratedColumn<String>(
    'cancel_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    customerId,
    referrerRmId,
    receiverRmId,
    referrerBranchId,
    receiverBranchId,
    referrerRegionalOfficeId,
    receiverRegionalOfficeId,
    approverType,
    reason,
    notes,
    status,
    receiverAcceptedAt,
    receiverRejectedAt,
    receiverRejectReason,
    receiverNotes,
    bmApprovedAt,
    bmApprovedBy,
    bmRejectedAt,
    bmRejectReason,
    bmNotes,
    bonusCalculated,
    bonusAmount,
    expiresAt,
    cancelledAt,
    cancelReason,
    isPendingSync,
    createdAt,
    updatedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pipeline_referrals';
  @override
  VerificationContext validateIntegrity(
    Insertable<PipelineReferral> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('referrer_rm_id')) {
      context.handle(
        _referrerRmIdMeta,
        referrerRmId.isAcceptableOrUnknown(
          data['referrer_rm_id']!,
          _referrerRmIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_referrerRmIdMeta);
    }
    if (data.containsKey('receiver_rm_id')) {
      context.handle(
        _receiverRmIdMeta,
        receiverRmId.isAcceptableOrUnknown(
          data['receiver_rm_id']!,
          _receiverRmIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_receiverRmIdMeta);
    }
    if (data.containsKey('referrer_branch_id')) {
      context.handle(
        _referrerBranchIdMeta,
        referrerBranchId.isAcceptableOrUnknown(
          data['referrer_branch_id']!,
          _referrerBranchIdMeta,
        ),
      );
    }
    if (data.containsKey('receiver_branch_id')) {
      context.handle(
        _receiverBranchIdMeta,
        receiverBranchId.isAcceptableOrUnknown(
          data['receiver_branch_id']!,
          _receiverBranchIdMeta,
        ),
      );
    }
    if (data.containsKey('referrer_regional_office_id')) {
      context.handle(
        _referrerRegionalOfficeIdMeta,
        referrerRegionalOfficeId.isAcceptableOrUnknown(
          data['referrer_regional_office_id']!,
          _referrerRegionalOfficeIdMeta,
        ),
      );
    }
    if (data.containsKey('receiver_regional_office_id')) {
      context.handle(
        _receiverRegionalOfficeIdMeta,
        receiverRegionalOfficeId.isAcceptableOrUnknown(
          data['receiver_regional_office_id']!,
          _receiverRegionalOfficeIdMeta,
        ),
      );
    }
    if (data.containsKey('approver_type')) {
      context.handle(
        _approverTypeMeta,
        approverType.isAcceptableOrUnknown(
          data['approver_type']!,
          _approverTypeMeta,
        ),
      );
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('receiver_accepted_at')) {
      context.handle(
        _receiverAcceptedAtMeta,
        receiverAcceptedAt.isAcceptableOrUnknown(
          data['receiver_accepted_at']!,
          _receiverAcceptedAtMeta,
        ),
      );
    }
    if (data.containsKey('receiver_rejected_at')) {
      context.handle(
        _receiverRejectedAtMeta,
        receiverRejectedAt.isAcceptableOrUnknown(
          data['receiver_rejected_at']!,
          _receiverRejectedAtMeta,
        ),
      );
    }
    if (data.containsKey('receiver_reject_reason')) {
      context.handle(
        _receiverRejectReasonMeta,
        receiverRejectReason.isAcceptableOrUnknown(
          data['receiver_reject_reason']!,
          _receiverRejectReasonMeta,
        ),
      );
    }
    if (data.containsKey('receiver_notes')) {
      context.handle(
        _receiverNotesMeta,
        receiverNotes.isAcceptableOrUnknown(
          data['receiver_notes']!,
          _receiverNotesMeta,
        ),
      );
    }
    if (data.containsKey('bm_approved_at')) {
      context.handle(
        _bmApprovedAtMeta,
        bmApprovedAt.isAcceptableOrUnknown(
          data['bm_approved_at']!,
          _bmApprovedAtMeta,
        ),
      );
    }
    if (data.containsKey('bm_approved_by')) {
      context.handle(
        _bmApprovedByMeta,
        bmApprovedBy.isAcceptableOrUnknown(
          data['bm_approved_by']!,
          _bmApprovedByMeta,
        ),
      );
    }
    if (data.containsKey('bm_rejected_at')) {
      context.handle(
        _bmRejectedAtMeta,
        bmRejectedAt.isAcceptableOrUnknown(
          data['bm_rejected_at']!,
          _bmRejectedAtMeta,
        ),
      );
    }
    if (data.containsKey('bm_reject_reason')) {
      context.handle(
        _bmRejectReasonMeta,
        bmRejectReason.isAcceptableOrUnknown(
          data['bm_reject_reason']!,
          _bmRejectReasonMeta,
        ),
      );
    }
    if (data.containsKey('bm_notes')) {
      context.handle(
        _bmNotesMeta,
        bmNotes.isAcceptableOrUnknown(data['bm_notes']!, _bmNotesMeta),
      );
    }
    if (data.containsKey('bonus_calculated')) {
      context.handle(
        _bonusCalculatedMeta,
        bonusCalculated.isAcceptableOrUnknown(
          data['bonus_calculated']!,
          _bonusCalculatedMeta,
        ),
      );
    }
    if (data.containsKey('bonus_amount')) {
      context.handle(
        _bonusAmountMeta,
        bonusAmount.isAcceptableOrUnknown(
          data['bonus_amount']!,
          _bonusAmountMeta,
        ),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('cancelled_at')) {
      context.handle(
        _cancelledAtMeta,
        cancelledAt.isAcceptableOrUnknown(
          data['cancelled_at']!,
          _cancelledAtMeta,
        ),
      );
    }
    if (data.containsKey('cancel_reason')) {
      context.handle(
        _cancelReasonMeta,
        cancelReason.isAcceptableOrUnknown(
          data['cancel_reason']!,
          _cancelReasonMeta,
        ),
      );
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PipelineReferral map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PipelineReferral(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      )!,
      referrerRmId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}referrer_rm_id'],
      )!,
      receiverRmId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receiver_rm_id'],
      )!,
      referrerBranchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}referrer_branch_id'],
      ),
      receiverBranchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receiver_branch_id'],
      ),
      referrerRegionalOfficeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}referrer_regional_office_id'],
      ),
      receiverRegionalOfficeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receiver_regional_office_id'],
      ),
      approverType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}approver_type'],
      )!,
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      receiverAcceptedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}receiver_accepted_at'],
      ),
      receiverRejectedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}receiver_rejected_at'],
      ),
      receiverRejectReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receiver_reject_reason'],
      ),
      receiverNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receiver_notes'],
      ),
      bmApprovedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}bm_approved_at'],
      ),
      bmApprovedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bm_approved_by'],
      ),
      bmRejectedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}bm_rejected_at'],
      ),
      bmRejectReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bm_reject_reason'],
      ),
      bmNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bm_notes'],
      ),
      bonusCalculated: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}bonus_calculated'],
      )!,
      bonusAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}bonus_amount'],
      ),
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      cancelledAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}cancelled_at'],
      ),
      cancelReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cancel_reason'],
      ),
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $PipelineReferralsTable createAlias(String alias) {
    return $PipelineReferralsTable(attachedDatabase, alias);
  }
}

class PipelineReferral extends DataClass
    implements Insertable<PipelineReferral> {
  final String id;
  final String code;
  final String customerId;
  final String referrerRmId;
  final String receiverRmId;
  final String? referrerBranchId;
  final String? receiverBranchId;
  final String? referrerRegionalOfficeId;
  final String? receiverRegionalOfficeId;
  final String approverType;
  final String reason;
  final String? notes;
  final String status;
  final DateTime? receiverAcceptedAt;
  final DateTime? receiverRejectedAt;
  final String? receiverRejectReason;
  final String? receiverNotes;
  final DateTime? bmApprovedAt;
  final String? bmApprovedBy;
  final DateTime? bmRejectedAt;
  final String? bmRejectReason;
  final String? bmNotes;
  final bool bonusCalculated;
  final double? bonusAmount;
  final DateTime? expiresAt;
  final DateTime? cancelledAt;
  final String? cancelReason;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastSyncAt;
  const PipelineReferral({
    required this.id,
    required this.code,
    required this.customerId,
    required this.referrerRmId,
    required this.receiverRmId,
    this.referrerBranchId,
    this.receiverBranchId,
    this.referrerRegionalOfficeId,
    this.receiverRegionalOfficeId,
    required this.approverType,
    required this.reason,
    this.notes,
    required this.status,
    this.receiverAcceptedAt,
    this.receiverRejectedAt,
    this.receiverRejectReason,
    this.receiverNotes,
    this.bmApprovedAt,
    this.bmApprovedBy,
    this.bmRejectedAt,
    this.bmRejectReason,
    this.bmNotes,
    required this.bonusCalculated,
    this.bonusAmount,
    this.expiresAt,
    this.cancelledAt,
    this.cancelReason,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['customer_id'] = Variable<String>(customerId);
    map['referrer_rm_id'] = Variable<String>(referrerRmId);
    map['receiver_rm_id'] = Variable<String>(receiverRmId);
    if (!nullToAbsent || referrerBranchId != null) {
      map['referrer_branch_id'] = Variable<String>(referrerBranchId);
    }
    if (!nullToAbsent || receiverBranchId != null) {
      map['receiver_branch_id'] = Variable<String>(receiverBranchId);
    }
    if (!nullToAbsent || referrerRegionalOfficeId != null) {
      map['referrer_regional_office_id'] = Variable<String>(
        referrerRegionalOfficeId,
      );
    }
    if (!nullToAbsent || receiverRegionalOfficeId != null) {
      map['receiver_regional_office_id'] = Variable<String>(
        receiverRegionalOfficeId,
      );
    }
    map['approver_type'] = Variable<String>(approverType);
    map['reason'] = Variable<String>(reason);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || receiverAcceptedAt != null) {
      map['receiver_accepted_at'] = Variable<DateTime>(receiverAcceptedAt);
    }
    if (!nullToAbsent || receiverRejectedAt != null) {
      map['receiver_rejected_at'] = Variable<DateTime>(receiverRejectedAt);
    }
    if (!nullToAbsent || receiverRejectReason != null) {
      map['receiver_reject_reason'] = Variable<String>(receiverRejectReason);
    }
    if (!nullToAbsent || receiverNotes != null) {
      map['receiver_notes'] = Variable<String>(receiverNotes);
    }
    if (!nullToAbsent || bmApprovedAt != null) {
      map['bm_approved_at'] = Variable<DateTime>(bmApprovedAt);
    }
    if (!nullToAbsent || bmApprovedBy != null) {
      map['bm_approved_by'] = Variable<String>(bmApprovedBy);
    }
    if (!nullToAbsent || bmRejectedAt != null) {
      map['bm_rejected_at'] = Variable<DateTime>(bmRejectedAt);
    }
    if (!nullToAbsent || bmRejectReason != null) {
      map['bm_reject_reason'] = Variable<String>(bmRejectReason);
    }
    if (!nullToAbsent || bmNotes != null) {
      map['bm_notes'] = Variable<String>(bmNotes);
    }
    map['bonus_calculated'] = Variable<bool>(bonusCalculated);
    if (!nullToAbsent || bonusAmount != null) {
      map['bonus_amount'] = Variable<double>(bonusAmount);
    }
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    if (!nullToAbsent || cancelledAt != null) {
      map['cancelled_at'] = Variable<DateTime>(cancelledAt);
    }
    if (!nullToAbsent || cancelReason != null) {
      map['cancel_reason'] = Variable<String>(cancelReason);
    }
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  PipelineReferralsCompanion toCompanion(bool nullToAbsent) {
    return PipelineReferralsCompanion(
      id: Value(id),
      code: Value(code),
      customerId: Value(customerId),
      referrerRmId: Value(referrerRmId),
      receiverRmId: Value(receiverRmId),
      referrerBranchId: referrerBranchId == null && nullToAbsent
          ? const Value.absent()
          : Value(referrerBranchId),
      receiverBranchId: receiverBranchId == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverBranchId),
      referrerRegionalOfficeId: referrerRegionalOfficeId == null && nullToAbsent
          ? const Value.absent()
          : Value(referrerRegionalOfficeId),
      receiverRegionalOfficeId: receiverRegionalOfficeId == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverRegionalOfficeId),
      approverType: Value(approverType),
      reason: Value(reason),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      status: Value(status),
      receiverAcceptedAt: receiverAcceptedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverAcceptedAt),
      receiverRejectedAt: receiverRejectedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverRejectedAt),
      receiverRejectReason: receiverRejectReason == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverRejectReason),
      receiverNotes: receiverNotes == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverNotes),
      bmApprovedAt: bmApprovedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(bmApprovedAt),
      bmApprovedBy: bmApprovedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(bmApprovedBy),
      bmRejectedAt: bmRejectedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(bmRejectedAt),
      bmRejectReason: bmRejectReason == null && nullToAbsent
          ? const Value.absent()
          : Value(bmRejectReason),
      bmNotes: bmNotes == null && nullToAbsent
          ? const Value.absent()
          : Value(bmNotes),
      bonusCalculated: Value(bonusCalculated),
      bonusAmount: bonusAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(bonusAmount),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      cancelledAt: cancelledAt == null && nullToAbsent
          ? const Value.absent()
          : Value(cancelledAt),
      cancelReason: cancelReason == null && nullToAbsent
          ? const Value.absent()
          : Value(cancelReason),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory PipelineReferral.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PipelineReferral(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      customerId: serializer.fromJson<String>(json['customerId']),
      referrerRmId: serializer.fromJson<String>(json['referrerRmId']),
      receiverRmId: serializer.fromJson<String>(json['receiverRmId']),
      referrerBranchId: serializer.fromJson<String?>(json['referrerBranchId']),
      receiverBranchId: serializer.fromJson<String?>(json['receiverBranchId']),
      referrerRegionalOfficeId: serializer.fromJson<String?>(
        json['referrerRegionalOfficeId'],
      ),
      receiverRegionalOfficeId: serializer.fromJson<String?>(
        json['receiverRegionalOfficeId'],
      ),
      approverType: serializer.fromJson<String>(json['approverType']),
      reason: serializer.fromJson<String>(json['reason']),
      notes: serializer.fromJson<String?>(json['notes']),
      status: serializer.fromJson<String>(json['status']),
      receiverAcceptedAt: serializer.fromJson<DateTime?>(
        json['receiverAcceptedAt'],
      ),
      receiverRejectedAt: serializer.fromJson<DateTime?>(
        json['receiverRejectedAt'],
      ),
      receiverRejectReason: serializer.fromJson<String?>(
        json['receiverRejectReason'],
      ),
      receiverNotes: serializer.fromJson<String?>(json['receiverNotes']),
      bmApprovedAt: serializer.fromJson<DateTime?>(json['bmApprovedAt']),
      bmApprovedBy: serializer.fromJson<String?>(json['bmApprovedBy']),
      bmRejectedAt: serializer.fromJson<DateTime?>(json['bmRejectedAt']),
      bmRejectReason: serializer.fromJson<String?>(json['bmRejectReason']),
      bmNotes: serializer.fromJson<String?>(json['bmNotes']),
      bonusCalculated: serializer.fromJson<bool>(json['bonusCalculated']),
      bonusAmount: serializer.fromJson<double?>(json['bonusAmount']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      cancelledAt: serializer.fromJson<DateTime?>(json['cancelledAt']),
      cancelReason: serializer.fromJson<String?>(json['cancelReason']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'customerId': serializer.toJson<String>(customerId),
      'referrerRmId': serializer.toJson<String>(referrerRmId),
      'receiverRmId': serializer.toJson<String>(receiverRmId),
      'referrerBranchId': serializer.toJson<String?>(referrerBranchId),
      'receiverBranchId': serializer.toJson<String?>(receiverBranchId),
      'referrerRegionalOfficeId': serializer.toJson<String?>(
        referrerRegionalOfficeId,
      ),
      'receiverRegionalOfficeId': serializer.toJson<String?>(
        receiverRegionalOfficeId,
      ),
      'approverType': serializer.toJson<String>(approverType),
      'reason': serializer.toJson<String>(reason),
      'notes': serializer.toJson<String?>(notes),
      'status': serializer.toJson<String>(status),
      'receiverAcceptedAt': serializer.toJson<DateTime?>(receiverAcceptedAt),
      'receiverRejectedAt': serializer.toJson<DateTime?>(receiverRejectedAt),
      'receiverRejectReason': serializer.toJson<String?>(receiverRejectReason),
      'receiverNotes': serializer.toJson<String?>(receiverNotes),
      'bmApprovedAt': serializer.toJson<DateTime?>(bmApprovedAt),
      'bmApprovedBy': serializer.toJson<String?>(bmApprovedBy),
      'bmRejectedAt': serializer.toJson<DateTime?>(bmRejectedAt),
      'bmRejectReason': serializer.toJson<String?>(bmRejectReason),
      'bmNotes': serializer.toJson<String?>(bmNotes),
      'bonusCalculated': serializer.toJson<bool>(bonusCalculated),
      'bonusAmount': serializer.toJson<double?>(bonusAmount),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'cancelledAt': serializer.toJson<DateTime?>(cancelledAt),
      'cancelReason': serializer.toJson<String?>(cancelReason),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  PipelineReferral copyWith({
    String? id,
    String? code,
    String? customerId,
    String? referrerRmId,
    String? receiverRmId,
    Value<String?> referrerBranchId = const Value.absent(),
    Value<String?> receiverBranchId = const Value.absent(),
    Value<String?> referrerRegionalOfficeId = const Value.absent(),
    Value<String?> receiverRegionalOfficeId = const Value.absent(),
    String? approverType,
    String? reason,
    Value<String?> notes = const Value.absent(),
    String? status,
    Value<DateTime?> receiverAcceptedAt = const Value.absent(),
    Value<DateTime?> receiverRejectedAt = const Value.absent(),
    Value<String?> receiverRejectReason = const Value.absent(),
    Value<String?> receiverNotes = const Value.absent(),
    Value<DateTime?> bmApprovedAt = const Value.absent(),
    Value<String?> bmApprovedBy = const Value.absent(),
    Value<DateTime?> bmRejectedAt = const Value.absent(),
    Value<String?> bmRejectReason = const Value.absent(),
    Value<String?> bmNotes = const Value.absent(),
    bool? bonusCalculated,
    Value<double?> bonusAmount = const Value.absent(),
    Value<DateTime?> expiresAt = const Value.absent(),
    Value<DateTime?> cancelledAt = const Value.absent(),
    Value<String?> cancelReason = const Value.absent(),
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => PipelineReferral(
    id: id ?? this.id,
    code: code ?? this.code,
    customerId: customerId ?? this.customerId,
    referrerRmId: referrerRmId ?? this.referrerRmId,
    receiverRmId: receiverRmId ?? this.receiverRmId,
    referrerBranchId: referrerBranchId.present
        ? referrerBranchId.value
        : this.referrerBranchId,
    receiverBranchId: receiverBranchId.present
        ? receiverBranchId.value
        : this.receiverBranchId,
    referrerRegionalOfficeId: referrerRegionalOfficeId.present
        ? referrerRegionalOfficeId.value
        : this.referrerRegionalOfficeId,
    receiverRegionalOfficeId: receiverRegionalOfficeId.present
        ? receiverRegionalOfficeId.value
        : this.receiverRegionalOfficeId,
    approverType: approverType ?? this.approverType,
    reason: reason ?? this.reason,
    notes: notes.present ? notes.value : this.notes,
    status: status ?? this.status,
    receiverAcceptedAt: receiverAcceptedAt.present
        ? receiverAcceptedAt.value
        : this.receiverAcceptedAt,
    receiverRejectedAt: receiverRejectedAt.present
        ? receiverRejectedAt.value
        : this.receiverRejectedAt,
    receiverRejectReason: receiverRejectReason.present
        ? receiverRejectReason.value
        : this.receiverRejectReason,
    receiverNotes: receiverNotes.present
        ? receiverNotes.value
        : this.receiverNotes,
    bmApprovedAt: bmApprovedAt.present ? bmApprovedAt.value : this.bmApprovedAt,
    bmApprovedBy: bmApprovedBy.present ? bmApprovedBy.value : this.bmApprovedBy,
    bmRejectedAt: bmRejectedAt.present ? bmRejectedAt.value : this.bmRejectedAt,
    bmRejectReason: bmRejectReason.present
        ? bmRejectReason.value
        : this.bmRejectReason,
    bmNotes: bmNotes.present ? bmNotes.value : this.bmNotes,
    bonusCalculated: bonusCalculated ?? this.bonusCalculated,
    bonusAmount: bonusAmount.present ? bonusAmount.value : this.bonusAmount,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    cancelledAt: cancelledAt.present ? cancelledAt.value : this.cancelledAt,
    cancelReason: cancelReason.present ? cancelReason.value : this.cancelReason,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  PipelineReferral copyWithCompanion(PipelineReferralsCompanion data) {
    return PipelineReferral(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      referrerRmId: data.referrerRmId.present
          ? data.referrerRmId.value
          : this.referrerRmId,
      receiverRmId: data.receiverRmId.present
          ? data.receiverRmId.value
          : this.receiverRmId,
      referrerBranchId: data.referrerBranchId.present
          ? data.referrerBranchId.value
          : this.referrerBranchId,
      receiverBranchId: data.receiverBranchId.present
          ? data.receiverBranchId.value
          : this.receiverBranchId,
      referrerRegionalOfficeId: data.referrerRegionalOfficeId.present
          ? data.referrerRegionalOfficeId.value
          : this.referrerRegionalOfficeId,
      receiverRegionalOfficeId: data.receiverRegionalOfficeId.present
          ? data.receiverRegionalOfficeId.value
          : this.receiverRegionalOfficeId,
      approverType: data.approverType.present
          ? data.approverType.value
          : this.approverType,
      reason: data.reason.present ? data.reason.value : this.reason,
      notes: data.notes.present ? data.notes.value : this.notes,
      status: data.status.present ? data.status.value : this.status,
      receiverAcceptedAt: data.receiverAcceptedAt.present
          ? data.receiverAcceptedAt.value
          : this.receiverAcceptedAt,
      receiverRejectedAt: data.receiverRejectedAt.present
          ? data.receiverRejectedAt.value
          : this.receiverRejectedAt,
      receiverRejectReason: data.receiverRejectReason.present
          ? data.receiverRejectReason.value
          : this.receiverRejectReason,
      receiverNotes: data.receiverNotes.present
          ? data.receiverNotes.value
          : this.receiverNotes,
      bmApprovedAt: data.bmApprovedAt.present
          ? data.bmApprovedAt.value
          : this.bmApprovedAt,
      bmApprovedBy: data.bmApprovedBy.present
          ? data.bmApprovedBy.value
          : this.bmApprovedBy,
      bmRejectedAt: data.bmRejectedAt.present
          ? data.bmRejectedAt.value
          : this.bmRejectedAt,
      bmRejectReason: data.bmRejectReason.present
          ? data.bmRejectReason.value
          : this.bmRejectReason,
      bmNotes: data.bmNotes.present ? data.bmNotes.value : this.bmNotes,
      bonusCalculated: data.bonusCalculated.present
          ? data.bonusCalculated.value
          : this.bonusCalculated,
      bonusAmount: data.bonusAmount.present
          ? data.bonusAmount.value
          : this.bonusAmount,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      cancelledAt: data.cancelledAt.present
          ? data.cancelledAt.value
          : this.cancelledAt,
      cancelReason: data.cancelReason.present
          ? data.cancelReason.value
          : this.cancelReason,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PipelineReferral(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('customerId: $customerId, ')
          ..write('referrerRmId: $referrerRmId, ')
          ..write('receiverRmId: $receiverRmId, ')
          ..write('referrerBranchId: $referrerBranchId, ')
          ..write('receiverBranchId: $receiverBranchId, ')
          ..write('referrerRegionalOfficeId: $referrerRegionalOfficeId, ')
          ..write('receiverRegionalOfficeId: $receiverRegionalOfficeId, ')
          ..write('approverType: $approverType, ')
          ..write('reason: $reason, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('receiverAcceptedAt: $receiverAcceptedAt, ')
          ..write('receiverRejectedAt: $receiverRejectedAt, ')
          ..write('receiverRejectReason: $receiverRejectReason, ')
          ..write('receiverNotes: $receiverNotes, ')
          ..write('bmApprovedAt: $bmApprovedAt, ')
          ..write('bmApprovedBy: $bmApprovedBy, ')
          ..write('bmRejectedAt: $bmRejectedAt, ')
          ..write('bmRejectReason: $bmRejectReason, ')
          ..write('bmNotes: $bmNotes, ')
          ..write('bonusCalculated: $bonusCalculated, ')
          ..write('bonusAmount: $bonusAmount, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('cancelledAt: $cancelledAt, ')
          ..write('cancelReason: $cancelReason, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    code,
    customerId,
    referrerRmId,
    receiverRmId,
    referrerBranchId,
    receiverBranchId,
    referrerRegionalOfficeId,
    receiverRegionalOfficeId,
    approverType,
    reason,
    notes,
    status,
    receiverAcceptedAt,
    receiverRejectedAt,
    receiverRejectReason,
    receiverNotes,
    bmApprovedAt,
    bmApprovedBy,
    bmRejectedAt,
    bmRejectReason,
    bmNotes,
    bonusCalculated,
    bonusAmount,
    expiresAt,
    cancelledAt,
    cancelReason,
    isPendingSync,
    createdAt,
    updatedAt,
    lastSyncAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PipelineReferral &&
          other.id == this.id &&
          other.code == this.code &&
          other.customerId == this.customerId &&
          other.referrerRmId == this.referrerRmId &&
          other.receiverRmId == this.receiverRmId &&
          other.referrerBranchId == this.referrerBranchId &&
          other.receiverBranchId == this.receiverBranchId &&
          other.referrerRegionalOfficeId == this.referrerRegionalOfficeId &&
          other.receiverRegionalOfficeId == this.receiverRegionalOfficeId &&
          other.approverType == this.approverType &&
          other.reason == this.reason &&
          other.notes == this.notes &&
          other.status == this.status &&
          other.receiverAcceptedAt == this.receiverAcceptedAt &&
          other.receiverRejectedAt == this.receiverRejectedAt &&
          other.receiverRejectReason == this.receiverRejectReason &&
          other.receiverNotes == this.receiverNotes &&
          other.bmApprovedAt == this.bmApprovedAt &&
          other.bmApprovedBy == this.bmApprovedBy &&
          other.bmRejectedAt == this.bmRejectedAt &&
          other.bmRejectReason == this.bmRejectReason &&
          other.bmNotes == this.bmNotes &&
          other.bonusCalculated == this.bonusCalculated &&
          other.bonusAmount == this.bonusAmount &&
          other.expiresAt == this.expiresAt &&
          other.cancelledAt == this.cancelledAt &&
          other.cancelReason == this.cancelReason &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class PipelineReferralsCompanion extends UpdateCompanion<PipelineReferral> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> customerId;
  final Value<String> referrerRmId;
  final Value<String> receiverRmId;
  final Value<String?> referrerBranchId;
  final Value<String?> receiverBranchId;
  final Value<String?> referrerRegionalOfficeId;
  final Value<String?> receiverRegionalOfficeId;
  final Value<String> approverType;
  final Value<String> reason;
  final Value<String?> notes;
  final Value<String> status;
  final Value<DateTime?> receiverAcceptedAt;
  final Value<DateTime?> receiverRejectedAt;
  final Value<String?> receiverRejectReason;
  final Value<String?> receiverNotes;
  final Value<DateTime?> bmApprovedAt;
  final Value<String?> bmApprovedBy;
  final Value<DateTime?> bmRejectedAt;
  final Value<String?> bmRejectReason;
  final Value<String?> bmNotes;
  final Value<bool> bonusCalculated;
  final Value<double?> bonusAmount;
  final Value<DateTime?> expiresAt;
  final Value<DateTime?> cancelledAt;
  final Value<String?> cancelReason;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const PipelineReferralsCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.customerId = const Value.absent(),
    this.referrerRmId = const Value.absent(),
    this.receiverRmId = const Value.absent(),
    this.referrerBranchId = const Value.absent(),
    this.receiverBranchId = const Value.absent(),
    this.referrerRegionalOfficeId = const Value.absent(),
    this.receiverRegionalOfficeId = const Value.absent(),
    this.approverType = const Value.absent(),
    this.reason = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.receiverAcceptedAt = const Value.absent(),
    this.receiverRejectedAt = const Value.absent(),
    this.receiverRejectReason = const Value.absent(),
    this.receiverNotes = const Value.absent(),
    this.bmApprovedAt = const Value.absent(),
    this.bmApprovedBy = const Value.absent(),
    this.bmRejectedAt = const Value.absent(),
    this.bmRejectReason = const Value.absent(),
    this.bmNotes = const Value.absent(),
    this.bonusCalculated = const Value.absent(),
    this.bonusAmount = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.cancelledAt = const Value.absent(),
    this.cancelReason = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PipelineReferralsCompanion.insert({
    required String id,
    required String code,
    required String customerId,
    required String referrerRmId,
    required String receiverRmId,
    this.referrerBranchId = const Value.absent(),
    this.receiverBranchId = const Value.absent(),
    this.referrerRegionalOfficeId = const Value.absent(),
    this.receiverRegionalOfficeId = const Value.absent(),
    this.approverType = const Value.absent(),
    required String reason,
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.receiverAcceptedAt = const Value.absent(),
    this.receiverRejectedAt = const Value.absent(),
    this.receiverRejectReason = const Value.absent(),
    this.receiverNotes = const Value.absent(),
    this.bmApprovedAt = const Value.absent(),
    this.bmApprovedBy = const Value.absent(),
    this.bmRejectedAt = const Value.absent(),
    this.bmRejectReason = const Value.absent(),
    this.bmNotes = const Value.absent(),
    this.bonusCalculated = const Value.absent(),
    this.bonusAmount = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.cancelledAt = const Value.absent(),
    this.cancelReason = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       customerId = Value(customerId),
       referrerRmId = Value(referrerRmId),
       receiverRmId = Value(receiverRmId),
       reason = Value(reason),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<PipelineReferral> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? customerId,
    Expression<String>? referrerRmId,
    Expression<String>? receiverRmId,
    Expression<String>? referrerBranchId,
    Expression<String>? receiverBranchId,
    Expression<String>? referrerRegionalOfficeId,
    Expression<String>? receiverRegionalOfficeId,
    Expression<String>? approverType,
    Expression<String>? reason,
    Expression<String>? notes,
    Expression<String>? status,
    Expression<DateTime>? receiverAcceptedAt,
    Expression<DateTime>? receiverRejectedAt,
    Expression<String>? receiverRejectReason,
    Expression<String>? receiverNotes,
    Expression<DateTime>? bmApprovedAt,
    Expression<String>? bmApprovedBy,
    Expression<DateTime>? bmRejectedAt,
    Expression<String>? bmRejectReason,
    Expression<String>? bmNotes,
    Expression<bool>? bonusCalculated,
    Expression<double>? bonusAmount,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? cancelledAt,
    Expression<String>? cancelReason,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (customerId != null) 'customer_id': customerId,
      if (referrerRmId != null) 'referrer_rm_id': referrerRmId,
      if (receiverRmId != null) 'receiver_rm_id': receiverRmId,
      if (referrerBranchId != null) 'referrer_branch_id': referrerBranchId,
      if (receiverBranchId != null) 'receiver_branch_id': receiverBranchId,
      if (referrerRegionalOfficeId != null)
        'referrer_regional_office_id': referrerRegionalOfficeId,
      if (receiverRegionalOfficeId != null)
        'receiver_regional_office_id': receiverRegionalOfficeId,
      if (approverType != null) 'approver_type': approverType,
      if (reason != null) 'reason': reason,
      if (notes != null) 'notes': notes,
      if (status != null) 'status': status,
      if (receiverAcceptedAt != null)
        'receiver_accepted_at': receiverAcceptedAt,
      if (receiverRejectedAt != null)
        'receiver_rejected_at': receiverRejectedAt,
      if (receiverRejectReason != null)
        'receiver_reject_reason': receiverRejectReason,
      if (receiverNotes != null) 'receiver_notes': receiverNotes,
      if (bmApprovedAt != null) 'bm_approved_at': bmApprovedAt,
      if (bmApprovedBy != null) 'bm_approved_by': bmApprovedBy,
      if (bmRejectedAt != null) 'bm_rejected_at': bmRejectedAt,
      if (bmRejectReason != null) 'bm_reject_reason': bmRejectReason,
      if (bmNotes != null) 'bm_notes': bmNotes,
      if (bonusCalculated != null) 'bonus_calculated': bonusCalculated,
      if (bonusAmount != null) 'bonus_amount': bonusAmount,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (cancelledAt != null) 'cancelled_at': cancelledAt,
      if (cancelReason != null) 'cancel_reason': cancelReason,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PipelineReferralsCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? customerId,
    Value<String>? referrerRmId,
    Value<String>? receiverRmId,
    Value<String?>? referrerBranchId,
    Value<String?>? receiverBranchId,
    Value<String?>? referrerRegionalOfficeId,
    Value<String?>? receiverRegionalOfficeId,
    Value<String>? approverType,
    Value<String>? reason,
    Value<String?>? notes,
    Value<String>? status,
    Value<DateTime?>? receiverAcceptedAt,
    Value<DateTime?>? receiverRejectedAt,
    Value<String?>? receiverRejectReason,
    Value<String?>? receiverNotes,
    Value<DateTime?>? bmApprovedAt,
    Value<String?>? bmApprovedBy,
    Value<DateTime?>? bmRejectedAt,
    Value<String?>? bmRejectReason,
    Value<String?>? bmNotes,
    Value<bool>? bonusCalculated,
    Value<double?>? bonusAmount,
    Value<DateTime?>? expiresAt,
    Value<DateTime?>? cancelledAt,
    Value<String?>? cancelReason,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return PipelineReferralsCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      customerId: customerId ?? this.customerId,
      referrerRmId: referrerRmId ?? this.referrerRmId,
      receiverRmId: receiverRmId ?? this.receiverRmId,
      referrerBranchId: referrerBranchId ?? this.referrerBranchId,
      receiverBranchId: receiverBranchId ?? this.receiverBranchId,
      referrerRegionalOfficeId:
          referrerRegionalOfficeId ?? this.referrerRegionalOfficeId,
      receiverRegionalOfficeId:
          receiverRegionalOfficeId ?? this.receiverRegionalOfficeId,
      approverType: approverType ?? this.approverType,
      reason: reason ?? this.reason,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      receiverAcceptedAt: receiverAcceptedAt ?? this.receiverAcceptedAt,
      receiverRejectedAt: receiverRejectedAt ?? this.receiverRejectedAt,
      receiverRejectReason: receiverRejectReason ?? this.receiverRejectReason,
      receiverNotes: receiverNotes ?? this.receiverNotes,
      bmApprovedAt: bmApprovedAt ?? this.bmApprovedAt,
      bmApprovedBy: bmApprovedBy ?? this.bmApprovedBy,
      bmRejectedAt: bmRejectedAt ?? this.bmRejectedAt,
      bmRejectReason: bmRejectReason ?? this.bmRejectReason,
      bmNotes: bmNotes ?? this.bmNotes,
      bonusCalculated: bonusCalculated ?? this.bonusCalculated,
      bonusAmount: bonusAmount ?? this.bonusAmount,
      expiresAt: expiresAt ?? this.expiresAt,
      cancelledAt: cancelledAt ?? this.cancelledAt,
      cancelReason: cancelReason ?? this.cancelReason,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (referrerRmId.present) {
      map['referrer_rm_id'] = Variable<String>(referrerRmId.value);
    }
    if (receiverRmId.present) {
      map['receiver_rm_id'] = Variable<String>(receiverRmId.value);
    }
    if (referrerBranchId.present) {
      map['referrer_branch_id'] = Variable<String>(referrerBranchId.value);
    }
    if (receiverBranchId.present) {
      map['receiver_branch_id'] = Variable<String>(receiverBranchId.value);
    }
    if (referrerRegionalOfficeId.present) {
      map['referrer_regional_office_id'] = Variable<String>(
        referrerRegionalOfficeId.value,
      );
    }
    if (receiverRegionalOfficeId.present) {
      map['receiver_regional_office_id'] = Variable<String>(
        receiverRegionalOfficeId.value,
      );
    }
    if (approverType.present) {
      map['approver_type'] = Variable<String>(approverType.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (receiverAcceptedAt.present) {
      map['receiver_accepted_at'] = Variable<DateTime>(
        receiverAcceptedAt.value,
      );
    }
    if (receiverRejectedAt.present) {
      map['receiver_rejected_at'] = Variable<DateTime>(
        receiverRejectedAt.value,
      );
    }
    if (receiverRejectReason.present) {
      map['receiver_reject_reason'] = Variable<String>(
        receiverRejectReason.value,
      );
    }
    if (receiverNotes.present) {
      map['receiver_notes'] = Variable<String>(receiverNotes.value);
    }
    if (bmApprovedAt.present) {
      map['bm_approved_at'] = Variable<DateTime>(bmApprovedAt.value);
    }
    if (bmApprovedBy.present) {
      map['bm_approved_by'] = Variable<String>(bmApprovedBy.value);
    }
    if (bmRejectedAt.present) {
      map['bm_rejected_at'] = Variable<DateTime>(bmRejectedAt.value);
    }
    if (bmRejectReason.present) {
      map['bm_reject_reason'] = Variable<String>(bmRejectReason.value);
    }
    if (bmNotes.present) {
      map['bm_notes'] = Variable<String>(bmNotes.value);
    }
    if (bonusCalculated.present) {
      map['bonus_calculated'] = Variable<bool>(bonusCalculated.value);
    }
    if (bonusAmount.present) {
      map['bonus_amount'] = Variable<double>(bonusAmount.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (cancelledAt.present) {
      map['cancelled_at'] = Variable<DateTime>(cancelledAt.value);
    }
    if (cancelReason.present) {
      map['cancel_reason'] = Variable<String>(cancelReason.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PipelineReferralsCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('customerId: $customerId, ')
          ..write('referrerRmId: $referrerRmId, ')
          ..write('receiverRmId: $receiverRmId, ')
          ..write('referrerBranchId: $referrerBranchId, ')
          ..write('receiverBranchId: $receiverBranchId, ')
          ..write('referrerRegionalOfficeId: $referrerRegionalOfficeId, ')
          ..write('receiverRegionalOfficeId: $receiverRegionalOfficeId, ')
          ..write('approverType: $approverType, ')
          ..write('reason: $reason, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('receiverAcceptedAt: $receiverAcceptedAt, ')
          ..write('receiverRejectedAt: $receiverRejectedAt, ')
          ..write('receiverRejectReason: $receiverRejectReason, ')
          ..write('receiverNotes: $receiverNotes, ')
          ..write('bmApprovedAt: $bmApprovedAt, ')
          ..write('bmApprovedBy: $bmApprovedBy, ')
          ..write('bmRejectedAt: $bmRejectedAt, ')
          ..write('bmRejectReason: $bmRejectReason, ')
          ..write('bmNotes: $bmNotes, ')
          ..write('bonusCalculated: $bonusCalculated, ')
          ..write('bonusAmount: $bonusAmount, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('cancelledAt: $cancelledAt, ')
          ..write('cancelReason: $cancelReason, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivitiesTable extends Activities
    with TableInfo<$ActivitiesTable, Activity> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _objectTypeMeta = const VerificationMeta(
    'objectType',
  );
  @override
  late final GeneratedColumn<String> objectType = GeneratedColumn<String>(
    'object_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES customers (id)',
    ),
  );
  static const VerificationMeta _hvcIdMeta = const VerificationMeta('hvcId');
  @override
  late final GeneratedColumn<String> hvcId = GeneratedColumn<String>(
    'hvc_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _brokerIdMeta = const VerificationMeta(
    'brokerId',
  );
  @override
  late final GeneratedColumn<String> brokerId = GeneratedColumn<String>(
    'broker_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pipelineIdMeta = const VerificationMeta(
    'pipelineId',
  );
  @override
  late final GeneratedColumn<String> pipelineId = GeneratedColumn<String>(
    'pipeline_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES pipelines (id)',
    ),
  );
  static const VerificationMeta _keyPersonIdMeta = const VerificationMeta(
    'keyPersonId',
  );
  @override
  late final GeneratedColumn<String> keyPersonId = GeneratedColumn<String>(
    'key_person_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _activityTypeIdMeta = const VerificationMeta(
    'activityTypeId',
  );
  @override
  late final GeneratedColumn<String> activityTypeId = GeneratedColumn<String>(
    'activity_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _summaryMeta = const VerificationMeta(
    'summary',
  );
  @override
  late final GeneratedColumn<String> summary = GeneratedColumn<String>(
    'summary',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _scheduledDatetimeMeta = const VerificationMeta(
    'scheduledDatetime',
  );
  @override
  late final GeneratedColumn<DateTime> scheduledDatetime =
      GeneratedColumn<DateTime>(
        'scheduled_datetime',
        aliasedName,
        false,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _isImmediateMeta = const VerificationMeta(
    'isImmediate',
  );
  @override
  late final GeneratedColumn<bool> isImmediate = GeneratedColumn<bool>(
    'is_immediate',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_immediate" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('PLANNED'),
  );
  static const VerificationMeta _executedAtMeta = const VerificationMeta(
    'executedAt',
  );
  @override
  late final GeneratedColumn<DateTime> executedAt = GeneratedColumn<DateTime>(
    'executed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationAccuracyMeta = const VerificationMeta(
    'locationAccuracy',
  );
  @override
  late final GeneratedColumn<double> locationAccuracy = GeneratedColumn<double>(
    'location_accuracy',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _distanceFromTargetMeta =
      const VerificationMeta('distanceFromTarget');
  @override
  late final GeneratedColumn<double> distanceFromTarget =
      GeneratedColumn<double>(
        'distance_from_target',
        aliasedName,
        true,
        type: DriftSqlType.double,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isLocationOverrideMeta =
      const VerificationMeta('isLocationOverride');
  @override
  late final GeneratedColumn<bool> isLocationOverride = GeneratedColumn<bool>(
    'is_location_override',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_location_override" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _overrideReasonMeta = const VerificationMeta(
    'overrideReason',
  );
  @override
  late final GeneratedColumn<String> overrideReason = GeneratedColumn<String>(
    'override_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rescheduledFromIdMeta = const VerificationMeta(
    'rescheduledFromId',
  );
  @override
  late final GeneratedColumn<String> rescheduledFromId =
      GeneratedColumn<String>(
        'rescheduled_from_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _rescheduledToIdMeta = const VerificationMeta(
    'rescheduledToId',
  );
  @override
  late final GeneratedColumn<String> rescheduledToId = GeneratedColumn<String>(
    'rescheduled_to_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cancelledAtMeta = const VerificationMeta(
    'cancelledAt',
  );
  @override
  late final GeneratedColumn<DateTime> cancelledAt = GeneratedColumn<DateTime>(
    'cancelled_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cancelReasonMeta = const VerificationMeta(
    'cancelReason',
  );
  @override
  late final GeneratedColumn<String> cancelReason = GeneratedColumn<String>(
    'cancel_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    createdBy,
    objectType,
    customerId,
    hvcId,
    brokerId,
    pipelineId,
    keyPersonId,
    activityTypeId,
    summary,
    notes,
    scheduledDatetime,
    isImmediate,
    status,
    executedAt,
    latitude,
    longitude,
    locationAccuracy,
    distanceFromTarget,
    isLocationOverride,
    overrideReason,
    rescheduledFromId,
    rescheduledToId,
    cancelledAt,
    cancelReason,
    isPendingSync,
    createdAt,
    updatedAt,
    lastSyncAt,
    deletedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activities';
  @override
  VerificationContext validateIntegrity(
    Insertable<Activity> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('object_type')) {
      context.handle(
        _objectTypeMeta,
        objectType.isAcceptableOrUnknown(data['object_type']!, _objectTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_objectTypeMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    }
    if (data.containsKey('hvc_id')) {
      context.handle(
        _hvcIdMeta,
        hvcId.isAcceptableOrUnknown(data['hvc_id']!, _hvcIdMeta),
      );
    }
    if (data.containsKey('broker_id')) {
      context.handle(
        _brokerIdMeta,
        brokerId.isAcceptableOrUnknown(data['broker_id']!, _brokerIdMeta),
      );
    }
    if (data.containsKey('pipeline_id')) {
      context.handle(
        _pipelineIdMeta,
        pipelineId.isAcceptableOrUnknown(data['pipeline_id']!, _pipelineIdMeta),
      );
    }
    if (data.containsKey('key_person_id')) {
      context.handle(
        _keyPersonIdMeta,
        keyPersonId.isAcceptableOrUnknown(
          data['key_person_id']!,
          _keyPersonIdMeta,
        ),
      );
    }
    if (data.containsKey('activity_type_id')) {
      context.handle(
        _activityTypeIdMeta,
        activityTypeId.isAcceptableOrUnknown(
          data['activity_type_id']!,
          _activityTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_activityTypeIdMeta);
    }
    if (data.containsKey('summary')) {
      context.handle(
        _summaryMeta,
        summary.isAcceptableOrUnknown(data['summary']!, _summaryMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('scheduled_datetime')) {
      context.handle(
        _scheduledDatetimeMeta,
        scheduledDatetime.isAcceptableOrUnknown(
          data['scheduled_datetime']!,
          _scheduledDatetimeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_scheduledDatetimeMeta);
    }
    if (data.containsKey('is_immediate')) {
      context.handle(
        _isImmediateMeta,
        isImmediate.isAcceptableOrUnknown(
          data['is_immediate']!,
          _isImmediateMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('executed_at')) {
      context.handle(
        _executedAtMeta,
        executedAt.isAcceptableOrUnknown(data['executed_at']!, _executedAtMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('location_accuracy')) {
      context.handle(
        _locationAccuracyMeta,
        locationAccuracy.isAcceptableOrUnknown(
          data['location_accuracy']!,
          _locationAccuracyMeta,
        ),
      );
    }
    if (data.containsKey('distance_from_target')) {
      context.handle(
        _distanceFromTargetMeta,
        distanceFromTarget.isAcceptableOrUnknown(
          data['distance_from_target']!,
          _distanceFromTargetMeta,
        ),
      );
    }
    if (data.containsKey('is_location_override')) {
      context.handle(
        _isLocationOverrideMeta,
        isLocationOverride.isAcceptableOrUnknown(
          data['is_location_override']!,
          _isLocationOverrideMeta,
        ),
      );
    }
    if (data.containsKey('override_reason')) {
      context.handle(
        _overrideReasonMeta,
        overrideReason.isAcceptableOrUnknown(
          data['override_reason']!,
          _overrideReasonMeta,
        ),
      );
    }
    if (data.containsKey('rescheduled_from_id')) {
      context.handle(
        _rescheduledFromIdMeta,
        rescheduledFromId.isAcceptableOrUnknown(
          data['rescheduled_from_id']!,
          _rescheduledFromIdMeta,
        ),
      );
    }
    if (data.containsKey('rescheduled_to_id')) {
      context.handle(
        _rescheduledToIdMeta,
        rescheduledToId.isAcceptableOrUnknown(
          data['rescheduled_to_id']!,
          _rescheduledToIdMeta,
        ),
      );
    }
    if (data.containsKey('cancelled_at')) {
      context.handle(
        _cancelledAtMeta,
        cancelledAt.isAcceptableOrUnknown(
          data['cancelled_at']!,
          _cancelledAtMeta,
        ),
      );
    }
    if (data.containsKey('cancel_reason')) {
      context.handle(
        _cancelReasonMeta,
        cancelReason.isAcceptableOrUnknown(
          data['cancel_reason']!,
          _cancelReasonMeta,
        ),
      );
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Activity map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Activity(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      objectType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}object_type'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      ),
      hvcId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}hvc_id'],
      ),
      brokerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}broker_id'],
      ),
      pipelineId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}pipeline_id'],
      ),
      keyPersonId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}key_person_id'],
      ),
      activityTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_type_id'],
      )!,
      summary: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}summary'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      scheduledDatetime: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}scheduled_datetime'],
      )!,
      isImmediate: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_immediate'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      executedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}executed_at'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      locationAccuracy: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}location_accuracy'],
      ),
      distanceFromTarget: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}distance_from_target'],
      ),
      isLocationOverride: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_location_override'],
      )!,
      overrideReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}override_reason'],
      ),
      rescheduledFromId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}rescheduled_from_id'],
      ),
      rescheduledToId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}rescheduled_to_id'],
      ),
      cancelledAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}cancelled_at'],
      ),
      cancelReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cancel_reason'],
      ),
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
    );
  }

  @override
  $ActivitiesTable createAlias(String alias) {
    return $ActivitiesTable(attachedDatabase, alias);
  }
}

class Activity extends DataClass implements Insertable<Activity> {
  final String id;
  final String userId;
  final String createdBy;
  final String objectType;
  final String? customerId;
  final String? hvcId;
  final String? brokerId;
  final String? pipelineId;
  final String? keyPersonId;
  final String activityTypeId;
  final String? summary;
  final String? notes;
  final DateTime scheduledDatetime;
  final bool isImmediate;
  final String status;
  final DateTime? executedAt;
  final double? latitude;
  final double? longitude;
  final double? locationAccuracy;
  final double? distanceFromTarget;
  final bool isLocationOverride;
  final String? overrideReason;
  final String? rescheduledFromId;
  final String? rescheduledToId;
  final DateTime? cancelledAt;
  final String? cancelReason;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastSyncAt;
  final DateTime? deletedAt;
  const Activity({
    required this.id,
    required this.userId,
    required this.createdBy,
    required this.objectType,
    this.customerId,
    this.hvcId,
    this.brokerId,
    this.pipelineId,
    this.keyPersonId,
    required this.activityTypeId,
    this.summary,
    this.notes,
    required this.scheduledDatetime,
    required this.isImmediate,
    required this.status,
    this.executedAt,
    this.latitude,
    this.longitude,
    this.locationAccuracy,
    this.distanceFromTarget,
    required this.isLocationOverride,
    this.overrideReason,
    this.rescheduledFromId,
    this.rescheduledToId,
    this.cancelledAt,
    this.cancelReason,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.lastSyncAt,
    this.deletedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['created_by'] = Variable<String>(createdBy);
    map['object_type'] = Variable<String>(objectType);
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || hvcId != null) {
      map['hvc_id'] = Variable<String>(hvcId);
    }
    if (!nullToAbsent || brokerId != null) {
      map['broker_id'] = Variable<String>(brokerId);
    }
    if (!nullToAbsent || pipelineId != null) {
      map['pipeline_id'] = Variable<String>(pipelineId);
    }
    if (!nullToAbsent || keyPersonId != null) {
      map['key_person_id'] = Variable<String>(keyPersonId);
    }
    map['activity_type_id'] = Variable<String>(activityTypeId);
    if (!nullToAbsent || summary != null) {
      map['summary'] = Variable<String>(summary);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['scheduled_datetime'] = Variable<DateTime>(scheduledDatetime);
    map['is_immediate'] = Variable<bool>(isImmediate);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || executedAt != null) {
      map['executed_at'] = Variable<DateTime>(executedAt);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || locationAccuracy != null) {
      map['location_accuracy'] = Variable<double>(locationAccuracy);
    }
    if (!nullToAbsent || distanceFromTarget != null) {
      map['distance_from_target'] = Variable<double>(distanceFromTarget);
    }
    map['is_location_override'] = Variable<bool>(isLocationOverride);
    if (!nullToAbsent || overrideReason != null) {
      map['override_reason'] = Variable<String>(overrideReason);
    }
    if (!nullToAbsent || rescheduledFromId != null) {
      map['rescheduled_from_id'] = Variable<String>(rescheduledFromId);
    }
    if (!nullToAbsent || rescheduledToId != null) {
      map['rescheduled_to_id'] = Variable<String>(rescheduledToId);
    }
    if (!nullToAbsent || cancelledAt != null) {
      map['cancelled_at'] = Variable<DateTime>(cancelledAt);
    }
    if (!nullToAbsent || cancelReason != null) {
      map['cancel_reason'] = Variable<String>(cancelReason);
    }
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    return map;
  }

  ActivitiesCompanion toCompanion(bool nullToAbsent) {
    return ActivitiesCompanion(
      id: Value(id),
      userId: Value(userId),
      createdBy: Value(createdBy),
      objectType: Value(objectType),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      hvcId: hvcId == null && nullToAbsent
          ? const Value.absent()
          : Value(hvcId),
      brokerId: brokerId == null && nullToAbsent
          ? const Value.absent()
          : Value(brokerId),
      pipelineId: pipelineId == null && nullToAbsent
          ? const Value.absent()
          : Value(pipelineId),
      keyPersonId: keyPersonId == null && nullToAbsent
          ? const Value.absent()
          : Value(keyPersonId),
      activityTypeId: Value(activityTypeId),
      summary: summary == null && nullToAbsent
          ? const Value.absent()
          : Value(summary),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      scheduledDatetime: Value(scheduledDatetime),
      isImmediate: Value(isImmediate),
      status: Value(status),
      executedAt: executedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(executedAt),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      locationAccuracy: locationAccuracy == null && nullToAbsent
          ? const Value.absent()
          : Value(locationAccuracy),
      distanceFromTarget: distanceFromTarget == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceFromTarget),
      isLocationOverride: Value(isLocationOverride),
      overrideReason: overrideReason == null && nullToAbsent
          ? const Value.absent()
          : Value(overrideReason),
      rescheduledFromId: rescheduledFromId == null && nullToAbsent
          ? const Value.absent()
          : Value(rescheduledFromId),
      rescheduledToId: rescheduledToId == null && nullToAbsent
          ? const Value.absent()
          : Value(rescheduledToId),
      cancelledAt: cancelledAt == null && nullToAbsent
          ? const Value.absent()
          : Value(cancelledAt),
      cancelReason: cancelReason == null && nullToAbsent
          ? const Value.absent()
          : Value(cancelReason),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
    );
  }

  factory Activity.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Activity(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      objectType: serializer.fromJson<String>(json['objectType']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      hvcId: serializer.fromJson<String?>(json['hvcId']),
      brokerId: serializer.fromJson<String?>(json['brokerId']),
      pipelineId: serializer.fromJson<String?>(json['pipelineId']),
      keyPersonId: serializer.fromJson<String?>(json['keyPersonId']),
      activityTypeId: serializer.fromJson<String>(json['activityTypeId']),
      summary: serializer.fromJson<String?>(json['summary']),
      notes: serializer.fromJson<String?>(json['notes']),
      scheduledDatetime: serializer.fromJson<DateTime>(
        json['scheduledDatetime'],
      ),
      isImmediate: serializer.fromJson<bool>(json['isImmediate']),
      status: serializer.fromJson<String>(json['status']),
      executedAt: serializer.fromJson<DateTime?>(json['executedAt']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      locationAccuracy: serializer.fromJson<double?>(json['locationAccuracy']),
      distanceFromTarget: serializer.fromJson<double?>(
        json['distanceFromTarget'],
      ),
      isLocationOverride: serializer.fromJson<bool>(json['isLocationOverride']),
      overrideReason: serializer.fromJson<String?>(json['overrideReason']),
      rescheduledFromId: serializer.fromJson<String?>(
        json['rescheduledFromId'],
      ),
      rescheduledToId: serializer.fromJson<String?>(json['rescheduledToId']),
      cancelledAt: serializer.fromJson<DateTime?>(json['cancelledAt']),
      cancelReason: serializer.fromJson<String?>(json['cancelReason']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'createdBy': serializer.toJson<String>(createdBy),
      'objectType': serializer.toJson<String>(objectType),
      'customerId': serializer.toJson<String?>(customerId),
      'hvcId': serializer.toJson<String?>(hvcId),
      'brokerId': serializer.toJson<String?>(brokerId),
      'pipelineId': serializer.toJson<String?>(pipelineId),
      'keyPersonId': serializer.toJson<String?>(keyPersonId),
      'activityTypeId': serializer.toJson<String>(activityTypeId),
      'summary': serializer.toJson<String?>(summary),
      'notes': serializer.toJson<String?>(notes),
      'scheduledDatetime': serializer.toJson<DateTime>(scheduledDatetime),
      'isImmediate': serializer.toJson<bool>(isImmediate),
      'status': serializer.toJson<String>(status),
      'executedAt': serializer.toJson<DateTime?>(executedAt),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'locationAccuracy': serializer.toJson<double?>(locationAccuracy),
      'distanceFromTarget': serializer.toJson<double?>(distanceFromTarget),
      'isLocationOverride': serializer.toJson<bool>(isLocationOverride),
      'overrideReason': serializer.toJson<String?>(overrideReason),
      'rescheduledFromId': serializer.toJson<String?>(rescheduledFromId),
      'rescheduledToId': serializer.toJson<String?>(rescheduledToId),
      'cancelledAt': serializer.toJson<DateTime?>(cancelledAt),
      'cancelReason': serializer.toJson<String?>(cancelReason),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
    };
  }

  Activity copyWith({
    String? id,
    String? userId,
    String? createdBy,
    String? objectType,
    Value<String?> customerId = const Value.absent(),
    Value<String?> hvcId = const Value.absent(),
    Value<String?> brokerId = const Value.absent(),
    Value<String?> pipelineId = const Value.absent(),
    Value<String?> keyPersonId = const Value.absent(),
    String? activityTypeId,
    Value<String?> summary = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? scheduledDatetime,
    bool? isImmediate,
    String? status,
    Value<DateTime?> executedAt = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<double?> locationAccuracy = const Value.absent(),
    Value<double?> distanceFromTarget = const Value.absent(),
    bool? isLocationOverride,
    Value<String?> overrideReason = const Value.absent(),
    Value<String?> rescheduledFromId = const Value.absent(),
    Value<String?> rescheduledToId = const Value.absent(),
    Value<DateTime?> cancelledAt = const Value.absent(),
    Value<String?> cancelReason = const Value.absent(),
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> lastSyncAt = const Value.absent(),
    Value<DateTime?> deletedAt = const Value.absent(),
  }) => Activity(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    createdBy: createdBy ?? this.createdBy,
    objectType: objectType ?? this.objectType,
    customerId: customerId.present ? customerId.value : this.customerId,
    hvcId: hvcId.present ? hvcId.value : this.hvcId,
    brokerId: brokerId.present ? brokerId.value : this.brokerId,
    pipelineId: pipelineId.present ? pipelineId.value : this.pipelineId,
    keyPersonId: keyPersonId.present ? keyPersonId.value : this.keyPersonId,
    activityTypeId: activityTypeId ?? this.activityTypeId,
    summary: summary.present ? summary.value : this.summary,
    notes: notes.present ? notes.value : this.notes,
    scheduledDatetime: scheduledDatetime ?? this.scheduledDatetime,
    isImmediate: isImmediate ?? this.isImmediate,
    status: status ?? this.status,
    executedAt: executedAt.present ? executedAt.value : this.executedAt,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    locationAccuracy: locationAccuracy.present
        ? locationAccuracy.value
        : this.locationAccuracy,
    distanceFromTarget: distanceFromTarget.present
        ? distanceFromTarget.value
        : this.distanceFromTarget,
    isLocationOverride: isLocationOverride ?? this.isLocationOverride,
    overrideReason: overrideReason.present
        ? overrideReason.value
        : this.overrideReason,
    rescheduledFromId: rescheduledFromId.present
        ? rescheduledFromId.value
        : this.rescheduledFromId,
    rescheduledToId: rescheduledToId.present
        ? rescheduledToId.value
        : this.rescheduledToId,
    cancelledAt: cancelledAt.present ? cancelledAt.value : this.cancelledAt,
    cancelReason: cancelReason.present ? cancelReason.value : this.cancelReason,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
  );
  Activity copyWithCompanion(ActivitiesCompanion data) {
    return Activity(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      objectType: data.objectType.present
          ? data.objectType.value
          : this.objectType,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      hvcId: data.hvcId.present ? data.hvcId.value : this.hvcId,
      brokerId: data.brokerId.present ? data.brokerId.value : this.brokerId,
      pipelineId: data.pipelineId.present
          ? data.pipelineId.value
          : this.pipelineId,
      keyPersonId: data.keyPersonId.present
          ? data.keyPersonId.value
          : this.keyPersonId,
      activityTypeId: data.activityTypeId.present
          ? data.activityTypeId.value
          : this.activityTypeId,
      summary: data.summary.present ? data.summary.value : this.summary,
      notes: data.notes.present ? data.notes.value : this.notes,
      scheduledDatetime: data.scheduledDatetime.present
          ? data.scheduledDatetime.value
          : this.scheduledDatetime,
      isImmediate: data.isImmediate.present
          ? data.isImmediate.value
          : this.isImmediate,
      status: data.status.present ? data.status.value : this.status,
      executedAt: data.executedAt.present
          ? data.executedAt.value
          : this.executedAt,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      locationAccuracy: data.locationAccuracy.present
          ? data.locationAccuracy.value
          : this.locationAccuracy,
      distanceFromTarget: data.distanceFromTarget.present
          ? data.distanceFromTarget.value
          : this.distanceFromTarget,
      isLocationOverride: data.isLocationOverride.present
          ? data.isLocationOverride.value
          : this.isLocationOverride,
      overrideReason: data.overrideReason.present
          ? data.overrideReason.value
          : this.overrideReason,
      rescheduledFromId: data.rescheduledFromId.present
          ? data.rescheduledFromId.value
          : this.rescheduledFromId,
      rescheduledToId: data.rescheduledToId.present
          ? data.rescheduledToId.value
          : this.rescheduledToId,
      cancelledAt: data.cancelledAt.present
          ? data.cancelledAt.value
          : this.cancelledAt,
      cancelReason: data.cancelReason.present
          ? data.cancelReason.value
          : this.cancelReason,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Activity(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('createdBy: $createdBy, ')
          ..write('objectType: $objectType, ')
          ..write('customerId: $customerId, ')
          ..write('hvcId: $hvcId, ')
          ..write('brokerId: $brokerId, ')
          ..write('pipelineId: $pipelineId, ')
          ..write('keyPersonId: $keyPersonId, ')
          ..write('activityTypeId: $activityTypeId, ')
          ..write('summary: $summary, ')
          ..write('notes: $notes, ')
          ..write('scheduledDatetime: $scheduledDatetime, ')
          ..write('isImmediate: $isImmediate, ')
          ..write('status: $status, ')
          ..write('executedAt: $executedAt, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('distanceFromTarget: $distanceFromTarget, ')
          ..write('isLocationOverride: $isLocationOverride, ')
          ..write('overrideReason: $overrideReason, ')
          ..write('rescheduledFromId: $rescheduledFromId, ')
          ..write('rescheduledToId: $rescheduledToId, ')
          ..write('cancelledAt: $cancelledAt, ')
          ..write('cancelReason: $cancelReason, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('deletedAt: $deletedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    userId,
    createdBy,
    objectType,
    customerId,
    hvcId,
    brokerId,
    pipelineId,
    keyPersonId,
    activityTypeId,
    summary,
    notes,
    scheduledDatetime,
    isImmediate,
    status,
    executedAt,
    latitude,
    longitude,
    locationAccuracy,
    distanceFromTarget,
    isLocationOverride,
    overrideReason,
    rescheduledFromId,
    rescheduledToId,
    cancelledAt,
    cancelReason,
    isPendingSync,
    createdAt,
    updatedAt,
    lastSyncAt,
    deletedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Activity &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.createdBy == this.createdBy &&
          other.objectType == this.objectType &&
          other.customerId == this.customerId &&
          other.hvcId == this.hvcId &&
          other.brokerId == this.brokerId &&
          other.pipelineId == this.pipelineId &&
          other.keyPersonId == this.keyPersonId &&
          other.activityTypeId == this.activityTypeId &&
          other.summary == this.summary &&
          other.notes == this.notes &&
          other.scheduledDatetime == this.scheduledDatetime &&
          other.isImmediate == this.isImmediate &&
          other.status == this.status &&
          other.executedAt == this.executedAt &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.locationAccuracy == this.locationAccuracy &&
          other.distanceFromTarget == this.distanceFromTarget &&
          other.isLocationOverride == this.isLocationOverride &&
          other.overrideReason == this.overrideReason &&
          other.rescheduledFromId == this.rescheduledFromId &&
          other.rescheduledToId == this.rescheduledToId &&
          other.cancelledAt == this.cancelledAt &&
          other.cancelReason == this.cancelReason &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.lastSyncAt == this.lastSyncAt &&
          other.deletedAt == this.deletedAt);
}

class ActivitiesCompanion extends UpdateCompanion<Activity> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> createdBy;
  final Value<String> objectType;
  final Value<String?> customerId;
  final Value<String?> hvcId;
  final Value<String?> brokerId;
  final Value<String?> pipelineId;
  final Value<String?> keyPersonId;
  final Value<String> activityTypeId;
  final Value<String?> summary;
  final Value<String?> notes;
  final Value<DateTime> scheduledDatetime;
  final Value<bool> isImmediate;
  final Value<String> status;
  final Value<DateTime?> executedAt;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<double?> locationAccuracy;
  final Value<double?> distanceFromTarget;
  final Value<bool> isLocationOverride;
  final Value<String?> overrideReason;
  final Value<String?> rescheduledFromId;
  final Value<String?> rescheduledToId;
  final Value<DateTime?> cancelledAt;
  final Value<String?> cancelReason;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<DateTime?> deletedAt;
  final Value<int> rowid;
  const ActivitiesCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.objectType = const Value.absent(),
    this.customerId = const Value.absent(),
    this.hvcId = const Value.absent(),
    this.brokerId = const Value.absent(),
    this.pipelineId = const Value.absent(),
    this.keyPersonId = const Value.absent(),
    this.activityTypeId = const Value.absent(),
    this.summary = const Value.absent(),
    this.notes = const Value.absent(),
    this.scheduledDatetime = const Value.absent(),
    this.isImmediate = const Value.absent(),
    this.status = const Value.absent(),
    this.executedAt = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.distanceFromTarget = const Value.absent(),
    this.isLocationOverride = const Value.absent(),
    this.overrideReason = const Value.absent(),
    this.rescheduledFromId = const Value.absent(),
    this.rescheduledToId = const Value.absent(),
    this.cancelledAt = const Value.absent(),
    this.cancelReason = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivitiesCompanion.insert({
    required String id,
    required String userId,
    required String createdBy,
    required String objectType,
    this.customerId = const Value.absent(),
    this.hvcId = const Value.absent(),
    this.brokerId = const Value.absent(),
    this.pipelineId = const Value.absent(),
    this.keyPersonId = const Value.absent(),
    required String activityTypeId,
    this.summary = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime scheduledDatetime,
    this.isImmediate = const Value.absent(),
    this.status = const Value.absent(),
    this.executedAt = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.distanceFromTarget = const Value.absent(),
    this.isLocationOverride = const Value.absent(),
    this.overrideReason = const Value.absent(),
    this.rescheduledFromId = const Value.absent(),
    this.rescheduledToId = const Value.absent(),
    this.cancelledAt = const Value.absent(),
    this.cancelReason = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.lastSyncAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       createdBy = Value(createdBy),
       objectType = Value(objectType),
       activityTypeId = Value(activityTypeId),
       scheduledDatetime = Value(scheduledDatetime),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Activity> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? createdBy,
    Expression<String>? objectType,
    Expression<String>? customerId,
    Expression<String>? hvcId,
    Expression<String>? brokerId,
    Expression<String>? pipelineId,
    Expression<String>? keyPersonId,
    Expression<String>? activityTypeId,
    Expression<String>? summary,
    Expression<String>? notes,
    Expression<DateTime>? scheduledDatetime,
    Expression<bool>? isImmediate,
    Expression<String>? status,
    Expression<DateTime>? executedAt,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? locationAccuracy,
    Expression<double>? distanceFromTarget,
    Expression<bool>? isLocationOverride,
    Expression<String>? overrideReason,
    Expression<String>? rescheduledFromId,
    Expression<String>? rescheduledToId,
    Expression<DateTime>? cancelledAt,
    Expression<String>? cancelReason,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<DateTime>? deletedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (createdBy != null) 'created_by': createdBy,
      if (objectType != null) 'object_type': objectType,
      if (customerId != null) 'customer_id': customerId,
      if (hvcId != null) 'hvc_id': hvcId,
      if (brokerId != null) 'broker_id': brokerId,
      if (pipelineId != null) 'pipeline_id': pipelineId,
      if (keyPersonId != null) 'key_person_id': keyPersonId,
      if (activityTypeId != null) 'activity_type_id': activityTypeId,
      if (summary != null) 'summary': summary,
      if (notes != null) 'notes': notes,
      if (scheduledDatetime != null) 'scheduled_datetime': scheduledDatetime,
      if (isImmediate != null) 'is_immediate': isImmediate,
      if (status != null) 'status': status,
      if (executedAt != null) 'executed_at': executedAt,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (locationAccuracy != null) 'location_accuracy': locationAccuracy,
      if (distanceFromTarget != null)
        'distance_from_target': distanceFromTarget,
      if (isLocationOverride != null)
        'is_location_override': isLocationOverride,
      if (overrideReason != null) 'override_reason': overrideReason,
      if (rescheduledFromId != null) 'rescheduled_from_id': rescheduledFromId,
      if (rescheduledToId != null) 'rescheduled_to_id': rescheduledToId,
      if (cancelledAt != null) 'cancelled_at': cancelledAt,
      if (cancelReason != null) 'cancel_reason': cancelReason,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivitiesCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? createdBy,
    Value<String>? objectType,
    Value<String?>? customerId,
    Value<String?>? hvcId,
    Value<String?>? brokerId,
    Value<String?>? pipelineId,
    Value<String?>? keyPersonId,
    Value<String>? activityTypeId,
    Value<String?>? summary,
    Value<String?>? notes,
    Value<DateTime>? scheduledDatetime,
    Value<bool>? isImmediate,
    Value<String>? status,
    Value<DateTime?>? executedAt,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<double?>? locationAccuracy,
    Value<double?>? distanceFromTarget,
    Value<bool>? isLocationOverride,
    Value<String?>? overrideReason,
    Value<String?>? rescheduledFromId,
    Value<String?>? rescheduledToId,
    Value<DateTime?>? cancelledAt,
    Value<String?>? cancelReason,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? lastSyncAt,
    Value<DateTime?>? deletedAt,
    Value<int>? rowid,
  }) {
    return ActivitiesCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      createdBy: createdBy ?? this.createdBy,
      objectType: objectType ?? this.objectType,
      customerId: customerId ?? this.customerId,
      hvcId: hvcId ?? this.hvcId,
      brokerId: brokerId ?? this.brokerId,
      pipelineId: pipelineId ?? this.pipelineId,
      keyPersonId: keyPersonId ?? this.keyPersonId,
      activityTypeId: activityTypeId ?? this.activityTypeId,
      summary: summary ?? this.summary,
      notes: notes ?? this.notes,
      scheduledDatetime: scheduledDatetime ?? this.scheduledDatetime,
      isImmediate: isImmediate ?? this.isImmediate,
      status: status ?? this.status,
      executedAt: executedAt ?? this.executedAt,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      locationAccuracy: locationAccuracy ?? this.locationAccuracy,
      distanceFromTarget: distanceFromTarget ?? this.distanceFromTarget,
      isLocationOverride: isLocationOverride ?? this.isLocationOverride,
      overrideReason: overrideReason ?? this.overrideReason,
      rescheduledFromId: rescheduledFromId ?? this.rescheduledFromId,
      rescheduledToId: rescheduledToId ?? this.rescheduledToId,
      cancelledAt: cancelledAt ?? this.cancelledAt,
      cancelReason: cancelReason ?? this.cancelReason,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      deletedAt: deletedAt ?? this.deletedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (objectType.present) {
      map['object_type'] = Variable<String>(objectType.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (hvcId.present) {
      map['hvc_id'] = Variable<String>(hvcId.value);
    }
    if (brokerId.present) {
      map['broker_id'] = Variable<String>(brokerId.value);
    }
    if (pipelineId.present) {
      map['pipeline_id'] = Variable<String>(pipelineId.value);
    }
    if (keyPersonId.present) {
      map['key_person_id'] = Variable<String>(keyPersonId.value);
    }
    if (activityTypeId.present) {
      map['activity_type_id'] = Variable<String>(activityTypeId.value);
    }
    if (summary.present) {
      map['summary'] = Variable<String>(summary.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (scheduledDatetime.present) {
      map['scheduled_datetime'] = Variable<DateTime>(scheduledDatetime.value);
    }
    if (isImmediate.present) {
      map['is_immediate'] = Variable<bool>(isImmediate.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (executedAt.present) {
      map['executed_at'] = Variable<DateTime>(executedAt.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (locationAccuracy.present) {
      map['location_accuracy'] = Variable<double>(locationAccuracy.value);
    }
    if (distanceFromTarget.present) {
      map['distance_from_target'] = Variable<double>(distanceFromTarget.value);
    }
    if (isLocationOverride.present) {
      map['is_location_override'] = Variable<bool>(isLocationOverride.value);
    }
    if (overrideReason.present) {
      map['override_reason'] = Variable<String>(overrideReason.value);
    }
    if (rescheduledFromId.present) {
      map['rescheduled_from_id'] = Variable<String>(rescheduledFromId.value);
    }
    if (rescheduledToId.present) {
      map['rescheduled_to_id'] = Variable<String>(rescheduledToId.value);
    }
    if (cancelledAt.present) {
      map['cancelled_at'] = Variable<DateTime>(cancelledAt.value);
    }
    if (cancelReason.present) {
      map['cancel_reason'] = Variable<String>(cancelReason.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivitiesCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('createdBy: $createdBy, ')
          ..write('objectType: $objectType, ')
          ..write('customerId: $customerId, ')
          ..write('hvcId: $hvcId, ')
          ..write('brokerId: $brokerId, ')
          ..write('pipelineId: $pipelineId, ')
          ..write('keyPersonId: $keyPersonId, ')
          ..write('activityTypeId: $activityTypeId, ')
          ..write('summary: $summary, ')
          ..write('notes: $notes, ')
          ..write('scheduledDatetime: $scheduledDatetime, ')
          ..write('isImmediate: $isImmediate, ')
          ..write('status: $status, ')
          ..write('executedAt: $executedAt, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('distanceFromTarget: $distanceFromTarget, ')
          ..write('isLocationOverride: $isLocationOverride, ')
          ..write('overrideReason: $overrideReason, ')
          ..write('rescheduledFromId: $rescheduledFromId, ')
          ..write('rescheduledToId: $rescheduledToId, ')
          ..write('cancelledAt: $cancelledAt, ')
          ..write('cancelReason: $cancelReason, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivityPhotosTable extends ActivityPhotos
    with TableInfo<$ActivityPhotosTable, ActivityPhoto> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivityPhotosTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _activityIdMeta = const VerificationMeta(
    'activityId',
  );
  @override
  late final GeneratedColumn<String> activityId = GeneratedColumn<String>(
    'activity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES activities (id)',
    ),
  );
  static const VerificationMeta _photoUrlMeta = const VerificationMeta(
    'photoUrl',
  );
  @override
  late final GeneratedColumn<String> photoUrl = GeneratedColumn<String>(
    'photo_url',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localPathMeta = const VerificationMeta(
    'localPath',
  );
  @override
  late final GeneratedColumn<String> localPath = GeneratedColumn<String>(
    'local_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _captionMeta = const VerificationMeta(
    'caption',
  );
  @override
  late final GeneratedColumn<String> caption = GeneratedColumn<String>(
    'caption',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _takenAtMeta = const VerificationMeta(
    'takenAt',
  );
  @override
  late final GeneratedColumn<DateTime> takenAt = GeneratedColumn<DateTime>(
    'taken_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPendingUploadMeta = const VerificationMeta(
    'isPendingUpload',
  );
  @override
  late final GeneratedColumn<bool> isPendingUpload = GeneratedColumn<bool>(
    'is_pending_upload',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_upload" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    activityId,
    photoUrl,
    localPath,
    caption,
    takenAt,
    latitude,
    longitude,
    isPendingUpload,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activity_photos';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityPhoto> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('activity_id')) {
      context.handle(
        _activityIdMeta,
        activityId.isAcceptableOrUnknown(data['activity_id']!, _activityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_activityIdMeta);
    }
    if (data.containsKey('photo_url')) {
      context.handle(
        _photoUrlMeta,
        photoUrl.isAcceptableOrUnknown(data['photo_url']!, _photoUrlMeta),
      );
    } else if (isInserting) {
      context.missing(_photoUrlMeta);
    }
    if (data.containsKey('local_path')) {
      context.handle(
        _localPathMeta,
        localPath.isAcceptableOrUnknown(data['local_path']!, _localPathMeta),
      );
    }
    if (data.containsKey('caption')) {
      context.handle(
        _captionMeta,
        caption.isAcceptableOrUnknown(data['caption']!, _captionMeta),
      );
    }
    if (data.containsKey('taken_at')) {
      context.handle(
        _takenAtMeta,
        takenAt.isAcceptableOrUnknown(data['taken_at']!, _takenAtMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('is_pending_upload')) {
      context.handle(
        _isPendingUploadMeta,
        isPendingUpload.isAcceptableOrUnknown(
          data['is_pending_upload']!,
          _isPendingUploadMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityPhoto map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityPhoto(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      activityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_id'],
      )!,
      photoUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}photo_url'],
      )!,
      localPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}local_path'],
      ),
      caption: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}caption'],
      ),
      takenAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}taken_at'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      isPendingUpload: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_upload'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ActivityPhotosTable createAlias(String alias) {
    return $ActivityPhotosTable(attachedDatabase, alias);
  }
}

class ActivityPhoto extends DataClass implements Insertable<ActivityPhoto> {
  final String id;
  final String activityId;
  final String photoUrl;
  final String? localPath;
  final String? caption;
  final DateTime? takenAt;
  final double? latitude;
  final double? longitude;
  final bool isPendingUpload;
  final DateTime createdAt;
  const ActivityPhoto({
    required this.id,
    required this.activityId,
    required this.photoUrl,
    this.localPath,
    this.caption,
    this.takenAt,
    this.latitude,
    this.longitude,
    required this.isPendingUpload,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['activity_id'] = Variable<String>(activityId);
    map['photo_url'] = Variable<String>(photoUrl);
    if (!nullToAbsent || localPath != null) {
      map['local_path'] = Variable<String>(localPath);
    }
    if (!nullToAbsent || caption != null) {
      map['caption'] = Variable<String>(caption);
    }
    if (!nullToAbsent || takenAt != null) {
      map['taken_at'] = Variable<DateTime>(takenAt);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    map['is_pending_upload'] = Variable<bool>(isPendingUpload);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ActivityPhotosCompanion toCompanion(bool nullToAbsent) {
    return ActivityPhotosCompanion(
      id: Value(id),
      activityId: Value(activityId),
      photoUrl: Value(photoUrl),
      localPath: localPath == null && nullToAbsent
          ? const Value.absent()
          : Value(localPath),
      caption: caption == null && nullToAbsent
          ? const Value.absent()
          : Value(caption),
      takenAt: takenAt == null && nullToAbsent
          ? const Value.absent()
          : Value(takenAt),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      isPendingUpload: Value(isPendingUpload),
      createdAt: Value(createdAt),
    );
  }

  factory ActivityPhoto.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityPhoto(
      id: serializer.fromJson<String>(json['id']),
      activityId: serializer.fromJson<String>(json['activityId']),
      photoUrl: serializer.fromJson<String>(json['photoUrl']),
      localPath: serializer.fromJson<String?>(json['localPath']),
      caption: serializer.fromJson<String?>(json['caption']),
      takenAt: serializer.fromJson<DateTime?>(json['takenAt']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      isPendingUpload: serializer.fromJson<bool>(json['isPendingUpload']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'activityId': serializer.toJson<String>(activityId),
      'photoUrl': serializer.toJson<String>(photoUrl),
      'localPath': serializer.toJson<String?>(localPath),
      'caption': serializer.toJson<String?>(caption),
      'takenAt': serializer.toJson<DateTime?>(takenAt),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'isPendingUpload': serializer.toJson<bool>(isPendingUpload),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ActivityPhoto copyWith({
    String? id,
    String? activityId,
    String? photoUrl,
    Value<String?> localPath = const Value.absent(),
    Value<String?> caption = const Value.absent(),
    Value<DateTime?> takenAt = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    bool? isPendingUpload,
    DateTime? createdAt,
  }) => ActivityPhoto(
    id: id ?? this.id,
    activityId: activityId ?? this.activityId,
    photoUrl: photoUrl ?? this.photoUrl,
    localPath: localPath.present ? localPath.value : this.localPath,
    caption: caption.present ? caption.value : this.caption,
    takenAt: takenAt.present ? takenAt.value : this.takenAt,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    isPendingUpload: isPendingUpload ?? this.isPendingUpload,
    createdAt: createdAt ?? this.createdAt,
  );
  ActivityPhoto copyWithCompanion(ActivityPhotosCompanion data) {
    return ActivityPhoto(
      id: data.id.present ? data.id.value : this.id,
      activityId: data.activityId.present
          ? data.activityId.value
          : this.activityId,
      photoUrl: data.photoUrl.present ? data.photoUrl.value : this.photoUrl,
      localPath: data.localPath.present ? data.localPath.value : this.localPath,
      caption: data.caption.present ? data.caption.value : this.caption,
      takenAt: data.takenAt.present ? data.takenAt.value : this.takenAt,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      isPendingUpload: data.isPendingUpload.present
          ? data.isPendingUpload.value
          : this.isPendingUpload,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityPhoto(')
          ..write('id: $id, ')
          ..write('activityId: $activityId, ')
          ..write('photoUrl: $photoUrl, ')
          ..write('localPath: $localPath, ')
          ..write('caption: $caption, ')
          ..write('takenAt: $takenAt, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('isPendingUpload: $isPendingUpload, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    activityId,
    photoUrl,
    localPath,
    caption,
    takenAt,
    latitude,
    longitude,
    isPendingUpload,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityPhoto &&
          other.id == this.id &&
          other.activityId == this.activityId &&
          other.photoUrl == this.photoUrl &&
          other.localPath == this.localPath &&
          other.caption == this.caption &&
          other.takenAt == this.takenAt &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.isPendingUpload == this.isPendingUpload &&
          other.createdAt == this.createdAt);
}

class ActivityPhotosCompanion extends UpdateCompanion<ActivityPhoto> {
  final Value<String> id;
  final Value<String> activityId;
  final Value<String> photoUrl;
  final Value<String?> localPath;
  final Value<String?> caption;
  final Value<DateTime?> takenAt;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<bool> isPendingUpload;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ActivityPhotosCompanion({
    this.id = const Value.absent(),
    this.activityId = const Value.absent(),
    this.photoUrl = const Value.absent(),
    this.localPath = const Value.absent(),
    this.caption = const Value.absent(),
    this.takenAt = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.isPendingUpload = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivityPhotosCompanion.insert({
    required String id,
    required String activityId,
    required String photoUrl,
    this.localPath = const Value.absent(),
    this.caption = const Value.absent(),
    this.takenAt = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.isPendingUpload = const Value.absent(),
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       activityId = Value(activityId),
       photoUrl = Value(photoUrl),
       createdAt = Value(createdAt);
  static Insertable<ActivityPhoto> custom({
    Expression<String>? id,
    Expression<String>? activityId,
    Expression<String>? photoUrl,
    Expression<String>? localPath,
    Expression<String>? caption,
    Expression<DateTime>? takenAt,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<bool>? isPendingUpload,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (activityId != null) 'activity_id': activityId,
      if (photoUrl != null) 'photo_url': photoUrl,
      if (localPath != null) 'local_path': localPath,
      if (caption != null) 'caption': caption,
      if (takenAt != null) 'taken_at': takenAt,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (isPendingUpload != null) 'is_pending_upload': isPendingUpload,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivityPhotosCompanion copyWith({
    Value<String>? id,
    Value<String>? activityId,
    Value<String>? photoUrl,
    Value<String?>? localPath,
    Value<String?>? caption,
    Value<DateTime?>? takenAt,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<bool>? isPendingUpload,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ActivityPhotosCompanion(
      id: id ?? this.id,
      activityId: activityId ?? this.activityId,
      photoUrl: photoUrl ?? this.photoUrl,
      localPath: localPath ?? this.localPath,
      caption: caption ?? this.caption,
      takenAt: takenAt ?? this.takenAt,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      isPendingUpload: isPendingUpload ?? this.isPendingUpload,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (activityId.present) {
      map['activity_id'] = Variable<String>(activityId.value);
    }
    if (photoUrl.present) {
      map['photo_url'] = Variable<String>(photoUrl.value);
    }
    if (localPath.present) {
      map['local_path'] = Variable<String>(localPath.value);
    }
    if (caption.present) {
      map['caption'] = Variable<String>(caption.value);
    }
    if (takenAt.present) {
      map['taken_at'] = Variable<DateTime>(takenAt.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (isPendingUpload.present) {
      map['is_pending_upload'] = Variable<bool>(isPendingUpload.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivityPhotosCompanion(')
          ..write('id: $id, ')
          ..write('activityId: $activityId, ')
          ..write('photoUrl: $photoUrl, ')
          ..write('localPath: $localPath, ')
          ..write('caption: $caption, ')
          ..write('takenAt: $takenAt, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('isPendingUpload: $isPendingUpload, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivityAuditLogsTable extends ActivityAuditLogs
    with TableInfo<$ActivityAuditLogsTable, ActivityAuditLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivityAuditLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _activityIdMeta = const VerificationMeta(
    'activityId',
  );
  @override
  late final GeneratedColumn<String> activityId = GeneratedColumn<String>(
    'activity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES activities (id)',
    ),
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _oldStatusMeta = const VerificationMeta(
    'oldStatus',
  );
  @override
  late final GeneratedColumn<String> oldStatus = GeneratedColumn<String>(
    'old_status',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _newStatusMeta = const VerificationMeta(
    'newStatus',
  );
  @override
  late final GeneratedColumn<String> newStatus = GeneratedColumn<String>(
    'new_status',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _oldValuesMeta = const VerificationMeta(
    'oldValues',
  );
  @override
  late final GeneratedColumn<String> oldValues = GeneratedColumn<String>(
    'old_values',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _newValuesMeta = const VerificationMeta(
    'newValues',
  );
  @override
  late final GeneratedColumn<String> newValues = GeneratedColumn<String>(
    'new_values',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _changedFieldsMeta = const VerificationMeta(
    'changedFields',
  );
  @override
  late final GeneratedColumn<String> changedFields = GeneratedColumn<String>(
    'changed_fields',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deviceInfoMeta = const VerificationMeta(
    'deviceInfo',
  );
  @override
  late final GeneratedColumn<String> deviceInfo = GeneratedColumn<String>(
    'device_info',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _performedByMeta = const VerificationMeta(
    'performedBy',
  );
  @override
  late final GeneratedColumn<String> performedBy = GeneratedColumn<String>(
    'performed_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _performedAtMeta = const VerificationMeta(
    'performedAt',
  );
  @override
  late final GeneratedColumn<DateTime> performedAt = GeneratedColumn<DateTime>(
    'performed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    activityId,
    action,
    oldStatus,
    newStatus,
    oldValues,
    newValues,
    changedFields,
    latitude,
    longitude,
    deviceInfo,
    performedBy,
    performedAt,
    notes,
    isSynced,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activity_audit_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityAuditLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('activity_id')) {
      context.handle(
        _activityIdMeta,
        activityId.isAcceptableOrUnknown(data['activity_id']!, _activityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_activityIdMeta);
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('old_status')) {
      context.handle(
        _oldStatusMeta,
        oldStatus.isAcceptableOrUnknown(data['old_status']!, _oldStatusMeta),
      );
    }
    if (data.containsKey('new_status')) {
      context.handle(
        _newStatusMeta,
        newStatus.isAcceptableOrUnknown(data['new_status']!, _newStatusMeta),
      );
    }
    if (data.containsKey('old_values')) {
      context.handle(
        _oldValuesMeta,
        oldValues.isAcceptableOrUnknown(data['old_values']!, _oldValuesMeta),
      );
    }
    if (data.containsKey('new_values')) {
      context.handle(
        _newValuesMeta,
        newValues.isAcceptableOrUnknown(data['new_values']!, _newValuesMeta),
      );
    }
    if (data.containsKey('changed_fields')) {
      context.handle(
        _changedFieldsMeta,
        changedFields.isAcceptableOrUnknown(
          data['changed_fields']!,
          _changedFieldsMeta,
        ),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('device_info')) {
      context.handle(
        _deviceInfoMeta,
        deviceInfo.isAcceptableOrUnknown(data['device_info']!, _deviceInfoMeta),
      );
    }
    if (data.containsKey('performed_by')) {
      context.handle(
        _performedByMeta,
        performedBy.isAcceptableOrUnknown(
          data['performed_by']!,
          _performedByMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_performedByMeta);
    }
    if (data.containsKey('performed_at')) {
      context.handle(
        _performedAtMeta,
        performedAt.isAcceptableOrUnknown(
          data['performed_at']!,
          _performedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_performedAtMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityAuditLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityAuditLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      activityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_id'],
      )!,
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      oldStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}old_status'],
      ),
      newStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}new_status'],
      ),
      oldValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}old_values'],
      ),
      newValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}new_values'],
      ),
      changedFields: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}changed_fields'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      deviceInfo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_info'],
      ),
      performedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}performed_by'],
      )!,
      performedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}performed_at'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
    );
  }

  @override
  $ActivityAuditLogsTable createAlias(String alias) {
    return $ActivityAuditLogsTable(attachedDatabase, alias);
  }
}

class ActivityAuditLog extends DataClass
    implements Insertable<ActivityAuditLog> {
  final String id;
  final String activityId;
  final String action;
  final String? oldStatus;
  final String? newStatus;
  final String? oldValues;
  final String? newValues;
  final String? changedFields;
  final double? latitude;
  final double? longitude;
  final String? deviceInfo;
  final String performedBy;
  final DateTime performedAt;
  final String? notes;
  final bool isSynced;
  const ActivityAuditLog({
    required this.id,
    required this.activityId,
    required this.action,
    this.oldStatus,
    this.newStatus,
    this.oldValues,
    this.newValues,
    this.changedFields,
    this.latitude,
    this.longitude,
    this.deviceInfo,
    required this.performedBy,
    required this.performedAt,
    this.notes,
    required this.isSynced,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['activity_id'] = Variable<String>(activityId);
    map['action'] = Variable<String>(action);
    if (!nullToAbsent || oldStatus != null) {
      map['old_status'] = Variable<String>(oldStatus);
    }
    if (!nullToAbsent || newStatus != null) {
      map['new_status'] = Variable<String>(newStatus);
    }
    if (!nullToAbsent || oldValues != null) {
      map['old_values'] = Variable<String>(oldValues);
    }
    if (!nullToAbsent || newValues != null) {
      map['new_values'] = Variable<String>(newValues);
    }
    if (!nullToAbsent || changedFields != null) {
      map['changed_fields'] = Variable<String>(changedFields);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || deviceInfo != null) {
      map['device_info'] = Variable<String>(deviceInfo);
    }
    map['performed_by'] = Variable<String>(performedBy);
    map['performed_at'] = Variable<DateTime>(performedAt);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  ActivityAuditLogsCompanion toCompanion(bool nullToAbsent) {
    return ActivityAuditLogsCompanion(
      id: Value(id),
      activityId: Value(activityId),
      action: Value(action),
      oldStatus: oldStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(oldStatus),
      newStatus: newStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(newStatus),
      oldValues: oldValues == null && nullToAbsent
          ? const Value.absent()
          : Value(oldValues),
      newValues: newValues == null && nullToAbsent
          ? const Value.absent()
          : Value(newValues),
      changedFields: changedFields == null && nullToAbsent
          ? const Value.absent()
          : Value(changedFields),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      deviceInfo: deviceInfo == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceInfo),
      performedBy: Value(performedBy),
      performedAt: Value(performedAt),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isSynced: Value(isSynced),
    );
  }

  factory ActivityAuditLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityAuditLog(
      id: serializer.fromJson<String>(json['id']),
      activityId: serializer.fromJson<String>(json['activityId']),
      action: serializer.fromJson<String>(json['action']),
      oldStatus: serializer.fromJson<String?>(json['oldStatus']),
      newStatus: serializer.fromJson<String?>(json['newStatus']),
      oldValues: serializer.fromJson<String?>(json['oldValues']),
      newValues: serializer.fromJson<String?>(json['newValues']),
      changedFields: serializer.fromJson<String?>(json['changedFields']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      deviceInfo: serializer.fromJson<String?>(json['deviceInfo']),
      performedBy: serializer.fromJson<String>(json['performedBy']),
      performedAt: serializer.fromJson<DateTime>(json['performedAt']),
      notes: serializer.fromJson<String?>(json['notes']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'activityId': serializer.toJson<String>(activityId),
      'action': serializer.toJson<String>(action),
      'oldStatus': serializer.toJson<String?>(oldStatus),
      'newStatus': serializer.toJson<String?>(newStatus),
      'oldValues': serializer.toJson<String?>(oldValues),
      'newValues': serializer.toJson<String?>(newValues),
      'changedFields': serializer.toJson<String?>(changedFields),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'deviceInfo': serializer.toJson<String?>(deviceInfo),
      'performedBy': serializer.toJson<String>(performedBy),
      'performedAt': serializer.toJson<DateTime>(performedAt),
      'notes': serializer.toJson<String?>(notes),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  ActivityAuditLog copyWith({
    String? id,
    String? activityId,
    String? action,
    Value<String?> oldStatus = const Value.absent(),
    Value<String?> newStatus = const Value.absent(),
    Value<String?> oldValues = const Value.absent(),
    Value<String?> newValues = const Value.absent(),
    Value<String?> changedFields = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<String?> deviceInfo = const Value.absent(),
    String? performedBy,
    DateTime? performedAt,
    Value<String?> notes = const Value.absent(),
    bool? isSynced,
  }) => ActivityAuditLog(
    id: id ?? this.id,
    activityId: activityId ?? this.activityId,
    action: action ?? this.action,
    oldStatus: oldStatus.present ? oldStatus.value : this.oldStatus,
    newStatus: newStatus.present ? newStatus.value : this.newStatus,
    oldValues: oldValues.present ? oldValues.value : this.oldValues,
    newValues: newValues.present ? newValues.value : this.newValues,
    changedFields: changedFields.present
        ? changedFields.value
        : this.changedFields,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    deviceInfo: deviceInfo.present ? deviceInfo.value : this.deviceInfo,
    performedBy: performedBy ?? this.performedBy,
    performedAt: performedAt ?? this.performedAt,
    notes: notes.present ? notes.value : this.notes,
    isSynced: isSynced ?? this.isSynced,
  );
  ActivityAuditLog copyWithCompanion(ActivityAuditLogsCompanion data) {
    return ActivityAuditLog(
      id: data.id.present ? data.id.value : this.id,
      activityId: data.activityId.present
          ? data.activityId.value
          : this.activityId,
      action: data.action.present ? data.action.value : this.action,
      oldStatus: data.oldStatus.present ? data.oldStatus.value : this.oldStatus,
      newStatus: data.newStatus.present ? data.newStatus.value : this.newStatus,
      oldValues: data.oldValues.present ? data.oldValues.value : this.oldValues,
      newValues: data.newValues.present ? data.newValues.value : this.newValues,
      changedFields: data.changedFields.present
          ? data.changedFields.value
          : this.changedFields,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      deviceInfo: data.deviceInfo.present
          ? data.deviceInfo.value
          : this.deviceInfo,
      performedBy: data.performedBy.present
          ? data.performedBy.value
          : this.performedBy,
      performedAt: data.performedAt.present
          ? data.performedAt.value
          : this.performedAt,
      notes: data.notes.present ? data.notes.value : this.notes,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityAuditLog(')
          ..write('id: $id, ')
          ..write('activityId: $activityId, ')
          ..write('action: $action, ')
          ..write('oldStatus: $oldStatus, ')
          ..write('newStatus: $newStatus, ')
          ..write('oldValues: $oldValues, ')
          ..write('newValues: $newValues, ')
          ..write('changedFields: $changedFields, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('deviceInfo: $deviceInfo, ')
          ..write('performedBy: $performedBy, ')
          ..write('performedAt: $performedAt, ')
          ..write('notes: $notes, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    activityId,
    action,
    oldStatus,
    newStatus,
    oldValues,
    newValues,
    changedFields,
    latitude,
    longitude,
    deviceInfo,
    performedBy,
    performedAt,
    notes,
    isSynced,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityAuditLog &&
          other.id == this.id &&
          other.activityId == this.activityId &&
          other.action == this.action &&
          other.oldStatus == this.oldStatus &&
          other.newStatus == this.newStatus &&
          other.oldValues == this.oldValues &&
          other.newValues == this.newValues &&
          other.changedFields == this.changedFields &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.deviceInfo == this.deviceInfo &&
          other.performedBy == this.performedBy &&
          other.performedAt == this.performedAt &&
          other.notes == this.notes &&
          other.isSynced == this.isSynced);
}

class ActivityAuditLogsCompanion extends UpdateCompanion<ActivityAuditLog> {
  final Value<String> id;
  final Value<String> activityId;
  final Value<String> action;
  final Value<String?> oldStatus;
  final Value<String?> newStatus;
  final Value<String?> oldValues;
  final Value<String?> newValues;
  final Value<String?> changedFields;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> deviceInfo;
  final Value<String> performedBy;
  final Value<DateTime> performedAt;
  final Value<String?> notes;
  final Value<bool> isSynced;
  final Value<int> rowid;
  const ActivityAuditLogsCompanion({
    this.id = const Value.absent(),
    this.activityId = const Value.absent(),
    this.action = const Value.absent(),
    this.oldStatus = const Value.absent(),
    this.newStatus = const Value.absent(),
    this.oldValues = const Value.absent(),
    this.newValues = const Value.absent(),
    this.changedFields = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.deviceInfo = const Value.absent(),
    this.performedBy = const Value.absent(),
    this.performedAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivityAuditLogsCompanion.insert({
    required String id,
    required String activityId,
    required String action,
    this.oldStatus = const Value.absent(),
    this.newStatus = const Value.absent(),
    this.oldValues = const Value.absent(),
    this.newValues = const Value.absent(),
    this.changedFields = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.deviceInfo = const Value.absent(),
    required String performedBy,
    required DateTime performedAt,
    this.notes = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       activityId = Value(activityId),
       action = Value(action),
       performedBy = Value(performedBy),
       performedAt = Value(performedAt);
  static Insertable<ActivityAuditLog> custom({
    Expression<String>? id,
    Expression<String>? activityId,
    Expression<String>? action,
    Expression<String>? oldStatus,
    Expression<String>? newStatus,
    Expression<String>? oldValues,
    Expression<String>? newValues,
    Expression<String>? changedFields,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? deviceInfo,
    Expression<String>? performedBy,
    Expression<DateTime>? performedAt,
    Expression<String>? notes,
    Expression<bool>? isSynced,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (activityId != null) 'activity_id': activityId,
      if (action != null) 'action': action,
      if (oldStatus != null) 'old_status': oldStatus,
      if (newStatus != null) 'new_status': newStatus,
      if (oldValues != null) 'old_values': oldValues,
      if (newValues != null) 'new_values': newValues,
      if (changedFields != null) 'changed_fields': changedFields,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (deviceInfo != null) 'device_info': deviceInfo,
      if (performedBy != null) 'performed_by': performedBy,
      if (performedAt != null) 'performed_at': performedAt,
      if (notes != null) 'notes': notes,
      if (isSynced != null) 'is_synced': isSynced,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivityAuditLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? activityId,
    Value<String>? action,
    Value<String?>? oldStatus,
    Value<String?>? newStatus,
    Value<String?>? oldValues,
    Value<String?>? newValues,
    Value<String?>? changedFields,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String?>? deviceInfo,
    Value<String>? performedBy,
    Value<DateTime>? performedAt,
    Value<String?>? notes,
    Value<bool>? isSynced,
    Value<int>? rowid,
  }) {
    return ActivityAuditLogsCompanion(
      id: id ?? this.id,
      activityId: activityId ?? this.activityId,
      action: action ?? this.action,
      oldStatus: oldStatus ?? this.oldStatus,
      newStatus: newStatus ?? this.newStatus,
      oldValues: oldValues ?? this.oldValues,
      newValues: newValues ?? this.newValues,
      changedFields: changedFields ?? this.changedFields,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      deviceInfo: deviceInfo ?? this.deviceInfo,
      performedBy: performedBy ?? this.performedBy,
      performedAt: performedAt ?? this.performedAt,
      notes: notes ?? this.notes,
      isSynced: isSynced ?? this.isSynced,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (activityId.present) {
      map['activity_id'] = Variable<String>(activityId.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (oldStatus.present) {
      map['old_status'] = Variable<String>(oldStatus.value);
    }
    if (newStatus.present) {
      map['new_status'] = Variable<String>(newStatus.value);
    }
    if (oldValues.present) {
      map['old_values'] = Variable<String>(oldValues.value);
    }
    if (newValues.present) {
      map['new_values'] = Variable<String>(newValues.value);
    }
    if (changedFields.present) {
      map['changed_fields'] = Variable<String>(changedFields.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (deviceInfo.present) {
      map['device_info'] = Variable<String>(deviceInfo.value);
    }
    if (performedBy.present) {
      map['performed_by'] = Variable<String>(performedBy.value);
    }
    if (performedAt.present) {
      map['performed_at'] = Variable<DateTime>(performedAt.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivityAuditLogsCompanion(')
          ..write('id: $id, ')
          ..write('activityId: $activityId, ')
          ..write('action: $action, ')
          ..write('oldStatus: $oldStatus, ')
          ..write('newStatus: $newStatus, ')
          ..write('oldValues: $oldValues, ')
          ..write('newValues: $newValues, ')
          ..write('changedFields: $changedFields, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('deviceInfo: $deviceInfo, ')
          ..write('performedBy: $performedBy, ')
          ..write('performedAt: $performedAt, ')
          ..write('notes: $notes, ')
          ..write('isSynced: $isSynced, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HvcTypesTable extends HvcTypes with TableInfo<$HvcTypesTable, HvcType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HvcTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    description,
    sortOrder,
    isActive,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'hvc_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<HvcType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  HvcType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HvcType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
    );
  }

  @override
  $HvcTypesTable createAlias(String alias) {
    return $HvcTypesTable(attachedDatabase, alias);
  }
}

class HvcType extends DataClass implements Insertable<HvcType> {
  final String id;
  final String code;
  final String name;
  final String? description;
  final int sortOrder;
  final bool isActive;
  const HvcType({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    required this.sortOrder,
    required this.isActive,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  HvcTypesCompanion toCompanion(bool nullToAbsent) {
    return HvcTypesCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      sortOrder: Value(sortOrder),
      isActive: Value(isActive),
    );
  }

  factory HvcType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HvcType(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  HvcType copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    int? sortOrder,
    bool? isActive,
  }) => HvcType(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    isActive: isActive ?? this.isActive,
  );
  HvcType copyWithCompanion(HvcTypesCompanion data) {
    return HvcType(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('HvcType(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, code, name, description, sortOrder, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HvcType &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.sortOrder == this.sortOrder &&
          other.isActive == this.isActive);
}

class HvcTypesCompanion extends UpdateCompanion<HvcType> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> sortOrder;
  final Value<bool> isActive;
  final Value<int> rowid;
  const HvcTypesCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HvcTypesCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.description = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name);
  static Insertable<HvcType> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? sortOrder,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HvcTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? sortOrder,
    Value<bool>? isActive,
    Value<int>? rowid,
  }) {
    return HvcTypesCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      sortOrder: sortOrder ?? this.sortOrder,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HvcTypesCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HvcsTable extends Hvcs with TableInfo<$HvcsTable, Hvc> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HvcsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIdMeta = const VerificationMeta('typeId');
  @override
  late final GeneratedColumn<String> typeId = GeneratedColumn<String>(
    'type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES hvc_types (id)',
    ),
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _radiusMetersMeta = const VerificationMeta(
    'radiusMeters',
  );
  @override
  late final GeneratedColumn<int> radiusMeters = GeneratedColumn<int>(
    'radius_meters',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(500),
  );
  static const VerificationMeta _potentialValueMeta = const VerificationMeta(
    'potentialValue',
  );
  @override
  late final GeneratedColumn<double> potentialValue = GeneratedColumn<double>(
    'potential_value',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    typeId,
    description,
    address,
    latitude,
    longitude,
    radiusMeters,
    potentialValue,
    imageUrl,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'hvcs';
  @override
  VerificationContext validateIntegrity(
    Insertable<Hvc> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('type_id')) {
      context.handle(
        _typeIdMeta,
        typeId.isAcceptableOrUnknown(data['type_id']!, _typeIdMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIdMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('radius_meters')) {
      context.handle(
        _radiusMetersMeta,
        radiusMeters.isAcceptableOrUnknown(
          data['radius_meters']!,
          _radiusMetersMeta,
        ),
      );
    }
    if (data.containsKey('potential_value')) {
      context.handle(
        _potentialValueMeta,
        potentialValue.isAcceptableOrUnknown(
          data['potential_value']!,
          _potentialValueMeta,
        ),
      );
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Hvc map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Hvc(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      typeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type_id'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      radiusMeters: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}radius_meters'],
      )!,
      potentialValue: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}potential_value'],
      ),
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $HvcsTable createAlias(String alias) {
    return $HvcsTable(attachedDatabase, alias);
  }
}

class Hvc extends DataClass implements Insertable<Hvc> {
  final String id;
  final String code;
  final String name;
  final String typeId;
  final String? description;
  final String? address;
  final double? latitude;
  final double? longitude;
  final int radiusMeters;
  final double? potentialValue;
  final String? imageUrl;
  final bool isActive;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const Hvc({
    required this.id,
    required this.code,
    required this.name,
    required this.typeId,
    this.description,
    this.address,
    this.latitude,
    this.longitude,
    required this.radiusMeters,
    this.potentialValue,
    this.imageUrl,
    required this.isActive,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    map['type_id'] = Variable<String>(typeId);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    map['radius_meters'] = Variable<int>(radiusMeters);
    if (!nullToAbsent || potentialValue != null) {
      map['potential_value'] = Variable<double>(potentialValue);
    }
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  HvcsCompanion toCompanion(bool nullToAbsent) {
    return HvcsCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      typeId: Value(typeId),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      radiusMeters: Value(radiusMeters),
      potentialValue: potentialValue == null && nullToAbsent
          ? const Value.absent()
          : Value(potentialValue),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      isActive: Value(isActive),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory Hvc.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Hvc(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      typeId: serializer.fromJson<String>(json['typeId']),
      description: serializer.fromJson<String?>(json['description']),
      address: serializer.fromJson<String?>(json['address']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      radiusMeters: serializer.fromJson<int>(json['radiusMeters']),
      potentialValue: serializer.fromJson<double?>(json['potentialValue']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'typeId': serializer.toJson<String>(typeId),
      'description': serializer.toJson<String?>(description),
      'address': serializer.toJson<String?>(address),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'radiusMeters': serializer.toJson<int>(radiusMeters),
      'potentialValue': serializer.toJson<double?>(potentialValue),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'isActive': serializer.toJson<bool>(isActive),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  Hvc copyWith({
    String? id,
    String? code,
    String? name,
    String? typeId,
    Value<String?> description = const Value.absent(),
    Value<String?> address = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    int? radiusMeters,
    Value<double?> potentialValue = const Value.absent(),
    Value<String?> imageUrl = const Value.absent(),
    bool? isActive,
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => Hvc(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    typeId: typeId ?? this.typeId,
    description: description.present ? description.value : this.description,
    address: address.present ? address.value : this.address,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    radiusMeters: radiusMeters ?? this.radiusMeters,
    potentialValue: potentialValue.present
        ? potentialValue.value
        : this.potentialValue,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    isActive: isActive ?? this.isActive,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  Hvc copyWithCompanion(HvcsCompanion data) {
    return Hvc(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      typeId: data.typeId.present ? data.typeId.value : this.typeId,
      description: data.description.present
          ? data.description.value
          : this.description,
      address: data.address.present ? data.address.value : this.address,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      radiusMeters: data.radiusMeters.present
          ? data.radiusMeters.value
          : this.radiusMeters,
      potentialValue: data.potentialValue.present
          ? data.potentialValue.value
          : this.potentialValue,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Hvc(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('typeId: $typeId, ')
          ..write('description: $description, ')
          ..write('address: $address, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('radiusMeters: $radiusMeters, ')
          ..write('potentialValue: $potentialValue, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    typeId,
    description,
    address,
    latitude,
    longitude,
    radiusMeters,
    potentialValue,
    imageUrl,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Hvc &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.typeId == this.typeId &&
          other.description == this.description &&
          other.address == this.address &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.radiusMeters == this.radiusMeters &&
          other.potentialValue == this.potentialValue &&
          other.imageUrl == this.imageUrl &&
          other.isActive == this.isActive &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class HvcsCompanion extends UpdateCompanion<Hvc> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String> typeId;
  final Value<String?> description;
  final Value<String?> address;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<int> radiusMeters;
  final Value<double?> potentialValue;
  final Value<String?> imageUrl;
  final Value<bool> isActive;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const HvcsCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.typeId = const Value.absent(),
    this.description = const Value.absent(),
    this.address = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.radiusMeters = const Value.absent(),
    this.potentialValue = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HvcsCompanion.insert({
    required String id,
    required String code,
    required String name,
    required String typeId,
    this.description = const Value.absent(),
    this.address = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.radiusMeters = const Value.absent(),
    this.potentialValue = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.isActive = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       typeId = Value(typeId),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Hvc> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? typeId,
    Expression<String>? description,
    Expression<String>? address,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<int>? radiusMeters,
    Expression<double>? potentialValue,
    Expression<String>? imageUrl,
    Expression<bool>? isActive,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (typeId != null) 'type_id': typeId,
      if (description != null) 'description': description,
      if (address != null) 'address': address,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (radiusMeters != null) 'radius_meters': radiusMeters,
      if (potentialValue != null) 'potential_value': potentialValue,
      if (imageUrl != null) 'image_url': imageUrl,
      if (isActive != null) 'is_active': isActive,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HvcsCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String>? typeId,
    Value<String?>? description,
    Value<String?>? address,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<int>? radiusMeters,
    Value<double?>? potentialValue,
    Value<String?>? imageUrl,
    Value<bool>? isActive,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return HvcsCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      typeId: typeId ?? this.typeId,
      description: description ?? this.description,
      address: address ?? this.address,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      radiusMeters: radiusMeters ?? this.radiusMeters,
      potentialValue: potentialValue ?? this.potentialValue,
      imageUrl: imageUrl ?? this.imageUrl,
      isActive: isActive ?? this.isActive,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (typeId.present) {
      map['type_id'] = Variable<String>(typeId.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (radiusMeters.present) {
      map['radius_meters'] = Variable<int>(radiusMeters.value);
    }
    if (potentialValue.present) {
      map['potential_value'] = Variable<double>(potentialValue.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HvcsCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('typeId: $typeId, ')
          ..write('description: $description, ')
          ..write('address: $address, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('radiusMeters: $radiusMeters, ')
          ..write('potentialValue: $potentialValue, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CustomerHvcLinksTable extends CustomerHvcLinks
    with TableInfo<$CustomerHvcLinksTable, CustomerHvcLink> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerHvcLinksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _customerIdMeta = const VerificationMeta(
    'customerId',
  );
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
    'customer_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _hvcIdMeta = const VerificationMeta('hvcId');
  @override
  late final GeneratedColumn<String> hvcId = GeneratedColumn<String>(
    'hvc_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES hvcs (id)',
    ),
  );
  static const VerificationMeta _relationshipTypeMeta = const VerificationMeta(
    'relationshipType',
  );
  @override
  late final GeneratedColumn<String> relationshipType = GeneratedColumn<String>(
    'relationship_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    customerId,
    hvcId,
    relationshipType,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer_hvc_links';
  @override
  VerificationContext validateIntegrity(
    Insertable<CustomerHvcLink> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
        _customerIdMeta,
        customerId.isAcceptableOrUnknown(data['customer_id']!, _customerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('hvc_id')) {
      context.handle(
        _hvcIdMeta,
        hvcId.isAcceptableOrUnknown(data['hvc_id']!, _hvcIdMeta),
      );
    } else if (isInserting) {
      context.missing(_hvcIdMeta);
    }
    if (data.containsKey('relationship_type')) {
      context.handle(
        _relationshipTypeMeta,
        relationshipType.isAcceptableOrUnknown(
          data['relationship_type']!,
          _relationshipTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_relationshipTypeMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CustomerHvcLink map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerHvcLink(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      customerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}customer_id'],
      )!,
      hvcId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}hvc_id'],
      )!,
      relationshipType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}relationship_type'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $CustomerHvcLinksTable createAlias(String alias) {
    return $CustomerHvcLinksTable(attachedDatabase, alias);
  }
}

class CustomerHvcLink extends DataClass implements Insertable<CustomerHvcLink> {
  final String id;
  final String customerId;
  final String hvcId;
  final String relationshipType;
  final bool isActive;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const CustomerHvcLink({
    required this.id,
    required this.customerId,
    required this.hvcId,
    required this.relationshipType,
    required this.isActive,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['customer_id'] = Variable<String>(customerId);
    map['hvc_id'] = Variable<String>(hvcId);
    map['relationship_type'] = Variable<String>(relationshipType);
    map['is_active'] = Variable<bool>(isActive);
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  CustomerHvcLinksCompanion toCompanion(bool nullToAbsent) {
    return CustomerHvcLinksCompanion(
      id: Value(id),
      customerId: Value(customerId),
      hvcId: Value(hvcId),
      relationshipType: Value(relationshipType),
      isActive: Value(isActive),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory CustomerHvcLink.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerHvcLink(
      id: serializer.fromJson<String>(json['id']),
      customerId: serializer.fromJson<String>(json['customerId']),
      hvcId: serializer.fromJson<String>(json['hvcId']),
      relationshipType: serializer.fromJson<String>(json['relationshipType']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'customerId': serializer.toJson<String>(customerId),
      'hvcId': serializer.toJson<String>(hvcId),
      'relationshipType': serializer.toJson<String>(relationshipType),
      'isActive': serializer.toJson<bool>(isActive),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  CustomerHvcLink copyWith({
    String? id,
    String? customerId,
    String? hvcId,
    String? relationshipType,
    bool? isActive,
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => CustomerHvcLink(
    id: id ?? this.id,
    customerId: customerId ?? this.customerId,
    hvcId: hvcId ?? this.hvcId,
    relationshipType: relationshipType ?? this.relationshipType,
    isActive: isActive ?? this.isActive,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  CustomerHvcLink copyWithCompanion(CustomerHvcLinksCompanion data) {
    return CustomerHvcLink(
      id: data.id.present ? data.id.value : this.id,
      customerId: data.customerId.present
          ? data.customerId.value
          : this.customerId,
      hvcId: data.hvcId.present ? data.hvcId.value : this.hvcId,
      relationshipType: data.relationshipType.present
          ? data.relationshipType.value
          : this.relationshipType,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CustomerHvcLink(')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('hvcId: $hvcId, ')
          ..write('relationshipType: $relationshipType, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    customerId,
    hvcId,
    relationshipType,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerHvcLink &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.hvcId == this.hvcId &&
          other.relationshipType == this.relationshipType &&
          other.isActive == this.isActive &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class CustomerHvcLinksCompanion extends UpdateCompanion<CustomerHvcLink> {
  final Value<String> id;
  final Value<String> customerId;
  final Value<String> hvcId;
  final Value<String> relationshipType;
  final Value<bool> isActive;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const CustomerHvcLinksCompanion({
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.hvcId = const Value.absent(),
    this.relationshipType = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CustomerHvcLinksCompanion.insert({
    required String id,
    required String customerId,
    required String hvcId,
    required String relationshipType,
    this.isActive = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       customerId = Value(customerId),
       hvcId = Value(hvcId),
       relationshipType = Value(relationshipType),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<CustomerHvcLink> custom({
    Expression<String>? id,
    Expression<String>? customerId,
    Expression<String>? hvcId,
    Expression<String>? relationshipType,
    Expression<bool>? isActive,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (hvcId != null) 'hvc_id': hvcId,
      if (relationshipType != null) 'relationship_type': relationshipType,
      if (isActive != null) 'is_active': isActive,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CustomerHvcLinksCompanion copyWith({
    Value<String>? id,
    Value<String>? customerId,
    Value<String>? hvcId,
    Value<String>? relationshipType,
    Value<bool>? isActive,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return CustomerHvcLinksCompanion(
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      hvcId: hvcId ?? this.hvcId,
      relationshipType: relationshipType ?? this.relationshipType,
      isActive: isActive ?? this.isActive,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (hvcId.present) {
      map['hvc_id'] = Variable<String>(hvcId.value);
    }
    if (relationshipType.present) {
      map['relationship_type'] = Variable<String>(relationshipType.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerHvcLinksCompanion(')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('hvcId: $hvcId, ')
          ..write('relationshipType: $relationshipType, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BrokersTable extends Brokers with TableInfo<$BrokersTable, Broker> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BrokersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _licenseNumberMeta = const VerificationMeta(
    'licenseNumber',
  );
  @override
  late final GeneratedColumn<String> licenseNumber = GeneratedColumn<String>(
    'license_number',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _provinceIdMeta = const VerificationMeta(
    'provinceId',
  );
  @override
  late final GeneratedColumn<String> provinceId = GeneratedColumn<String>(
    'province_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES provinces (id)',
    ),
  );
  static const VerificationMeta _cityIdMeta = const VerificationMeta('cityId');
  @override
  late final GeneratedColumn<String> cityId = GeneratedColumn<String>(
    'city_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES cities (id)',
    ),
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _websiteMeta = const VerificationMeta(
    'website',
  );
  @override
  late final GeneratedColumn<String> website = GeneratedColumn<String>(
    'website',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _commissionRateMeta = const VerificationMeta(
    'commissionRate',
  );
  @override
  late final GeneratedColumn<double> commissionRate = GeneratedColumn<double>(
    'commission_rate',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    licenseNumber,
    address,
    provinceId,
    cityId,
    latitude,
    longitude,
    phone,
    email,
    website,
    commissionRate,
    imageUrl,
    notes,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'brokers';
  @override
  VerificationContext validateIntegrity(
    Insertable<Broker> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('license_number')) {
      context.handle(
        _licenseNumberMeta,
        licenseNumber.isAcceptableOrUnknown(
          data['license_number']!,
          _licenseNumberMeta,
        ),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('province_id')) {
      context.handle(
        _provinceIdMeta,
        provinceId.isAcceptableOrUnknown(data['province_id']!, _provinceIdMeta),
      );
    }
    if (data.containsKey('city_id')) {
      context.handle(
        _cityIdMeta,
        cityId.isAcceptableOrUnknown(data['city_id']!, _cityIdMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('website')) {
      context.handle(
        _websiteMeta,
        website.isAcceptableOrUnknown(data['website']!, _websiteMeta),
      );
    }
    if (data.containsKey('commission_rate')) {
      context.handle(
        _commissionRateMeta,
        commissionRate.isAcceptableOrUnknown(
          data['commission_rate']!,
          _commissionRateMeta,
        ),
      );
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Broker map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Broker(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      licenseNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}license_number'],
      ),
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      provinceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}province_id'],
      ),
      cityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}city_id'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      website: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}website'],
      ),
      commissionRate: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}commission_rate'],
      ),
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $BrokersTable createAlias(String alias) {
    return $BrokersTable(attachedDatabase, alias);
  }
}

class Broker extends DataClass implements Insertable<Broker> {
  final String id;
  final String code;
  final String name;
  final String? licenseNumber;
  final String? address;
  final String? provinceId;
  final String? cityId;
  final double? latitude;
  final double? longitude;
  final String? phone;
  final String? email;
  final String? website;
  final double? commissionRate;
  final String? imageUrl;
  final String? notes;
  final bool isActive;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final DateTime? lastSyncAt;
  const Broker({
    required this.id,
    required this.code,
    required this.name,
    this.licenseNumber,
    this.address,
    this.provinceId,
    this.cityId,
    this.latitude,
    this.longitude,
    this.phone,
    this.email,
    this.website,
    this.commissionRate,
    this.imageUrl,
    this.notes,
    required this.isActive,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || licenseNumber != null) {
      map['license_number'] = Variable<String>(licenseNumber);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || provinceId != null) {
      map['province_id'] = Variable<String>(provinceId);
    }
    if (!nullToAbsent || cityId != null) {
      map['city_id'] = Variable<String>(cityId);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || website != null) {
      map['website'] = Variable<String>(website);
    }
    if (!nullToAbsent || commissionRate != null) {
      map['commission_rate'] = Variable<double>(commissionRate);
    }
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  BrokersCompanion toCompanion(bool nullToAbsent) {
    return BrokersCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      licenseNumber: licenseNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(licenseNumber),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      provinceId: provinceId == null && nullToAbsent
          ? const Value.absent()
          : Value(provinceId),
      cityId: cityId == null && nullToAbsent
          ? const Value.absent()
          : Value(cityId),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      website: website == null && nullToAbsent
          ? const Value.absent()
          : Value(website),
      commissionRate: commissionRate == null && nullToAbsent
          ? const Value.absent()
          : Value(commissionRate),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isActive: Value(isActive),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory Broker.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Broker(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      licenseNumber: serializer.fromJson<String?>(json['licenseNumber']),
      address: serializer.fromJson<String?>(json['address']),
      provinceId: serializer.fromJson<String?>(json['provinceId']),
      cityId: serializer.fromJson<String?>(json['cityId']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      website: serializer.fromJson<String?>(json['website']),
      commissionRate: serializer.fromJson<double?>(json['commissionRate']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      notes: serializer.fromJson<String?>(json['notes']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'licenseNumber': serializer.toJson<String?>(licenseNumber),
      'address': serializer.toJson<String?>(address),
      'provinceId': serializer.toJson<String?>(provinceId),
      'cityId': serializer.toJson<String?>(cityId),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'website': serializer.toJson<String?>(website),
      'commissionRate': serializer.toJson<double?>(commissionRate),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'notes': serializer.toJson<String?>(notes),
      'isActive': serializer.toJson<bool>(isActive),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  Broker copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> licenseNumber = const Value.absent(),
    Value<String?> address = const Value.absent(),
    Value<String?> provinceId = const Value.absent(),
    Value<String?> cityId = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> email = const Value.absent(),
    Value<String?> website = const Value.absent(),
    Value<double?> commissionRate = const Value.absent(),
    Value<String?> imageUrl = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    bool? isActive,
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => Broker(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    licenseNumber: licenseNumber.present
        ? licenseNumber.value
        : this.licenseNumber,
    address: address.present ? address.value : this.address,
    provinceId: provinceId.present ? provinceId.value : this.provinceId,
    cityId: cityId.present ? cityId.value : this.cityId,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    phone: phone.present ? phone.value : this.phone,
    email: email.present ? email.value : this.email,
    website: website.present ? website.value : this.website,
    commissionRate: commissionRate.present
        ? commissionRate.value
        : this.commissionRate,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    notes: notes.present ? notes.value : this.notes,
    isActive: isActive ?? this.isActive,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  Broker copyWithCompanion(BrokersCompanion data) {
    return Broker(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      licenseNumber: data.licenseNumber.present
          ? data.licenseNumber.value
          : this.licenseNumber,
      address: data.address.present ? data.address.value : this.address,
      provinceId: data.provinceId.present
          ? data.provinceId.value
          : this.provinceId,
      cityId: data.cityId.present ? data.cityId.value : this.cityId,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      website: data.website.present ? data.website.value : this.website,
      commissionRate: data.commissionRate.present
          ? data.commissionRate.value
          : this.commissionRate,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      notes: data.notes.present ? data.notes.value : this.notes,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Broker(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('licenseNumber: $licenseNumber, ')
          ..write('address: $address, ')
          ..write('provinceId: $provinceId, ')
          ..write('cityId: $cityId, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('website: $website, ')
          ..write('commissionRate: $commissionRate, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('notes: $notes, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    code,
    name,
    licenseNumber,
    address,
    provinceId,
    cityId,
    latitude,
    longitude,
    phone,
    email,
    website,
    commissionRate,
    imageUrl,
    notes,
    isActive,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    deletedAt,
    lastSyncAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Broker &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.licenseNumber == this.licenseNumber &&
          other.address == this.address &&
          other.provinceId == this.provinceId &&
          other.cityId == this.cityId &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.website == this.website &&
          other.commissionRate == this.commissionRate &&
          other.imageUrl == this.imageUrl &&
          other.notes == this.notes &&
          other.isActive == this.isActive &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class BrokersCompanion extends UpdateCompanion<Broker> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> licenseNumber;
  final Value<String?> address;
  final Value<String?> provinceId;
  final Value<String?> cityId;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<String?> website;
  final Value<double?> commissionRate;
  final Value<String?> imageUrl;
  final Value<String?> notes;
  final Value<bool> isActive;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const BrokersCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.licenseNumber = const Value.absent(),
    this.address = const Value.absent(),
    this.provinceId = const Value.absent(),
    this.cityId = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.website = const Value.absent(),
    this.commissionRate = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.notes = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BrokersCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.licenseNumber = const Value.absent(),
    this.address = const Value.absent(),
    this.provinceId = const Value.absent(),
    this.cityId = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.website = const Value.absent(),
    this.commissionRate = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.notes = const Value.absent(),
    this.isActive = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Broker> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? licenseNumber,
    Expression<String>? address,
    Expression<String>? provinceId,
    Expression<String>? cityId,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<String>? website,
    Expression<double>? commissionRate,
    Expression<String>? imageUrl,
    Expression<String>? notes,
    Expression<bool>? isActive,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (licenseNumber != null) 'license_number': licenseNumber,
      if (address != null) 'address': address,
      if (provinceId != null) 'province_id': provinceId,
      if (cityId != null) 'city_id': cityId,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (website != null) 'website': website,
      if (commissionRate != null) 'commission_rate': commissionRate,
      if (imageUrl != null) 'image_url': imageUrl,
      if (notes != null) 'notes': notes,
      if (isActive != null) 'is_active': isActive,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BrokersCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? licenseNumber,
    Value<String?>? address,
    Value<String?>? provinceId,
    Value<String?>? cityId,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<String?>? phone,
    Value<String?>? email,
    Value<String?>? website,
    Value<double?>? commissionRate,
    Value<String?>? imageUrl,
    Value<String?>? notes,
    Value<bool>? isActive,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return BrokersCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      licenseNumber: licenseNumber ?? this.licenseNumber,
      address: address ?? this.address,
      provinceId: provinceId ?? this.provinceId,
      cityId: cityId ?? this.cityId,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      website: website ?? this.website,
      commissionRate: commissionRate ?? this.commissionRate,
      imageUrl: imageUrl ?? this.imageUrl,
      notes: notes ?? this.notes,
      isActive: isActive ?? this.isActive,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (licenseNumber.present) {
      map['license_number'] = Variable<String>(licenseNumber.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (provinceId.present) {
      map['province_id'] = Variable<String>(provinceId.value);
    }
    if (cityId.present) {
      map['city_id'] = Variable<String>(cityId.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (website.present) {
      map['website'] = Variable<String>(website.value);
    }
    if (commissionRate.present) {
      map['commission_rate'] = Variable<double>(commissionRate.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BrokersCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('licenseNumber: $licenseNumber, ')
          ..write('address: $address, ')
          ..write('provinceId: $provinceId, ')
          ..write('cityId: $cityId, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('website: $website, ')
          ..write('commissionRate: $commissionRate, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('notes: $notes, ')
          ..write('isActive: $isActive, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MeasureDefinitionsTable extends MeasureDefinitions
    with TableInfo<$MeasureDefinitionsTable, MeasureDefinition> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MeasureDefinitionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _measureTypeMeta = const VerificationMeta(
    'measureType',
  );
  @override
  late final GeneratedColumn<String> measureType = GeneratedColumn<String>(
    'measure_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dataTypeMeta = const VerificationMeta(
    'dataType',
  );
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
    'data_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('COUNT'),
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _calculationMethodMeta = const VerificationMeta(
    'calculationMethod',
  );
  @override
  late final GeneratedColumn<String> calculationMethod =
      GeneratedColumn<String>(
        'calculation_method',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _calculationFormulaMeta =
      const VerificationMeta('calculationFormula');
  @override
  late final GeneratedColumn<String> calculationFormula =
      GeneratedColumn<String>(
        'calculation_formula',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _sourceTableMeta = const VerificationMeta(
    'sourceTable',
  );
  @override
  late final GeneratedColumn<String> sourceTable = GeneratedColumn<String>(
    'source_table',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sourceConditionMeta = const VerificationMeta(
    'sourceCondition',
  );
  @override
  late final GeneratedColumn<String> sourceCondition = GeneratedColumn<String>(
    'source_condition',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _weightMeta = const VerificationMeta('weight');
  @override
  late final GeneratedColumn<double> weight = GeneratedColumn<double>(
    'weight',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _defaultTargetMeta = const VerificationMeta(
    'defaultTarget',
  );
  @override
  late final GeneratedColumn<double> defaultTarget = GeneratedColumn<double>(
    'default_target',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _periodTypeMeta = const VerificationMeta(
    'periodType',
  );
  @override
  late final GeneratedColumn<String> periodType = GeneratedColumn<String>(
    'period_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('WEEKLY'),
  );
  static const VerificationMeta _templateTypeMeta = const VerificationMeta(
    'templateType',
  );
  @override
  late final GeneratedColumn<String> templateType = GeneratedColumn<String>(
    'template_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _templateConfigMeta = const VerificationMeta(
    'templateConfig',
  );
  @override
  late final GeneratedColumn<String> templateConfig = GeneratedColumn<String>(
    'template_config',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    code,
    name,
    description,
    measureType,
    dataType,
    unit,
    calculationMethod,
    calculationFormula,
    sourceTable,
    sourceCondition,
    weight,
    defaultTarget,
    periodType,
    templateType,
    templateConfig,
    isActive,
    sortOrder,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'measure_definitions';
  @override
  VerificationContext validateIntegrity(
    Insertable<MeasureDefinition> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('measure_type')) {
      context.handle(
        _measureTypeMeta,
        measureType.isAcceptableOrUnknown(
          data['measure_type']!,
          _measureTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_measureTypeMeta);
    }
    if (data.containsKey('data_type')) {
      context.handle(
        _dataTypeMeta,
        dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta),
      );
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    } else if (isInserting) {
      context.missing(_unitMeta);
    }
    if (data.containsKey('calculation_method')) {
      context.handle(
        _calculationMethodMeta,
        calculationMethod.isAcceptableOrUnknown(
          data['calculation_method']!,
          _calculationMethodMeta,
        ),
      );
    }
    if (data.containsKey('calculation_formula')) {
      context.handle(
        _calculationFormulaMeta,
        calculationFormula.isAcceptableOrUnknown(
          data['calculation_formula']!,
          _calculationFormulaMeta,
        ),
      );
    }
    if (data.containsKey('source_table')) {
      context.handle(
        _sourceTableMeta,
        sourceTable.isAcceptableOrUnknown(
          data['source_table']!,
          _sourceTableMeta,
        ),
      );
    }
    if (data.containsKey('source_condition')) {
      context.handle(
        _sourceConditionMeta,
        sourceCondition.isAcceptableOrUnknown(
          data['source_condition']!,
          _sourceConditionMeta,
        ),
      );
    }
    if (data.containsKey('weight')) {
      context.handle(
        _weightMeta,
        weight.isAcceptableOrUnknown(data['weight']!, _weightMeta),
      );
    }
    if (data.containsKey('default_target')) {
      context.handle(
        _defaultTargetMeta,
        defaultTarget.isAcceptableOrUnknown(
          data['default_target']!,
          _defaultTargetMeta,
        ),
      );
    }
    if (data.containsKey('period_type')) {
      context.handle(
        _periodTypeMeta,
        periodType.isAcceptableOrUnknown(data['period_type']!, _periodTypeMeta),
      );
    }
    if (data.containsKey('template_type')) {
      context.handle(
        _templateTypeMeta,
        templateType.isAcceptableOrUnknown(
          data['template_type']!,
          _templateTypeMeta,
        ),
      );
    }
    if (data.containsKey('template_config')) {
      context.handle(
        _templateConfigMeta,
        templateConfig.isAcceptableOrUnknown(
          data['template_config']!,
          _templateConfigMeta,
        ),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MeasureDefinition map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MeasureDefinition(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      measureType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}measure_type'],
      )!,
      dataType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}data_type'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      )!,
      calculationMethod: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}calculation_method'],
      ),
      calculationFormula: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}calculation_formula'],
      ),
      sourceTable: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source_table'],
      ),
      sourceCondition: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source_condition'],
      ),
      weight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}weight'],
      )!,
      defaultTarget: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}default_target'],
      ),
      periodType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}period_type'],
      )!,
      templateType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}template_type'],
      ),
      templateConfig: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}template_config'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $MeasureDefinitionsTable createAlias(String alias) {
    return $MeasureDefinitionsTable(attachedDatabase, alias);
  }
}

class MeasureDefinition extends DataClass
    implements Insertable<MeasureDefinition> {
  final String id;
  final String code;
  final String name;
  final String? description;
  final String measureType;
  final String dataType;
  final String unit;
  final String? calculationMethod;
  final String? calculationFormula;
  final String? sourceTable;
  final String? sourceCondition;
  final double weight;
  final double? defaultTarget;
  final String periodType;
  final String? templateType;
  final String? templateConfig;
  final bool isActive;
  final int sortOrder;
  final DateTime createdAt;
  final DateTime updatedAt;
  const MeasureDefinition({
    required this.id,
    required this.code,
    required this.name,
    this.description,
    required this.measureType,
    required this.dataType,
    required this.unit,
    this.calculationMethod,
    this.calculationFormula,
    this.sourceTable,
    this.sourceCondition,
    required this.weight,
    this.defaultTarget,
    required this.periodType,
    this.templateType,
    this.templateConfig,
    required this.isActive,
    required this.sortOrder,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['measure_type'] = Variable<String>(measureType);
    map['data_type'] = Variable<String>(dataType);
    map['unit'] = Variable<String>(unit);
    if (!nullToAbsent || calculationMethod != null) {
      map['calculation_method'] = Variable<String>(calculationMethod);
    }
    if (!nullToAbsent || calculationFormula != null) {
      map['calculation_formula'] = Variable<String>(calculationFormula);
    }
    if (!nullToAbsent || sourceTable != null) {
      map['source_table'] = Variable<String>(sourceTable);
    }
    if (!nullToAbsent || sourceCondition != null) {
      map['source_condition'] = Variable<String>(sourceCondition);
    }
    map['weight'] = Variable<double>(weight);
    if (!nullToAbsent || defaultTarget != null) {
      map['default_target'] = Variable<double>(defaultTarget);
    }
    map['period_type'] = Variable<String>(periodType);
    if (!nullToAbsent || templateType != null) {
      map['template_type'] = Variable<String>(templateType);
    }
    if (!nullToAbsent || templateConfig != null) {
      map['template_config'] = Variable<String>(templateConfig);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['sort_order'] = Variable<int>(sortOrder);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  MeasureDefinitionsCompanion toCompanion(bool nullToAbsent) {
    return MeasureDefinitionsCompanion(
      id: Value(id),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      measureType: Value(measureType),
      dataType: Value(dataType),
      unit: Value(unit),
      calculationMethod: calculationMethod == null && nullToAbsent
          ? const Value.absent()
          : Value(calculationMethod),
      calculationFormula: calculationFormula == null && nullToAbsent
          ? const Value.absent()
          : Value(calculationFormula),
      sourceTable: sourceTable == null && nullToAbsent
          ? const Value.absent()
          : Value(sourceTable),
      sourceCondition: sourceCondition == null && nullToAbsent
          ? const Value.absent()
          : Value(sourceCondition),
      weight: Value(weight),
      defaultTarget: defaultTarget == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultTarget),
      periodType: Value(periodType),
      templateType: templateType == null && nullToAbsent
          ? const Value.absent()
          : Value(templateType),
      templateConfig: templateConfig == null && nullToAbsent
          ? const Value.absent()
          : Value(templateConfig),
      isActive: Value(isActive),
      sortOrder: Value(sortOrder),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory MeasureDefinition.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MeasureDefinition(
      id: serializer.fromJson<String>(json['id']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      measureType: serializer.fromJson<String>(json['measureType']),
      dataType: serializer.fromJson<String>(json['dataType']),
      unit: serializer.fromJson<String>(json['unit']),
      calculationMethod: serializer.fromJson<String?>(
        json['calculationMethod'],
      ),
      calculationFormula: serializer.fromJson<String?>(
        json['calculationFormula'],
      ),
      sourceTable: serializer.fromJson<String?>(json['sourceTable']),
      sourceCondition: serializer.fromJson<String?>(json['sourceCondition']),
      weight: serializer.fromJson<double>(json['weight']),
      defaultTarget: serializer.fromJson<double?>(json['defaultTarget']),
      periodType: serializer.fromJson<String>(json['periodType']),
      templateType: serializer.fromJson<String?>(json['templateType']),
      templateConfig: serializer.fromJson<String?>(json['templateConfig']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'measureType': serializer.toJson<String>(measureType),
      'dataType': serializer.toJson<String>(dataType),
      'unit': serializer.toJson<String>(unit),
      'calculationMethod': serializer.toJson<String?>(calculationMethod),
      'calculationFormula': serializer.toJson<String?>(calculationFormula),
      'sourceTable': serializer.toJson<String?>(sourceTable),
      'sourceCondition': serializer.toJson<String?>(sourceCondition),
      'weight': serializer.toJson<double>(weight),
      'defaultTarget': serializer.toJson<double?>(defaultTarget),
      'periodType': serializer.toJson<String>(periodType),
      'templateType': serializer.toJson<String?>(templateType),
      'templateConfig': serializer.toJson<String?>(templateConfig),
      'isActive': serializer.toJson<bool>(isActive),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  MeasureDefinition copyWith({
    String? id,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    String? measureType,
    String? dataType,
    String? unit,
    Value<String?> calculationMethod = const Value.absent(),
    Value<String?> calculationFormula = const Value.absent(),
    Value<String?> sourceTable = const Value.absent(),
    Value<String?> sourceCondition = const Value.absent(),
    double? weight,
    Value<double?> defaultTarget = const Value.absent(),
    String? periodType,
    Value<String?> templateType = const Value.absent(),
    Value<String?> templateConfig = const Value.absent(),
    bool? isActive,
    int? sortOrder,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => MeasureDefinition(
    id: id ?? this.id,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    measureType: measureType ?? this.measureType,
    dataType: dataType ?? this.dataType,
    unit: unit ?? this.unit,
    calculationMethod: calculationMethod.present
        ? calculationMethod.value
        : this.calculationMethod,
    calculationFormula: calculationFormula.present
        ? calculationFormula.value
        : this.calculationFormula,
    sourceTable: sourceTable.present ? sourceTable.value : this.sourceTable,
    sourceCondition: sourceCondition.present
        ? sourceCondition.value
        : this.sourceCondition,
    weight: weight ?? this.weight,
    defaultTarget: defaultTarget.present
        ? defaultTarget.value
        : this.defaultTarget,
    periodType: periodType ?? this.periodType,
    templateType: templateType.present ? templateType.value : this.templateType,
    templateConfig: templateConfig.present
        ? templateConfig.value
        : this.templateConfig,
    isActive: isActive ?? this.isActive,
    sortOrder: sortOrder ?? this.sortOrder,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  MeasureDefinition copyWithCompanion(MeasureDefinitionsCompanion data) {
    return MeasureDefinition(
      id: data.id.present ? data.id.value : this.id,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      measureType: data.measureType.present
          ? data.measureType.value
          : this.measureType,
      dataType: data.dataType.present ? data.dataType.value : this.dataType,
      unit: data.unit.present ? data.unit.value : this.unit,
      calculationMethod: data.calculationMethod.present
          ? data.calculationMethod.value
          : this.calculationMethod,
      calculationFormula: data.calculationFormula.present
          ? data.calculationFormula.value
          : this.calculationFormula,
      sourceTable: data.sourceTable.present
          ? data.sourceTable.value
          : this.sourceTable,
      sourceCondition: data.sourceCondition.present
          ? data.sourceCondition.value
          : this.sourceCondition,
      weight: data.weight.present ? data.weight.value : this.weight,
      defaultTarget: data.defaultTarget.present
          ? data.defaultTarget.value
          : this.defaultTarget,
      periodType: data.periodType.present
          ? data.periodType.value
          : this.periodType,
      templateType: data.templateType.present
          ? data.templateType.value
          : this.templateType,
      templateConfig: data.templateConfig.present
          ? data.templateConfig.value
          : this.templateConfig,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MeasureDefinition(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('measureType: $measureType, ')
          ..write('dataType: $dataType, ')
          ..write('unit: $unit, ')
          ..write('calculationMethod: $calculationMethod, ')
          ..write('calculationFormula: $calculationFormula, ')
          ..write('sourceTable: $sourceTable, ')
          ..write('sourceCondition: $sourceCondition, ')
          ..write('weight: $weight, ')
          ..write('defaultTarget: $defaultTarget, ')
          ..write('periodType: $periodType, ')
          ..write('templateType: $templateType, ')
          ..write('templateConfig: $templateConfig, ')
          ..write('isActive: $isActive, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    code,
    name,
    description,
    measureType,
    dataType,
    unit,
    calculationMethod,
    calculationFormula,
    sourceTable,
    sourceCondition,
    weight,
    defaultTarget,
    periodType,
    templateType,
    templateConfig,
    isActive,
    sortOrder,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MeasureDefinition &&
          other.id == this.id &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.measureType == this.measureType &&
          other.dataType == this.dataType &&
          other.unit == this.unit &&
          other.calculationMethod == this.calculationMethod &&
          other.calculationFormula == this.calculationFormula &&
          other.sourceTable == this.sourceTable &&
          other.sourceCondition == this.sourceCondition &&
          other.weight == this.weight &&
          other.defaultTarget == this.defaultTarget &&
          other.periodType == this.periodType &&
          other.templateType == this.templateType &&
          other.templateConfig == this.templateConfig &&
          other.isActive == this.isActive &&
          other.sortOrder == this.sortOrder &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class MeasureDefinitionsCompanion extends UpdateCompanion<MeasureDefinition> {
  final Value<String> id;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<String> measureType;
  final Value<String> dataType;
  final Value<String> unit;
  final Value<String?> calculationMethod;
  final Value<String?> calculationFormula;
  final Value<String?> sourceTable;
  final Value<String?> sourceCondition;
  final Value<double> weight;
  final Value<double?> defaultTarget;
  final Value<String> periodType;
  final Value<String?> templateType;
  final Value<String?> templateConfig;
  final Value<bool> isActive;
  final Value<int> sortOrder;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const MeasureDefinitionsCompanion({
    this.id = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.measureType = const Value.absent(),
    this.dataType = const Value.absent(),
    this.unit = const Value.absent(),
    this.calculationMethod = const Value.absent(),
    this.calculationFormula = const Value.absent(),
    this.sourceTable = const Value.absent(),
    this.sourceCondition = const Value.absent(),
    this.weight = const Value.absent(),
    this.defaultTarget = const Value.absent(),
    this.periodType = const Value.absent(),
    this.templateType = const Value.absent(),
    this.templateConfig = const Value.absent(),
    this.isActive = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MeasureDefinitionsCompanion.insert({
    required String id,
    required String code,
    required String name,
    this.description = const Value.absent(),
    required String measureType,
    this.dataType = const Value.absent(),
    required String unit,
    this.calculationMethod = const Value.absent(),
    this.calculationFormula = const Value.absent(),
    this.sourceTable = const Value.absent(),
    this.sourceCondition = const Value.absent(),
    this.weight = const Value.absent(),
    this.defaultTarget = const Value.absent(),
    this.periodType = const Value.absent(),
    this.templateType = const Value.absent(),
    this.templateConfig = const Value.absent(),
    this.isActive = const Value.absent(),
    this.sortOrder = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       code = Value(code),
       name = Value(name),
       measureType = Value(measureType),
       unit = Value(unit),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<MeasureDefinition> custom({
    Expression<String>? id,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? measureType,
    Expression<String>? dataType,
    Expression<String>? unit,
    Expression<String>? calculationMethod,
    Expression<String>? calculationFormula,
    Expression<String>? sourceTable,
    Expression<String>? sourceCondition,
    Expression<double>? weight,
    Expression<double>? defaultTarget,
    Expression<String>? periodType,
    Expression<String>? templateType,
    Expression<String>? templateConfig,
    Expression<bool>? isActive,
    Expression<int>? sortOrder,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (measureType != null) 'measure_type': measureType,
      if (dataType != null) 'data_type': dataType,
      if (unit != null) 'unit': unit,
      if (calculationMethod != null) 'calculation_method': calculationMethod,
      if (calculationFormula != null) 'calculation_formula': calculationFormula,
      if (sourceTable != null) 'source_table': sourceTable,
      if (sourceCondition != null) 'source_condition': sourceCondition,
      if (weight != null) 'weight': weight,
      if (defaultTarget != null) 'default_target': defaultTarget,
      if (periodType != null) 'period_type': periodType,
      if (templateType != null) 'template_type': templateType,
      if (templateConfig != null) 'template_config': templateConfig,
      if (isActive != null) 'is_active': isActive,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MeasureDefinitionsCompanion copyWith({
    Value<String>? id,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<String>? measureType,
    Value<String>? dataType,
    Value<String>? unit,
    Value<String?>? calculationMethod,
    Value<String?>? calculationFormula,
    Value<String?>? sourceTable,
    Value<String?>? sourceCondition,
    Value<double>? weight,
    Value<double?>? defaultTarget,
    Value<String>? periodType,
    Value<String?>? templateType,
    Value<String?>? templateConfig,
    Value<bool>? isActive,
    Value<int>? sortOrder,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return MeasureDefinitionsCompanion(
      id: id ?? this.id,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      measureType: measureType ?? this.measureType,
      dataType: dataType ?? this.dataType,
      unit: unit ?? this.unit,
      calculationMethod: calculationMethod ?? this.calculationMethod,
      calculationFormula: calculationFormula ?? this.calculationFormula,
      sourceTable: sourceTable ?? this.sourceTable,
      sourceCondition: sourceCondition ?? this.sourceCondition,
      weight: weight ?? this.weight,
      defaultTarget: defaultTarget ?? this.defaultTarget,
      periodType: periodType ?? this.periodType,
      templateType: templateType ?? this.templateType,
      templateConfig: templateConfig ?? this.templateConfig,
      isActive: isActive ?? this.isActive,
      sortOrder: sortOrder ?? this.sortOrder,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (measureType.present) {
      map['measure_type'] = Variable<String>(measureType.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (calculationMethod.present) {
      map['calculation_method'] = Variable<String>(calculationMethod.value);
    }
    if (calculationFormula.present) {
      map['calculation_formula'] = Variable<String>(calculationFormula.value);
    }
    if (sourceTable.present) {
      map['source_table'] = Variable<String>(sourceTable.value);
    }
    if (sourceCondition.present) {
      map['source_condition'] = Variable<String>(sourceCondition.value);
    }
    if (weight.present) {
      map['weight'] = Variable<double>(weight.value);
    }
    if (defaultTarget.present) {
      map['default_target'] = Variable<double>(defaultTarget.value);
    }
    if (periodType.present) {
      map['period_type'] = Variable<String>(periodType.value);
    }
    if (templateType.present) {
      map['template_type'] = Variable<String>(templateType.value);
    }
    if (templateConfig.present) {
      map['template_config'] = Variable<String>(templateConfig.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MeasureDefinitionsCompanion(')
          ..write('id: $id, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('measureType: $measureType, ')
          ..write('dataType: $dataType, ')
          ..write('unit: $unit, ')
          ..write('calculationMethod: $calculationMethod, ')
          ..write('calculationFormula: $calculationFormula, ')
          ..write('sourceTable: $sourceTable, ')
          ..write('sourceCondition: $sourceCondition, ')
          ..write('weight: $weight, ')
          ..write('defaultTarget: $defaultTarget, ')
          ..write('periodType: $periodType, ')
          ..write('templateType: $templateType, ')
          ..write('templateConfig: $templateConfig, ')
          ..write('isActive: $isActive, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ScoringPeriodsTable extends ScoringPeriods
    with TableInfo<$ScoringPeriodsTable, ScoringPeriod> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ScoringPeriodsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _periodTypeMeta = const VerificationMeta(
    'periodType',
  );
  @override
  late final GeneratedColumn<String> periodType = GeneratedColumn<String>(
    'period_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startDateMeta = const VerificationMeta(
    'startDate',
  );
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
    'start_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endDateMeta = const VerificationMeta(
    'endDate',
  );
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
    'end_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _isCurrentMeta = const VerificationMeta(
    'isCurrent',
  );
  @override
  late final GeneratedColumn<bool> isCurrent = GeneratedColumn<bool>(
    'is_current',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_current" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isLockedMeta = const VerificationMeta(
    'isLocked',
  );
  @override
  late final GeneratedColumn<bool> isLocked = GeneratedColumn<bool>(
    'is_locked',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_locked" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    periodType,
    startDate,
    endDate,
    isActive,
    isCurrent,
    isLocked,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'scoring_periods';
  @override
  VerificationContext validateIntegrity(
    Insertable<ScoringPeriod> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('period_type')) {
      context.handle(
        _periodTypeMeta,
        periodType.isAcceptableOrUnknown(data['period_type']!, _periodTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_periodTypeMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(
        _startDateMeta,
        startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta),
      );
    } else if (isInserting) {
      context.missing(_startDateMeta);
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _endDateMeta,
        endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta),
      );
    } else if (isInserting) {
      context.missing(_endDateMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('is_current')) {
      context.handle(
        _isCurrentMeta,
        isCurrent.isAcceptableOrUnknown(data['is_current']!, _isCurrentMeta),
      );
    }
    if (data.containsKey('is_locked')) {
      context.handle(
        _isLockedMeta,
        isLocked.isAcceptableOrUnknown(data['is_locked']!, _isLockedMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ScoringPeriod map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ScoringPeriod(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      periodType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}period_type'],
      )!,
      startDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}start_date'],
      )!,
      endDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}end_date'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      isCurrent: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_current'],
      )!,
      isLocked: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_locked'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ScoringPeriodsTable createAlias(String alias) {
    return $ScoringPeriodsTable(attachedDatabase, alias);
  }
}

class ScoringPeriod extends DataClass implements Insertable<ScoringPeriod> {
  final String id;
  final String name;
  final String periodType;
  final DateTime startDate;
  final DateTime endDate;
  final bool isActive;
  final bool isCurrent;
  final bool isLocked;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ScoringPeriod({
    required this.id,
    required this.name,
    required this.periodType,
    required this.startDate,
    required this.endDate,
    required this.isActive,
    required this.isCurrent,
    required this.isLocked,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['period_type'] = Variable<String>(periodType);
    map['start_date'] = Variable<DateTime>(startDate);
    map['end_date'] = Variable<DateTime>(endDate);
    map['is_active'] = Variable<bool>(isActive);
    map['is_current'] = Variable<bool>(isCurrent);
    map['is_locked'] = Variable<bool>(isLocked);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ScoringPeriodsCompanion toCompanion(bool nullToAbsent) {
    return ScoringPeriodsCompanion(
      id: Value(id),
      name: Value(name),
      periodType: Value(periodType),
      startDate: Value(startDate),
      endDate: Value(endDate),
      isActive: Value(isActive),
      isCurrent: Value(isCurrent),
      isLocked: Value(isLocked),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ScoringPeriod.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ScoringPeriod(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      periodType: serializer.fromJson<String>(json['periodType']),
      startDate: serializer.fromJson<DateTime>(json['startDate']),
      endDate: serializer.fromJson<DateTime>(json['endDate']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isCurrent: serializer.fromJson<bool>(json['isCurrent']),
      isLocked: serializer.fromJson<bool>(json['isLocked']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'periodType': serializer.toJson<String>(periodType),
      'startDate': serializer.toJson<DateTime>(startDate),
      'endDate': serializer.toJson<DateTime>(endDate),
      'isActive': serializer.toJson<bool>(isActive),
      'isCurrent': serializer.toJson<bool>(isCurrent),
      'isLocked': serializer.toJson<bool>(isLocked),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ScoringPeriod copyWith({
    String? id,
    String? name,
    String? periodType,
    DateTime? startDate,
    DateTime? endDate,
    bool? isActive,
    bool? isCurrent,
    bool? isLocked,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ScoringPeriod(
    id: id ?? this.id,
    name: name ?? this.name,
    periodType: periodType ?? this.periodType,
    startDate: startDate ?? this.startDate,
    endDate: endDate ?? this.endDate,
    isActive: isActive ?? this.isActive,
    isCurrent: isCurrent ?? this.isCurrent,
    isLocked: isLocked ?? this.isLocked,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ScoringPeriod copyWithCompanion(ScoringPeriodsCompanion data) {
    return ScoringPeriod(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      periodType: data.periodType.present
          ? data.periodType.value
          : this.periodType,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      isCurrent: data.isCurrent.present ? data.isCurrent.value : this.isCurrent,
      isLocked: data.isLocked.present ? data.isLocked.value : this.isLocked,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ScoringPeriod(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('periodType: $periodType, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isActive: $isActive, ')
          ..write('isCurrent: $isCurrent, ')
          ..write('isLocked: $isLocked, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    periodType,
    startDate,
    endDate,
    isActive,
    isCurrent,
    isLocked,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ScoringPeriod &&
          other.id == this.id &&
          other.name == this.name &&
          other.periodType == this.periodType &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.isActive == this.isActive &&
          other.isCurrent == this.isCurrent &&
          other.isLocked == this.isLocked &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ScoringPeriodsCompanion extends UpdateCompanion<ScoringPeriod> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> periodType;
  final Value<DateTime> startDate;
  final Value<DateTime> endDate;
  final Value<bool> isActive;
  final Value<bool> isCurrent;
  final Value<bool> isLocked;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const ScoringPeriodsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.periodType = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isCurrent = const Value.absent(),
    this.isLocked = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ScoringPeriodsCompanion.insert({
    required String id,
    required String name,
    required String periodType,
    required DateTime startDate,
    required DateTime endDate,
    this.isActive = const Value.absent(),
    this.isCurrent = const Value.absent(),
    this.isLocked = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       periodType = Value(periodType),
       startDate = Value(startDate),
       endDate = Value(endDate),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ScoringPeriod> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? periodType,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<bool>? isActive,
    Expression<bool>? isCurrent,
    Expression<bool>? isLocked,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (periodType != null) 'period_type': periodType,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (isActive != null) 'is_active': isActive,
      if (isCurrent != null) 'is_current': isCurrent,
      if (isLocked != null) 'is_locked': isLocked,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ScoringPeriodsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? periodType,
    Value<DateTime>? startDate,
    Value<DateTime>? endDate,
    Value<bool>? isActive,
    Value<bool>? isCurrent,
    Value<bool>? isLocked,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return ScoringPeriodsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      periodType: periodType ?? this.periodType,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isActive: isActive ?? this.isActive,
      isCurrent: isCurrent ?? this.isCurrent,
      isLocked: isLocked ?? this.isLocked,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (periodType.present) {
      map['period_type'] = Variable<String>(periodType.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isCurrent.present) {
      map['is_current'] = Variable<bool>(isCurrent.value);
    }
    if (isLocked.present) {
      map['is_locked'] = Variable<bool>(isLocked.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ScoringPeriodsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('periodType: $periodType, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isActive: $isActive, ')
          ..write('isCurrent: $isCurrent, ')
          ..write('isLocked: $isLocked, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserTargetsTable extends UserTargets
    with TableInfo<$UserTargetsTable, UserTarget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserTargetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _measureIdMeta = const VerificationMeta(
    'measureId',
  );
  @override
  late final GeneratedColumn<String> measureId = GeneratedColumn<String>(
    'measure_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES measure_definitions (id)',
    ),
  );
  static const VerificationMeta _periodIdMeta = const VerificationMeta(
    'periodId',
  );
  @override
  late final GeneratedColumn<String> periodId = GeneratedColumn<String>(
    'period_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES scoring_periods (id)',
    ),
  );
  static const VerificationMeta _targetValueMeta = const VerificationMeta(
    'targetValue',
  );
  @override
  late final GeneratedColumn<double> targetValue = GeneratedColumn<double>(
    'target_value',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _assignedByMeta = const VerificationMeta(
    'assignedBy',
  );
  @override
  late final GeneratedColumn<String> assignedBy = GeneratedColumn<String>(
    'assigned_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _assignedAtMeta = const VerificationMeta(
    'assignedAt',
  );
  @override
  late final GeneratedColumn<DateTime> assignedAt = GeneratedColumn<DateTime>(
    'assigned_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    measureId,
    periodId,
    targetValue,
    assignedBy,
    assignedAt,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_targets';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserTarget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('measure_id')) {
      context.handle(
        _measureIdMeta,
        measureId.isAcceptableOrUnknown(data['measure_id']!, _measureIdMeta),
      );
    } else if (isInserting) {
      context.missing(_measureIdMeta);
    }
    if (data.containsKey('period_id')) {
      context.handle(
        _periodIdMeta,
        periodId.isAcceptableOrUnknown(data['period_id']!, _periodIdMeta),
      );
    } else if (isInserting) {
      context.missing(_periodIdMeta);
    }
    if (data.containsKey('target_value')) {
      context.handle(
        _targetValueMeta,
        targetValue.isAcceptableOrUnknown(
          data['target_value']!,
          _targetValueMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetValueMeta);
    }
    if (data.containsKey('assigned_by')) {
      context.handle(
        _assignedByMeta,
        assignedBy.isAcceptableOrUnknown(data['assigned_by']!, _assignedByMeta),
      );
    } else if (isInserting) {
      context.missing(_assignedByMeta);
    }
    if (data.containsKey('assigned_at')) {
      context.handle(
        _assignedAtMeta,
        assignedAt.isAcceptableOrUnknown(data['assigned_at']!, _assignedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_assignedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserTarget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserTarget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      measureId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}measure_id'],
      )!,
      periodId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}period_id'],
      )!,
      targetValue: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}target_value'],
      )!,
      assignedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}assigned_by'],
      )!,
      assignedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}assigned_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UserTargetsTable createAlias(String alias) {
    return $UserTargetsTable(attachedDatabase, alias);
  }
}

class UserTarget extends DataClass implements Insertable<UserTarget> {
  final String id;
  final String userId;
  final String measureId;
  final String periodId;
  final double targetValue;
  final String assignedBy;
  final DateTime assignedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const UserTarget({
    required this.id,
    required this.userId,
    required this.measureId,
    required this.periodId,
    required this.targetValue,
    required this.assignedBy,
    required this.assignedAt,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['measure_id'] = Variable<String>(measureId);
    map['period_id'] = Variable<String>(periodId);
    map['target_value'] = Variable<double>(targetValue);
    map['assigned_by'] = Variable<String>(assignedBy);
    map['assigned_at'] = Variable<DateTime>(assignedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UserTargetsCompanion toCompanion(bool nullToAbsent) {
    return UserTargetsCompanion(
      id: Value(id),
      userId: Value(userId),
      measureId: Value(measureId),
      periodId: Value(periodId),
      targetValue: Value(targetValue),
      assignedBy: Value(assignedBy),
      assignedAt: Value(assignedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory UserTarget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserTarget(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      measureId: serializer.fromJson<String>(json['measureId']),
      periodId: serializer.fromJson<String>(json['periodId']),
      targetValue: serializer.fromJson<double>(json['targetValue']),
      assignedBy: serializer.fromJson<String>(json['assignedBy']),
      assignedAt: serializer.fromJson<DateTime>(json['assignedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'measureId': serializer.toJson<String>(measureId),
      'periodId': serializer.toJson<String>(periodId),
      'targetValue': serializer.toJson<double>(targetValue),
      'assignedBy': serializer.toJson<String>(assignedBy),
      'assignedAt': serializer.toJson<DateTime>(assignedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  UserTarget copyWith({
    String? id,
    String? userId,
    String? measureId,
    String? periodId,
    double? targetValue,
    String? assignedBy,
    DateTime? assignedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => UserTarget(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    measureId: measureId ?? this.measureId,
    periodId: periodId ?? this.periodId,
    targetValue: targetValue ?? this.targetValue,
    assignedBy: assignedBy ?? this.assignedBy,
    assignedAt: assignedAt ?? this.assignedAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  UserTarget copyWithCompanion(UserTargetsCompanion data) {
    return UserTarget(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      measureId: data.measureId.present ? data.measureId.value : this.measureId,
      periodId: data.periodId.present ? data.periodId.value : this.periodId,
      targetValue: data.targetValue.present
          ? data.targetValue.value
          : this.targetValue,
      assignedBy: data.assignedBy.present
          ? data.assignedBy.value
          : this.assignedBy,
      assignedAt: data.assignedAt.present
          ? data.assignedAt.value
          : this.assignedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserTarget(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('measureId: $measureId, ')
          ..write('periodId: $periodId, ')
          ..write('targetValue: $targetValue, ')
          ..write('assignedBy: $assignedBy, ')
          ..write('assignedAt: $assignedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    measureId,
    periodId,
    targetValue,
    assignedBy,
    assignedAt,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserTarget &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.measureId == this.measureId &&
          other.periodId == this.periodId &&
          other.targetValue == this.targetValue &&
          other.assignedBy == this.assignedBy &&
          other.assignedAt == this.assignedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UserTargetsCompanion extends UpdateCompanion<UserTarget> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> measureId;
  final Value<String> periodId;
  final Value<double> targetValue;
  final Value<String> assignedBy;
  final Value<DateTime> assignedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UserTargetsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.measureId = const Value.absent(),
    this.periodId = const Value.absent(),
    this.targetValue = const Value.absent(),
    this.assignedBy = const Value.absent(),
    this.assignedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserTargetsCompanion.insert({
    required String id,
    required String userId,
    required String measureId,
    required String periodId,
    required double targetValue,
    required String assignedBy,
    required DateTime assignedAt,
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       measureId = Value(measureId),
       periodId = Value(periodId),
       targetValue = Value(targetValue),
       assignedBy = Value(assignedBy),
       assignedAt = Value(assignedAt),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<UserTarget> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? measureId,
    Expression<String>? periodId,
    Expression<double>? targetValue,
    Expression<String>? assignedBy,
    Expression<DateTime>? assignedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (measureId != null) 'measure_id': measureId,
      if (periodId != null) 'period_id': periodId,
      if (targetValue != null) 'target_value': targetValue,
      if (assignedBy != null) 'assigned_by': assignedBy,
      if (assignedAt != null) 'assigned_at': assignedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserTargetsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? measureId,
    Value<String>? periodId,
    Value<double>? targetValue,
    Value<String>? assignedBy,
    Value<DateTime>? assignedAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UserTargetsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      measureId: measureId ?? this.measureId,
      periodId: periodId ?? this.periodId,
      targetValue: targetValue ?? this.targetValue,
      assignedBy: assignedBy ?? this.assignedBy,
      assignedAt: assignedAt ?? this.assignedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (measureId.present) {
      map['measure_id'] = Variable<String>(measureId.value);
    }
    if (periodId.present) {
      map['period_id'] = Variable<String>(periodId.value);
    }
    if (targetValue.present) {
      map['target_value'] = Variable<double>(targetValue.value);
    }
    if (assignedBy.present) {
      map['assigned_by'] = Variable<String>(assignedBy.value);
    }
    if (assignedAt.present) {
      map['assigned_at'] = Variable<DateTime>(assignedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserTargetsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('measureId: $measureId, ')
          ..write('periodId: $periodId, ')
          ..write('targetValue: $targetValue, ')
          ..write('assignedBy: $assignedBy, ')
          ..write('assignedAt: $assignedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserScoresTable extends UserScores
    with TableInfo<$UserScoresTable, UserScore> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserScoresTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _measureIdMeta = const VerificationMeta(
    'measureId',
  );
  @override
  late final GeneratedColumn<String> measureId = GeneratedColumn<String>(
    'measure_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES measure_definitions (id)',
    ),
  );
  static const VerificationMeta _periodIdMeta = const VerificationMeta(
    'periodId',
  );
  @override
  late final GeneratedColumn<String> periodId = GeneratedColumn<String>(
    'period_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES scoring_periods (id)',
    ),
  );
  static const VerificationMeta _targetValueMeta = const VerificationMeta(
    'targetValue',
  );
  @override
  late final GeneratedColumn<double> targetValue = GeneratedColumn<double>(
    'target_value',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actualValueMeta = const VerificationMeta(
    'actualValue',
  );
  @override
  late final GeneratedColumn<double> actualValue = GeneratedColumn<double>(
    'actual_value',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _percentageMeta = const VerificationMeta(
    'percentage',
  );
  @override
  late final GeneratedColumn<double> percentage = GeneratedColumn<double>(
    'percentage',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _scoreMeta = const VerificationMeta('score');
  @override
  late final GeneratedColumn<double> score = GeneratedColumn<double>(
    'score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _rankMeta = const VerificationMeta('rank');
  @override
  late final GeneratedColumn<int> rank = GeneratedColumn<int>(
    'rank',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _calculatedAtMeta = const VerificationMeta(
    'calculatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> calculatedAt = GeneratedColumn<DateTime>(
    'calculated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    measureId,
    periodId,
    targetValue,
    actualValue,
    percentage,
    score,
    rank,
    calculatedAt,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_scores';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserScore> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('measure_id')) {
      context.handle(
        _measureIdMeta,
        measureId.isAcceptableOrUnknown(data['measure_id']!, _measureIdMeta),
      );
    } else if (isInserting) {
      context.missing(_measureIdMeta);
    }
    if (data.containsKey('period_id')) {
      context.handle(
        _periodIdMeta,
        periodId.isAcceptableOrUnknown(data['period_id']!, _periodIdMeta),
      );
    } else if (isInserting) {
      context.missing(_periodIdMeta);
    }
    if (data.containsKey('target_value')) {
      context.handle(
        _targetValueMeta,
        targetValue.isAcceptableOrUnknown(
          data['target_value']!,
          _targetValueMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetValueMeta);
    }
    if (data.containsKey('actual_value')) {
      context.handle(
        _actualValueMeta,
        actualValue.isAcceptableOrUnknown(
          data['actual_value']!,
          _actualValueMeta,
        ),
      );
    }
    if (data.containsKey('percentage')) {
      context.handle(
        _percentageMeta,
        percentage.isAcceptableOrUnknown(data['percentage']!, _percentageMeta),
      );
    }
    if (data.containsKey('score')) {
      context.handle(
        _scoreMeta,
        score.isAcceptableOrUnknown(data['score']!, _scoreMeta),
      );
    }
    if (data.containsKey('rank')) {
      context.handle(
        _rankMeta,
        rank.isAcceptableOrUnknown(data['rank']!, _rankMeta),
      );
    }
    if (data.containsKey('calculated_at')) {
      context.handle(
        _calculatedAtMeta,
        calculatedAt.isAcceptableOrUnknown(
          data['calculated_at']!,
          _calculatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_calculatedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserScore map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserScore(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      measureId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}measure_id'],
      )!,
      periodId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}period_id'],
      )!,
      targetValue: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}target_value'],
      )!,
      actualValue: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}actual_value'],
      )!,
      percentage: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}percentage'],
      )!,
      score: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}score'],
      )!,
      rank: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rank'],
      ),
      calculatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}calculated_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $UserScoresTable createAlias(String alias) {
    return $UserScoresTable(attachedDatabase, alias);
  }
}

class UserScore extends DataClass implements Insertable<UserScore> {
  final String id;
  final String userId;
  final String measureId;
  final String periodId;
  final double targetValue;
  final double actualValue;
  final double percentage;
  final double score;
  final int? rank;
  final DateTime calculatedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const UserScore({
    required this.id,
    required this.userId,
    required this.measureId,
    required this.periodId,
    required this.targetValue,
    required this.actualValue,
    required this.percentage,
    required this.score,
    this.rank,
    required this.calculatedAt,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['measure_id'] = Variable<String>(measureId);
    map['period_id'] = Variable<String>(periodId);
    map['target_value'] = Variable<double>(targetValue);
    map['actual_value'] = Variable<double>(actualValue);
    map['percentage'] = Variable<double>(percentage);
    map['score'] = Variable<double>(score);
    if (!nullToAbsent || rank != null) {
      map['rank'] = Variable<int>(rank);
    }
    map['calculated_at'] = Variable<DateTime>(calculatedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  UserScoresCompanion toCompanion(bool nullToAbsent) {
    return UserScoresCompanion(
      id: Value(id),
      userId: Value(userId),
      measureId: Value(measureId),
      periodId: Value(periodId),
      targetValue: Value(targetValue),
      actualValue: Value(actualValue),
      percentage: Value(percentage),
      score: Value(score),
      rank: rank == null && nullToAbsent ? const Value.absent() : Value(rank),
      calculatedAt: Value(calculatedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory UserScore.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserScore(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      measureId: serializer.fromJson<String>(json['measureId']),
      periodId: serializer.fromJson<String>(json['periodId']),
      targetValue: serializer.fromJson<double>(json['targetValue']),
      actualValue: serializer.fromJson<double>(json['actualValue']),
      percentage: serializer.fromJson<double>(json['percentage']),
      score: serializer.fromJson<double>(json['score']),
      rank: serializer.fromJson<int?>(json['rank']),
      calculatedAt: serializer.fromJson<DateTime>(json['calculatedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'measureId': serializer.toJson<String>(measureId),
      'periodId': serializer.toJson<String>(periodId),
      'targetValue': serializer.toJson<double>(targetValue),
      'actualValue': serializer.toJson<double>(actualValue),
      'percentage': serializer.toJson<double>(percentage),
      'score': serializer.toJson<double>(score),
      'rank': serializer.toJson<int?>(rank),
      'calculatedAt': serializer.toJson<DateTime>(calculatedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  UserScore copyWith({
    String? id,
    String? userId,
    String? measureId,
    String? periodId,
    double? targetValue,
    double? actualValue,
    double? percentage,
    double? score,
    Value<int?> rank = const Value.absent(),
    DateTime? calculatedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => UserScore(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    measureId: measureId ?? this.measureId,
    periodId: periodId ?? this.periodId,
    targetValue: targetValue ?? this.targetValue,
    actualValue: actualValue ?? this.actualValue,
    percentage: percentage ?? this.percentage,
    score: score ?? this.score,
    rank: rank.present ? rank.value : this.rank,
    calculatedAt: calculatedAt ?? this.calculatedAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  UserScore copyWithCompanion(UserScoresCompanion data) {
    return UserScore(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      measureId: data.measureId.present ? data.measureId.value : this.measureId,
      periodId: data.periodId.present ? data.periodId.value : this.periodId,
      targetValue: data.targetValue.present
          ? data.targetValue.value
          : this.targetValue,
      actualValue: data.actualValue.present
          ? data.actualValue.value
          : this.actualValue,
      percentage: data.percentage.present
          ? data.percentage.value
          : this.percentage,
      score: data.score.present ? data.score.value : this.score,
      rank: data.rank.present ? data.rank.value : this.rank,
      calculatedAt: data.calculatedAt.present
          ? data.calculatedAt.value
          : this.calculatedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserScore(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('measureId: $measureId, ')
          ..write('periodId: $periodId, ')
          ..write('targetValue: $targetValue, ')
          ..write('actualValue: $actualValue, ')
          ..write('percentage: $percentage, ')
          ..write('score: $score, ')
          ..write('rank: $rank, ')
          ..write('calculatedAt: $calculatedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    measureId,
    periodId,
    targetValue,
    actualValue,
    percentage,
    score,
    rank,
    calculatedAt,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserScore &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.measureId == this.measureId &&
          other.periodId == this.periodId &&
          other.targetValue == this.targetValue &&
          other.actualValue == this.actualValue &&
          other.percentage == this.percentage &&
          other.score == this.score &&
          other.rank == this.rank &&
          other.calculatedAt == this.calculatedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class UserScoresCompanion extends UpdateCompanion<UserScore> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> measureId;
  final Value<String> periodId;
  final Value<double> targetValue;
  final Value<double> actualValue;
  final Value<double> percentage;
  final Value<double> score;
  final Value<int?> rank;
  final Value<DateTime> calculatedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const UserScoresCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.measureId = const Value.absent(),
    this.periodId = const Value.absent(),
    this.targetValue = const Value.absent(),
    this.actualValue = const Value.absent(),
    this.percentage = const Value.absent(),
    this.score = const Value.absent(),
    this.rank = const Value.absent(),
    this.calculatedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserScoresCompanion.insert({
    required String id,
    required String userId,
    required String measureId,
    required String periodId,
    required double targetValue,
    this.actualValue = const Value.absent(),
    this.percentage = const Value.absent(),
    this.score = const Value.absent(),
    this.rank = const Value.absent(),
    required DateTime calculatedAt,
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       measureId = Value(measureId),
       periodId = Value(periodId),
       targetValue = Value(targetValue),
       calculatedAt = Value(calculatedAt),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<UserScore> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? measureId,
    Expression<String>? periodId,
    Expression<double>? targetValue,
    Expression<double>? actualValue,
    Expression<double>? percentage,
    Expression<double>? score,
    Expression<int>? rank,
    Expression<DateTime>? calculatedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (measureId != null) 'measure_id': measureId,
      if (periodId != null) 'period_id': periodId,
      if (targetValue != null) 'target_value': targetValue,
      if (actualValue != null) 'actual_value': actualValue,
      if (percentage != null) 'percentage': percentage,
      if (score != null) 'score': score,
      if (rank != null) 'rank': rank,
      if (calculatedAt != null) 'calculated_at': calculatedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserScoresCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? measureId,
    Value<String>? periodId,
    Value<double>? targetValue,
    Value<double>? actualValue,
    Value<double>? percentage,
    Value<double>? score,
    Value<int?>? rank,
    Value<DateTime>? calculatedAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return UserScoresCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      measureId: measureId ?? this.measureId,
      periodId: periodId ?? this.periodId,
      targetValue: targetValue ?? this.targetValue,
      actualValue: actualValue ?? this.actualValue,
      percentage: percentage ?? this.percentage,
      score: score ?? this.score,
      rank: rank ?? this.rank,
      calculatedAt: calculatedAt ?? this.calculatedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (measureId.present) {
      map['measure_id'] = Variable<String>(measureId.value);
    }
    if (periodId.present) {
      map['period_id'] = Variable<String>(periodId.value);
    }
    if (targetValue.present) {
      map['target_value'] = Variable<double>(targetValue.value);
    }
    if (actualValue.present) {
      map['actual_value'] = Variable<double>(actualValue.value);
    }
    if (percentage.present) {
      map['percentage'] = Variable<double>(percentage.value);
    }
    if (score.present) {
      map['score'] = Variable<double>(score.value);
    }
    if (rank.present) {
      map['rank'] = Variable<int>(rank.value);
    }
    if (calculatedAt.present) {
      map['calculated_at'] = Variable<DateTime>(calculatedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserScoresCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('measureId: $measureId, ')
          ..write('periodId: $periodId, ')
          ..write('targetValue: $targetValue, ')
          ..write('actualValue: $actualValue, ')
          ..write('percentage: $percentage, ')
          ..write('score: $score, ')
          ..write('rank: $rank, ')
          ..write('calculatedAt: $calculatedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserScoreAggregatesTable extends UserScoreAggregates
    with TableInfo<$UserScoreAggregatesTable, UserScoreAggregate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserScoreAggregatesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _periodIdMeta = const VerificationMeta(
    'periodId',
  );
  @override
  late final GeneratedColumn<String> periodId = GeneratedColumn<String>(
    'period_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES scoring_periods (id)',
    ),
  );
  static const VerificationMeta _leadScoreMeta = const VerificationMeta(
    'leadScore',
  );
  @override
  late final GeneratedColumn<double> leadScore = GeneratedColumn<double>(
    'lead_score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lagScoreMeta = const VerificationMeta(
    'lagScore',
  );
  @override
  late final GeneratedColumn<double> lagScore = GeneratedColumn<double>(
    'lag_score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _bonusPointsMeta = const VerificationMeta(
    'bonusPoints',
  );
  @override
  late final GeneratedColumn<double> bonusPoints = GeneratedColumn<double>(
    'bonus_points',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _penaltyPointsMeta = const VerificationMeta(
    'penaltyPoints',
  );
  @override
  late final GeneratedColumn<double> penaltyPoints = GeneratedColumn<double>(
    'penalty_points',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _totalScoreMeta = const VerificationMeta(
    'totalScore',
  );
  @override
  late final GeneratedColumn<double> totalScore = GeneratedColumn<double>(
    'total_score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _rankMeta = const VerificationMeta('rank');
  @override
  late final GeneratedColumn<int> rank = GeneratedColumn<int>(
    'rank',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rankChangeMeta = const VerificationMeta(
    'rankChange',
  );
  @override
  late final GeneratedColumn<int> rankChange = GeneratedColumn<int>(
    'rank_change',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _calculatedAtMeta = const VerificationMeta(
    'calculatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> calculatedAt = GeneratedColumn<DateTime>(
    'calculated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    periodId,
    leadScore,
    lagScore,
    bonusPoints,
    penaltyPoints,
    totalScore,
    rank,
    rankChange,
    calculatedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_score_aggregates';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserScoreAggregate> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('period_id')) {
      context.handle(
        _periodIdMeta,
        periodId.isAcceptableOrUnknown(data['period_id']!, _periodIdMeta),
      );
    } else if (isInserting) {
      context.missing(_periodIdMeta);
    }
    if (data.containsKey('lead_score')) {
      context.handle(
        _leadScoreMeta,
        leadScore.isAcceptableOrUnknown(data['lead_score']!, _leadScoreMeta),
      );
    }
    if (data.containsKey('lag_score')) {
      context.handle(
        _lagScoreMeta,
        lagScore.isAcceptableOrUnknown(data['lag_score']!, _lagScoreMeta),
      );
    }
    if (data.containsKey('bonus_points')) {
      context.handle(
        _bonusPointsMeta,
        bonusPoints.isAcceptableOrUnknown(
          data['bonus_points']!,
          _bonusPointsMeta,
        ),
      );
    }
    if (data.containsKey('penalty_points')) {
      context.handle(
        _penaltyPointsMeta,
        penaltyPoints.isAcceptableOrUnknown(
          data['penalty_points']!,
          _penaltyPointsMeta,
        ),
      );
    }
    if (data.containsKey('total_score')) {
      context.handle(
        _totalScoreMeta,
        totalScore.isAcceptableOrUnknown(data['total_score']!, _totalScoreMeta),
      );
    }
    if (data.containsKey('rank')) {
      context.handle(
        _rankMeta,
        rank.isAcceptableOrUnknown(data['rank']!, _rankMeta),
      );
    }
    if (data.containsKey('rank_change')) {
      context.handle(
        _rankChangeMeta,
        rankChange.isAcceptableOrUnknown(data['rank_change']!, _rankChangeMeta),
      );
    }
    if (data.containsKey('calculated_at')) {
      context.handle(
        _calculatedAtMeta,
        calculatedAt.isAcceptableOrUnknown(
          data['calculated_at']!,
          _calculatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_calculatedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserScoreAggregate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserScoreAggregate(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      periodId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}period_id'],
      )!,
      leadScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}lead_score'],
      )!,
      lagScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}lag_score'],
      )!,
      bonusPoints: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}bonus_points'],
      )!,
      penaltyPoints: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}penalty_points'],
      )!,
      totalScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_score'],
      )!,
      rank: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rank'],
      ),
      rankChange: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}rank_change'],
      ),
      calculatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}calculated_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $UserScoreAggregatesTable createAlias(String alias) {
    return $UserScoreAggregatesTable(attachedDatabase, alias);
  }
}

class UserScoreAggregate extends DataClass
    implements Insertable<UserScoreAggregate> {
  final String id;
  final String userId;
  final String periodId;
  final double leadScore;
  final double lagScore;
  final double bonusPoints;
  final double penaltyPoints;
  final double totalScore;
  final int? rank;
  final int? rankChange;
  final DateTime calculatedAt;
  final DateTime createdAt;
  const UserScoreAggregate({
    required this.id,
    required this.userId,
    required this.periodId,
    required this.leadScore,
    required this.lagScore,
    required this.bonusPoints,
    required this.penaltyPoints,
    required this.totalScore,
    this.rank,
    this.rankChange,
    required this.calculatedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['period_id'] = Variable<String>(periodId);
    map['lead_score'] = Variable<double>(leadScore);
    map['lag_score'] = Variable<double>(lagScore);
    map['bonus_points'] = Variable<double>(bonusPoints);
    map['penalty_points'] = Variable<double>(penaltyPoints);
    map['total_score'] = Variable<double>(totalScore);
    if (!nullToAbsent || rank != null) {
      map['rank'] = Variable<int>(rank);
    }
    if (!nullToAbsent || rankChange != null) {
      map['rank_change'] = Variable<int>(rankChange);
    }
    map['calculated_at'] = Variable<DateTime>(calculatedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  UserScoreAggregatesCompanion toCompanion(bool nullToAbsent) {
    return UserScoreAggregatesCompanion(
      id: Value(id),
      userId: Value(userId),
      periodId: Value(periodId),
      leadScore: Value(leadScore),
      lagScore: Value(lagScore),
      bonusPoints: Value(bonusPoints),
      penaltyPoints: Value(penaltyPoints),
      totalScore: Value(totalScore),
      rank: rank == null && nullToAbsent ? const Value.absent() : Value(rank),
      rankChange: rankChange == null && nullToAbsent
          ? const Value.absent()
          : Value(rankChange),
      calculatedAt: Value(calculatedAt),
      createdAt: Value(createdAt),
    );
  }

  factory UserScoreAggregate.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserScoreAggregate(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      periodId: serializer.fromJson<String>(json['periodId']),
      leadScore: serializer.fromJson<double>(json['leadScore']),
      lagScore: serializer.fromJson<double>(json['lagScore']),
      bonusPoints: serializer.fromJson<double>(json['bonusPoints']),
      penaltyPoints: serializer.fromJson<double>(json['penaltyPoints']),
      totalScore: serializer.fromJson<double>(json['totalScore']),
      rank: serializer.fromJson<int?>(json['rank']),
      rankChange: serializer.fromJson<int?>(json['rankChange']),
      calculatedAt: serializer.fromJson<DateTime>(json['calculatedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'periodId': serializer.toJson<String>(periodId),
      'leadScore': serializer.toJson<double>(leadScore),
      'lagScore': serializer.toJson<double>(lagScore),
      'bonusPoints': serializer.toJson<double>(bonusPoints),
      'penaltyPoints': serializer.toJson<double>(penaltyPoints),
      'totalScore': serializer.toJson<double>(totalScore),
      'rank': serializer.toJson<int?>(rank),
      'rankChange': serializer.toJson<int?>(rankChange),
      'calculatedAt': serializer.toJson<DateTime>(calculatedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  UserScoreAggregate copyWith({
    String? id,
    String? userId,
    String? periodId,
    double? leadScore,
    double? lagScore,
    double? bonusPoints,
    double? penaltyPoints,
    double? totalScore,
    Value<int?> rank = const Value.absent(),
    Value<int?> rankChange = const Value.absent(),
    DateTime? calculatedAt,
    DateTime? createdAt,
  }) => UserScoreAggregate(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    periodId: periodId ?? this.periodId,
    leadScore: leadScore ?? this.leadScore,
    lagScore: lagScore ?? this.lagScore,
    bonusPoints: bonusPoints ?? this.bonusPoints,
    penaltyPoints: penaltyPoints ?? this.penaltyPoints,
    totalScore: totalScore ?? this.totalScore,
    rank: rank.present ? rank.value : this.rank,
    rankChange: rankChange.present ? rankChange.value : this.rankChange,
    calculatedAt: calculatedAt ?? this.calculatedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  UserScoreAggregate copyWithCompanion(UserScoreAggregatesCompanion data) {
    return UserScoreAggregate(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      periodId: data.periodId.present ? data.periodId.value : this.periodId,
      leadScore: data.leadScore.present ? data.leadScore.value : this.leadScore,
      lagScore: data.lagScore.present ? data.lagScore.value : this.lagScore,
      bonusPoints: data.bonusPoints.present
          ? data.bonusPoints.value
          : this.bonusPoints,
      penaltyPoints: data.penaltyPoints.present
          ? data.penaltyPoints.value
          : this.penaltyPoints,
      totalScore: data.totalScore.present
          ? data.totalScore.value
          : this.totalScore,
      rank: data.rank.present ? data.rank.value : this.rank,
      rankChange: data.rankChange.present
          ? data.rankChange.value
          : this.rankChange,
      calculatedAt: data.calculatedAt.present
          ? data.calculatedAt.value
          : this.calculatedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserScoreAggregate(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('periodId: $periodId, ')
          ..write('leadScore: $leadScore, ')
          ..write('lagScore: $lagScore, ')
          ..write('bonusPoints: $bonusPoints, ')
          ..write('penaltyPoints: $penaltyPoints, ')
          ..write('totalScore: $totalScore, ')
          ..write('rank: $rank, ')
          ..write('rankChange: $rankChange, ')
          ..write('calculatedAt: $calculatedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    periodId,
    leadScore,
    lagScore,
    bonusPoints,
    penaltyPoints,
    totalScore,
    rank,
    rankChange,
    calculatedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserScoreAggregate &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.periodId == this.periodId &&
          other.leadScore == this.leadScore &&
          other.lagScore == this.lagScore &&
          other.bonusPoints == this.bonusPoints &&
          other.penaltyPoints == this.penaltyPoints &&
          other.totalScore == this.totalScore &&
          other.rank == this.rank &&
          other.rankChange == this.rankChange &&
          other.calculatedAt == this.calculatedAt &&
          other.createdAt == this.createdAt);
}

class UserScoreAggregatesCompanion extends UpdateCompanion<UserScoreAggregate> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> periodId;
  final Value<double> leadScore;
  final Value<double> lagScore;
  final Value<double> bonusPoints;
  final Value<double> penaltyPoints;
  final Value<double> totalScore;
  final Value<int?> rank;
  final Value<int?> rankChange;
  final Value<DateTime> calculatedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const UserScoreAggregatesCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.periodId = const Value.absent(),
    this.leadScore = const Value.absent(),
    this.lagScore = const Value.absent(),
    this.bonusPoints = const Value.absent(),
    this.penaltyPoints = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.rank = const Value.absent(),
    this.rankChange = const Value.absent(),
    this.calculatedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserScoreAggregatesCompanion.insert({
    required String id,
    required String userId,
    required String periodId,
    this.leadScore = const Value.absent(),
    this.lagScore = const Value.absent(),
    this.bonusPoints = const Value.absent(),
    this.penaltyPoints = const Value.absent(),
    this.totalScore = const Value.absent(),
    this.rank = const Value.absent(),
    this.rankChange = const Value.absent(),
    required DateTime calculatedAt,
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       periodId = Value(periodId),
       calculatedAt = Value(calculatedAt),
       createdAt = Value(createdAt);
  static Insertable<UserScoreAggregate> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? periodId,
    Expression<double>? leadScore,
    Expression<double>? lagScore,
    Expression<double>? bonusPoints,
    Expression<double>? penaltyPoints,
    Expression<double>? totalScore,
    Expression<int>? rank,
    Expression<int>? rankChange,
    Expression<DateTime>? calculatedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (periodId != null) 'period_id': periodId,
      if (leadScore != null) 'lead_score': leadScore,
      if (lagScore != null) 'lag_score': lagScore,
      if (bonusPoints != null) 'bonus_points': bonusPoints,
      if (penaltyPoints != null) 'penalty_points': penaltyPoints,
      if (totalScore != null) 'total_score': totalScore,
      if (rank != null) 'rank': rank,
      if (rankChange != null) 'rank_change': rankChange,
      if (calculatedAt != null) 'calculated_at': calculatedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserScoreAggregatesCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? periodId,
    Value<double>? leadScore,
    Value<double>? lagScore,
    Value<double>? bonusPoints,
    Value<double>? penaltyPoints,
    Value<double>? totalScore,
    Value<int?>? rank,
    Value<int?>? rankChange,
    Value<DateTime>? calculatedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return UserScoreAggregatesCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      periodId: periodId ?? this.periodId,
      leadScore: leadScore ?? this.leadScore,
      lagScore: lagScore ?? this.lagScore,
      bonusPoints: bonusPoints ?? this.bonusPoints,
      penaltyPoints: penaltyPoints ?? this.penaltyPoints,
      totalScore: totalScore ?? this.totalScore,
      rank: rank ?? this.rank,
      rankChange: rankChange ?? this.rankChange,
      calculatedAt: calculatedAt ?? this.calculatedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (periodId.present) {
      map['period_id'] = Variable<String>(periodId.value);
    }
    if (leadScore.present) {
      map['lead_score'] = Variable<double>(leadScore.value);
    }
    if (lagScore.present) {
      map['lag_score'] = Variable<double>(lagScore.value);
    }
    if (bonusPoints.present) {
      map['bonus_points'] = Variable<double>(bonusPoints.value);
    }
    if (penaltyPoints.present) {
      map['penalty_points'] = Variable<double>(penaltyPoints.value);
    }
    if (totalScore.present) {
      map['total_score'] = Variable<double>(totalScore.value);
    }
    if (rank.present) {
      map['rank'] = Variable<int>(rank.value);
    }
    if (rankChange.present) {
      map['rank_change'] = Variable<int>(rankChange.value);
    }
    if (calculatedAt.present) {
      map['calculated_at'] = Variable<DateTime>(calculatedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserScoreAggregatesCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('periodId: $periodId, ')
          ..write('leadScore: $leadScore, ')
          ..write('lagScore: $lagScore, ')
          ..write('bonusPoints: $bonusPoints, ')
          ..write('penaltyPoints: $penaltyPoints, ')
          ..write('totalScore: $totalScore, ')
          ..write('rank: $rank, ')
          ..write('rankChange: $rankChange, ')
          ..write('calculatedAt: $calculatedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CadenceScheduleConfigTable extends CadenceScheduleConfig
    with TableInfo<$CadenceScheduleConfigTable, CadenceScheduleConfigData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CadenceScheduleConfigTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _targetRoleMeta = const VerificationMeta(
    'targetRole',
  );
  @override
  late final GeneratedColumn<String> targetRole = GeneratedColumn<String>(
    'target_role',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _facilitatorRoleMeta = const VerificationMeta(
    'facilitatorRole',
  );
  @override
  late final GeneratedColumn<String> facilitatorRole = GeneratedColumn<String>(
    'facilitator_role',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _frequencyMeta = const VerificationMeta(
    'frequency',
  );
  @override
  late final GeneratedColumn<String> frequency = GeneratedColumn<String>(
    'frequency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dayOfWeekMeta = const VerificationMeta(
    'dayOfWeek',
  );
  @override
  late final GeneratedColumn<int> dayOfWeek = GeneratedColumn<int>(
    'day_of_week',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dayOfMonthMeta = const VerificationMeta(
    'dayOfMonth',
  );
  @override
  late final GeneratedColumn<int> dayOfMonth = GeneratedColumn<int>(
    'day_of_month',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _defaultTimeMeta = const VerificationMeta(
    'defaultTime',
  );
  @override
  late final GeneratedColumn<String> defaultTime = GeneratedColumn<String>(
    'default_time',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(60),
  );
  static const VerificationMeta _preMeetingHoursMeta = const VerificationMeta(
    'preMeetingHours',
  );
  @override
  late final GeneratedColumn<int> preMeetingHours = GeneratedColumn<int>(
    'pre_meeting_hours',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(24),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    description,
    targetRole,
    facilitatorRole,
    frequency,
    dayOfWeek,
    dayOfMonth,
    defaultTime,
    durationMinutes,
    preMeetingHours,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cadence_schedule_config';
  @override
  VerificationContext validateIntegrity(
    Insertable<CadenceScheduleConfigData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('target_role')) {
      context.handle(
        _targetRoleMeta,
        targetRole.isAcceptableOrUnknown(data['target_role']!, _targetRoleMeta),
      );
    } else if (isInserting) {
      context.missing(_targetRoleMeta);
    }
    if (data.containsKey('facilitator_role')) {
      context.handle(
        _facilitatorRoleMeta,
        facilitatorRole.isAcceptableOrUnknown(
          data['facilitator_role']!,
          _facilitatorRoleMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_facilitatorRoleMeta);
    }
    if (data.containsKey('frequency')) {
      context.handle(
        _frequencyMeta,
        frequency.isAcceptableOrUnknown(data['frequency']!, _frequencyMeta),
      );
    } else if (isInserting) {
      context.missing(_frequencyMeta);
    }
    if (data.containsKey('day_of_week')) {
      context.handle(
        _dayOfWeekMeta,
        dayOfWeek.isAcceptableOrUnknown(data['day_of_week']!, _dayOfWeekMeta),
      );
    }
    if (data.containsKey('day_of_month')) {
      context.handle(
        _dayOfMonthMeta,
        dayOfMonth.isAcceptableOrUnknown(
          data['day_of_month']!,
          _dayOfMonthMeta,
        ),
      );
    }
    if (data.containsKey('default_time')) {
      context.handle(
        _defaultTimeMeta,
        defaultTime.isAcceptableOrUnknown(
          data['default_time']!,
          _defaultTimeMeta,
        ),
      );
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    }
    if (data.containsKey('pre_meeting_hours')) {
      context.handle(
        _preMeetingHoursMeta,
        preMeetingHours.isAcceptableOrUnknown(
          data['pre_meeting_hours']!,
          _preMeetingHoursMeta,
        ),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CadenceScheduleConfigData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CadenceScheduleConfigData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      targetRole: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_role'],
      )!,
      facilitatorRole: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}facilitator_role'],
      )!,
      frequency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}frequency'],
      )!,
      dayOfWeek: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}day_of_week'],
      ),
      dayOfMonth: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}day_of_month'],
      ),
      defaultTime: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}default_time'],
      ),
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      )!,
      preMeetingHours: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}pre_meeting_hours'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CadenceScheduleConfigTable createAlias(String alias) {
    return $CadenceScheduleConfigTable(attachedDatabase, alias);
  }
}

class CadenceScheduleConfigData extends DataClass
    implements Insertable<CadenceScheduleConfigData> {
  final String id;
  final String name;
  final String? description;
  final String targetRole;
  final String facilitatorRole;
  final String frequency;
  final int? dayOfWeek;
  final int? dayOfMonth;
  final String? defaultTime;
  final int durationMinutes;
  final int preMeetingHours;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const CadenceScheduleConfigData({
    required this.id,
    required this.name,
    this.description,
    required this.targetRole,
    required this.facilitatorRole,
    required this.frequency,
    this.dayOfWeek,
    this.dayOfMonth,
    this.defaultTime,
    required this.durationMinutes,
    required this.preMeetingHours,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['target_role'] = Variable<String>(targetRole);
    map['facilitator_role'] = Variable<String>(facilitatorRole);
    map['frequency'] = Variable<String>(frequency);
    if (!nullToAbsent || dayOfWeek != null) {
      map['day_of_week'] = Variable<int>(dayOfWeek);
    }
    if (!nullToAbsent || dayOfMonth != null) {
      map['day_of_month'] = Variable<int>(dayOfMonth);
    }
    if (!nullToAbsent || defaultTime != null) {
      map['default_time'] = Variable<String>(defaultTime);
    }
    map['duration_minutes'] = Variable<int>(durationMinutes);
    map['pre_meeting_hours'] = Variable<int>(preMeetingHours);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  CadenceScheduleConfigCompanion toCompanion(bool nullToAbsent) {
    return CadenceScheduleConfigCompanion(
      id: Value(id),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      targetRole: Value(targetRole),
      facilitatorRole: Value(facilitatorRole),
      frequency: Value(frequency),
      dayOfWeek: dayOfWeek == null && nullToAbsent
          ? const Value.absent()
          : Value(dayOfWeek),
      dayOfMonth: dayOfMonth == null && nullToAbsent
          ? const Value.absent()
          : Value(dayOfMonth),
      defaultTime: defaultTime == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultTime),
      durationMinutes: Value(durationMinutes),
      preMeetingHours: Value(preMeetingHours),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory CadenceScheduleConfigData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CadenceScheduleConfigData(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      targetRole: serializer.fromJson<String>(json['targetRole']),
      facilitatorRole: serializer.fromJson<String>(json['facilitatorRole']),
      frequency: serializer.fromJson<String>(json['frequency']),
      dayOfWeek: serializer.fromJson<int?>(json['dayOfWeek']),
      dayOfMonth: serializer.fromJson<int?>(json['dayOfMonth']),
      defaultTime: serializer.fromJson<String?>(json['defaultTime']),
      durationMinutes: serializer.fromJson<int>(json['durationMinutes']),
      preMeetingHours: serializer.fromJson<int>(json['preMeetingHours']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'targetRole': serializer.toJson<String>(targetRole),
      'facilitatorRole': serializer.toJson<String>(facilitatorRole),
      'frequency': serializer.toJson<String>(frequency),
      'dayOfWeek': serializer.toJson<int?>(dayOfWeek),
      'dayOfMonth': serializer.toJson<int?>(dayOfMonth),
      'defaultTime': serializer.toJson<String?>(defaultTime),
      'durationMinutes': serializer.toJson<int>(durationMinutes),
      'preMeetingHours': serializer.toJson<int>(preMeetingHours),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  CadenceScheduleConfigData copyWith({
    String? id,
    String? name,
    Value<String?> description = const Value.absent(),
    String? targetRole,
    String? facilitatorRole,
    String? frequency,
    Value<int?> dayOfWeek = const Value.absent(),
    Value<int?> dayOfMonth = const Value.absent(),
    Value<String?> defaultTime = const Value.absent(),
    int? durationMinutes,
    int? preMeetingHours,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => CadenceScheduleConfigData(
    id: id ?? this.id,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    targetRole: targetRole ?? this.targetRole,
    facilitatorRole: facilitatorRole ?? this.facilitatorRole,
    frequency: frequency ?? this.frequency,
    dayOfWeek: dayOfWeek.present ? dayOfWeek.value : this.dayOfWeek,
    dayOfMonth: dayOfMonth.present ? dayOfMonth.value : this.dayOfMonth,
    defaultTime: defaultTime.present ? defaultTime.value : this.defaultTime,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    preMeetingHours: preMeetingHours ?? this.preMeetingHours,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  CadenceScheduleConfigData copyWithCompanion(
    CadenceScheduleConfigCompanion data,
  ) {
    return CadenceScheduleConfigData(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      targetRole: data.targetRole.present
          ? data.targetRole.value
          : this.targetRole,
      facilitatorRole: data.facilitatorRole.present
          ? data.facilitatorRole.value
          : this.facilitatorRole,
      frequency: data.frequency.present ? data.frequency.value : this.frequency,
      dayOfWeek: data.dayOfWeek.present ? data.dayOfWeek.value : this.dayOfWeek,
      dayOfMonth: data.dayOfMonth.present
          ? data.dayOfMonth.value
          : this.dayOfMonth,
      defaultTime: data.defaultTime.present
          ? data.defaultTime.value
          : this.defaultTime,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      preMeetingHours: data.preMeetingHours.present
          ? data.preMeetingHours.value
          : this.preMeetingHours,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CadenceScheduleConfigData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('targetRole: $targetRole, ')
          ..write('facilitatorRole: $facilitatorRole, ')
          ..write('frequency: $frequency, ')
          ..write('dayOfWeek: $dayOfWeek, ')
          ..write('dayOfMonth: $dayOfMonth, ')
          ..write('defaultTime: $defaultTime, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('preMeetingHours: $preMeetingHours, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    description,
    targetRole,
    facilitatorRole,
    frequency,
    dayOfWeek,
    dayOfMonth,
    defaultTime,
    durationMinutes,
    preMeetingHours,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CadenceScheduleConfigData &&
          other.id == this.id &&
          other.name == this.name &&
          other.description == this.description &&
          other.targetRole == this.targetRole &&
          other.facilitatorRole == this.facilitatorRole &&
          other.frequency == this.frequency &&
          other.dayOfWeek == this.dayOfWeek &&
          other.dayOfMonth == this.dayOfMonth &&
          other.defaultTime == this.defaultTime &&
          other.durationMinutes == this.durationMinutes &&
          other.preMeetingHours == this.preMeetingHours &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CadenceScheduleConfigCompanion
    extends UpdateCompanion<CadenceScheduleConfigData> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> description;
  final Value<String> targetRole;
  final Value<String> facilitatorRole;
  final Value<String> frequency;
  final Value<int?> dayOfWeek;
  final Value<int?> dayOfMonth;
  final Value<String?> defaultTime;
  final Value<int> durationMinutes;
  final Value<int> preMeetingHours;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const CadenceScheduleConfigCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.targetRole = const Value.absent(),
    this.facilitatorRole = const Value.absent(),
    this.frequency = const Value.absent(),
    this.dayOfWeek = const Value.absent(),
    this.dayOfMonth = const Value.absent(),
    this.defaultTime = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.preMeetingHours = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CadenceScheduleConfigCompanion.insert({
    required String id,
    required String name,
    this.description = const Value.absent(),
    required String targetRole,
    required String facilitatorRole,
    required String frequency,
    this.dayOfWeek = const Value.absent(),
    this.dayOfMonth = const Value.absent(),
    this.defaultTime = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.preMeetingHours = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       targetRole = Value(targetRole),
       facilitatorRole = Value(facilitatorRole),
       frequency = Value(frequency),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<CadenceScheduleConfigData> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? targetRole,
    Expression<String>? facilitatorRole,
    Expression<String>? frequency,
    Expression<int>? dayOfWeek,
    Expression<int>? dayOfMonth,
    Expression<String>? defaultTime,
    Expression<int>? durationMinutes,
    Expression<int>? preMeetingHours,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (targetRole != null) 'target_role': targetRole,
      if (facilitatorRole != null) 'facilitator_role': facilitatorRole,
      if (frequency != null) 'frequency': frequency,
      if (dayOfWeek != null) 'day_of_week': dayOfWeek,
      if (dayOfMonth != null) 'day_of_month': dayOfMonth,
      if (defaultTime != null) 'default_time': defaultTime,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (preMeetingHours != null) 'pre_meeting_hours': preMeetingHours,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CadenceScheduleConfigCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? description,
    Value<String>? targetRole,
    Value<String>? facilitatorRole,
    Value<String>? frequency,
    Value<int?>? dayOfWeek,
    Value<int?>? dayOfMonth,
    Value<String?>? defaultTime,
    Value<int>? durationMinutes,
    Value<int>? preMeetingHours,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return CadenceScheduleConfigCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      targetRole: targetRole ?? this.targetRole,
      facilitatorRole: facilitatorRole ?? this.facilitatorRole,
      frequency: frequency ?? this.frequency,
      dayOfWeek: dayOfWeek ?? this.dayOfWeek,
      dayOfMonth: dayOfMonth ?? this.dayOfMonth,
      defaultTime: defaultTime ?? this.defaultTime,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      preMeetingHours: preMeetingHours ?? this.preMeetingHours,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (targetRole.present) {
      map['target_role'] = Variable<String>(targetRole.value);
    }
    if (facilitatorRole.present) {
      map['facilitator_role'] = Variable<String>(facilitatorRole.value);
    }
    if (frequency.present) {
      map['frequency'] = Variable<String>(frequency.value);
    }
    if (dayOfWeek.present) {
      map['day_of_week'] = Variable<int>(dayOfWeek.value);
    }
    if (dayOfMonth.present) {
      map['day_of_month'] = Variable<int>(dayOfMonth.value);
    }
    if (defaultTime.present) {
      map['default_time'] = Variable<String>(defaultTime.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (preMeetingHours.present) {
      map['pre_meeting_hours'] = Variable<int>(preMeetingHours.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CadenceScheduleConfigCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('targetRole: $targetRole, ')
          ..write('facilitatorRole: $facilitatorRole, ')
          ..write('frequency: $frequency, ')
          ..write('dayOfWeek: $dayOfWeek, ')
          ..write('dayOfMonth: $dayOfMonth, ')
          ..write('defaultTime: $defaultTime, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('preMeetingHours: $preMeetingHours, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CadenceMeetingsTable extends CadenceMeetings
    with TableInfo<$CadenceMeetingsTable, CadenceMeeting> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CadenceMeetingsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _configIdMeta = const VerificationMeta(
    'configId',
  );
  @override
  late final GeneratedColumn<String> configId = GeneratedColumn<String>(
    'config_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES cadence_schedule_config (id)',
    ),
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scheduledAtMeta = const VerificationMeta(
    'scheduledAt',
  );
  @override
  late final GeneratedColumn<DateTime> scheduledAt = GeneratedColumn<DateTime>(
    'scheduled_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _durationMinutesMeta = const VerificationMeta(
    'durationMinutes',
  );
  @override
  late final GeneratedColumn<int> durationMinutes = GeneratedColumn<int>(
    'duration_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _facilitatorIdMeta = const VerificationMeta(
    'facilitatorId',
  );
  @override
  late final GeneratedColumn<String> facilitatorId = GeneratedColumn<String>(
    'facilitator_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('SCHEDULED'),
  );
  static const VerificationMeta _locationMeta = const VerificationMeta(
    'location',
  );
  @override
  late final GeneratedColumn<String> location = GeneratedColumn<String>(
    'location',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _meetingLinkMeta = const VerificationMeta(
    'meetingLink',
  );
  @override
  late final GeneratedColumn<String> meetingLink = GeneratedColumn<String>(
    'meeting_link',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _agendaMeta = const VerificationMeta('agenda');
  @override
  late final GeneratedColumn<String> agenda = GeneratedColumn<String>(
    'agenda',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    configId,
    title,
    scheduledAt,
    durationMinutes,
    facilitatorId,
    status,
    location,
    meetingLink,
    agenda,
    notes,
    startedAt,
    completedAt,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    lastSyncAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cadence_meetings';
  @override
  VerificationContext validateIntegrity(
    Insertable<CadenceMeeting> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('config_id')) {
      context.handle(
        _configIdMeta,
        configId.isAcceptableOrUnknown(data['config_id']!, _configIdMeta),
      );
    } else if (isInserting) {
      context.missing(_configIdMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('scheduled_at')) {
      context.handle(
        _scheduledAtMeta,
        scheduledAt.isAcceptableOrUnknown(
          data['scheduled_at']!,
          _scheduledAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_scheduledAtMeta);
    }
    if (data.containsKey('duration_minutes')) {
      context.handle(
        _durationMinutesMeta,
        durationMinutes.isAcceptableOrUnknown(
          data['duration_minutes']!,
          _durationMinutesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_durationMinutesMeta);
    }
    if (data.containsKey('facilitator_id')) {
      context.handle(
        _facilitatorIdMeta,
        facilitatorId.isAcceptableOrUnknown(
          data['facilitator_id']!,
          _facilitatorIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_facilitatorIdMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('location')) {
      context.handle(
        _locationMeta,
        location.isAcceptableOrUnknown(data['location']!, _locationMeta),
      );
    }
    if (data.containsKey('meeting_link')) {
      context.handle(
        _meetingLinkMeta,
        meetingLink.isAcceptableOrUnknown(
          data['meeting_link']!,
          _meetingLinkMeta,
        ),
      );
    }
    if (data.containsKey('agenda')) {
      context.handle(
        _agendaMeta,
        agenda.isAcceptableOrUnknown(data['agenda']!, _agendaMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CadenceMeeting map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CadenceMeeting(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      configId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}config_id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      scheduledAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}scheduled_at'],
      )!,
      durationMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_minutes'],
      )!,
      facilitatorId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}facilitator_id'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      location: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location'],
      ),
      meetingLink: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}meeting_link'],
      ),
      agenda: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}agenda'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      ),
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
    );
  }

  @override
  $CadenceMeetingsTable createAlias(String alias) {
    return $CadenceMeetingsTable(attachedDatabase, alias);
  }
}

class CadenceMeeting extends DataClass implements Insertable<CadenceMeeting> {
  final String id;
  final String configId;
  final String title;
  final DateTime scheduledAt;
  final int durationMinutes;
  final String facilitatorId;
  final String status;
  final String? location;
  final String? meetingLink;
  final String? agenda;
  final String? notes;
  final DateTime? startedAt;
  final DateTime? completedAt;
  final String createdBy;
  final bool isPendingSync;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? lastSyncAt;
  const CadenceMeeting({
    required this.id,
    required this.configId,
    required this.title,
    required this.scheduledAt,
    required this.durationMinutes,
    required this.facilitatorId,
    required this.status,
    this.location,
    this.meetingLink,
    this.agenda,
    this.notes,
    this.startedAt,
    this.completedAt,
    required this.createdBy,
    required this.isPendingSync,
    required this.createdAt,
    required this.updatedAt,
    this.lastSyncAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['config_id'] = Variable<String>(configId);
    map['title'] = Variable<String>(title);
    map['scheduled_at'] = Variable<DateTime>(scheduledAt);
    map['duration_minutes'] = Variable<int>(durationMinutes);
    map['facilitator_id'] = Variable<String>(facilitatorId);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || location != null) {
      map['location'] = Variable<String>(location);
    }
    if (!nullToAbsent || meetingLink != null) {
      map['meeting_link'] = Variable<String>(meetingLink);
    }
    if (!nullToAbsent || agenda != null) {
      map['agenda'] = Variable<String>(agenda);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || startedAt != null) {
      map['started_at'] = Variable<DateTime>(startedAt);
    }
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    return map;
  }

  CadenceMeetingsCompanion toCompanion(bool nullToAbsent) {
    return CadenceMeetingsCompanion(
      id: Value(id),
      configId: Value(configId),
      title: Value(title),
      scheduledAt: Value(scheduledAt),
      durationMinutes: Value(durationMinutes),
      facilitatorId: Value(facilitatorId),
      status: Value(status),
      location: location == null && nullToAbsent
          ? const Value.absent()
          : Value(location),
      meetingLink: meetingLink == null && nullToAbsent
          ? const Value.absent()
          : Value(meetingLink),
      agenda: agenda == null && nullToAbsent
          ? const Value.absent()
          : Value(agenda),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      startedAt: startedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(startedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      createdBy: Value(createdBy),
      isPendingSync: Value(isPendingSync),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
    );
  }

  factory CadenceMeeting.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CadenceMeeting(
      id: serializer.fromJson<String>(json['id']),
      configId: serializer.fromJson<String>(json['configId']),
      title: serializer.fromJson<String>(json['title']),
      scheduledAt: serializer.fromJson<DateTime>(json['scheduledAt']),
      durationMinutes: serializer.fromJson<int>(json['durationMinutes']),
      facilitatorId: serializer.fromJson<String>(json['facilitatorId']),
      status: serializer.fromJson<String>(json['status']),
      location: serializer.fromJson<String?>(json['location']),
      meetingLink: serializer.fromJson<String?>(json['meetingLink']),
      agenda: serializer.fromJson<String?>(json['agenda']),
      notes: serializer.fromJson<String?>(json['notes']),
      startedAt: serializer.fromJson<DateTime?>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'configId': serializer.toJson<String>(configId),
      'title': serializer.toJson<String>(title),
      'scheduledAt': serializer.toJson<DateTime>(scheduledAt),
      'durationMinutes': serializer.toJson<int>(durationMinutes),
      'facilitatorId': serializer.toJson<String>(facilitatorId),
      'status': serializer.toJson<String>(status),
      'location': serializer.toJson<String?>(location),
      'meetingLink': serializer.toJson<String?>(meetingLink),
      'agenda': serializer.toJson<String?>(agenda),
      'notes': serializer.toJson<String?>(notes),
      'startedAt': serializer.toJson<DateTime?>(startedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'createdBy': serializer.toJson<String>(createdBy),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
    };
  }

  CadenceMeeting copyWith({
    String? id,
    String? configId,
    String? title,
    DateTime? scheduledAt,
    int? durationMinutes,
    String? facilitatorId,
    String? status,
    Value<String?> location = const Value.absent(),
    Value<String?> meetingLink = const Value.absent(),
    Value<String?> agenda = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<DateTime?> startedAt = const Value.absent(),
    Value<DateTime?> completedAt = const Value.absent(),
    String? createdBy,
    bool? isPendingSync,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> lastSyncAt = const Value.absent(),
  }) => CadenceMeeting(
    id: id ?? this.id,
    configId: configId ?? this.configId,
    title: title ?? this.title,
    scheduledAt: scheduledAt ?? this.scheduledAt,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    facilitatorId: facilitatorId ?? this.facilitatorId,
    status: status ?? this.status,
    location: location.present ? location.value : this.location,
    meetingLink: meetingLink.present ? meetingLink.value : this.meetingLink,
    agenda: agenda.present ? agenda.value : this.agenda,
    notes: notes.present ? notes.value : this.notes,
    startedAt: startedAt.present ? startedAt.value : this.startedAt,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
    createdBy: createdBy ?? this.createdBy,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
  );
  CadenceMeeting copyWithCompanion(CadenceMeetingsCompanion data) {
    return CadenceMeeting(
      id: data.id.present ? data.id.value : this.id,
      configId: data.configId.present ? data.configId.value : this.configId,
      title: data.title.present ? data.title.value : this.title,
      scheduledAt: data.scheduledAt.present
          ? data.scheduledAt.value
          : this.scheduledAt,
      durationMinutes: data.durationMinutes.present
          ? data.durationMinutes.value
          : this.durationMinutes,
      facilitatorId: data.facilitatorId.present
          ? data.facilitatorId.value
          : this.facilitatorId,
      status: data.status.present ? data.status.value : this.status,
      location: data.location.present ? data.location.value : this.location,
      meetingLink: data.meetingLink.present
          ? data.meetingLink.value
          : this.meetingLink,
      agenda: data.agenda.present ? data.agenda.value : this.agenda,
      notes: data.notes.present ? data.notes.value : this.notes,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CadenceMeeting(')
          ..write('id: $id, ')
          ..write('configId: $configId, ')
          ..write('title: $title, ')
          ..write('scheduledAt: $scheduledAt, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('facilitatorId: $facilitatorId, ')
          ..write('status: $status, ')
          ..write('location: $location, ')
          ..write('meetingLink: $meetingLink, ')
          ..write('agenda: $agenda, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('lastSyncAt: $lastSyncAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    configId,
    title,
    scheduledAt,
    durationMinutes,
    facilitatorId,
    status,
    location,
    meetingLink,
    agenda,
    notes,
    startedAt,
    completedAt,
    createdBy,
    isPendingSync,
    createdAt,
    updatedAt,
    lastSyncAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CadenceMeeting &&
          other.id == this.id &&
          other.configId == this.configId &&
          other.title == this.title &&
          other.scheduledAt == this.scheduledAt &&
          other.durationMinutes == this.durationMinutes &&
          other.facilitatorId == this.facilitatorId &&
          other.status == this.status &&
          other.location == this.location &&
          other.meetingLink == this.meetingLink &&
          other.agenda == this.agenda &&
          other.notes == this.notes &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.createdBy == this.createdBy &&
          other.isPendingSync == this.isPendingSync &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.lastSyncAt == this.lastSyncAt);
}

class CadenceMeetingsCompanion extends UpdateCompanion<CadenceMeeting> {
  final Value<String> id;
  final Value<String> configId;
  final Value<String> title;
  final Value<DateTime> scheduledAt;
  final Value<int> durationMinutes;
  final Value<String> facilitatorId;
  final Value<String> status;
  final Value<String?> location;
  final Value<String?> meetingLink;
  final Value<String?> agenda;
  final Value<String?> notes;
  final Value<DateTime?> startedAt;
  final Value<DateTime?> completedAt;
  final Value<String> createdBy;
  final Value<bool> isPendingSync;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> lastSyncAt;
  final Value<int> rowid;
  const CadenceMeetingsCompanion({
    this.id = const Value.absent(),
    this.configId = const Value.absent(),
    this.title = const Value.absent(),
    this.scheduledAt = const Value.absent(),
    this.durationMinutes = const Value.absent(),
    this.facilitatorId = const Value.absent(),
    this.status = const Value.absent(),
    this.location = const Value.absent(),
    this.meetingLink = const Value.absent(),
    this.agenda = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CadenceMeetingsCompanion.insert({
    required String id,
    required String configId,
    required String title,
    required DateTime scheduledAt,
    required int durationMinutes,
    required String facilitatorId,
    this.status = const Value.absent(),
    this.location = const Value.absent(),
    this.meetingLink = const Value.absent(),
    this.agenda = const Value.absent(),
    this.notes = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    required String createdBy,
    this.isPendingSync = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.lastSyncAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       configId = Value(configId),
       title = Value(title),
       scheduledAt = Value(scheduledAt),
       durationMinutes = Value(durationMinutes),
       facilitatorId = Value(facilitatorId),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<CadenceMeeting> custom({
    Expression<String>? id,
    Expression<String>? configId,
    Expression<String>? title,
    Expression<DateTime>? scheduledAt,
    Expression<int>? durationMinutes,
    Expression<String>? facilitatorId,
    Expression<String>? status,
    Expression<String>? location,
    Expression<String>? meetingLink,
    Expression<String>? agenda,
    Expression<String>? notes,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<String>? createdBy,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? lastSyncAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (configId != null) 'config_id': configId,
      if (title != null) 'title': title,
      if (scheduledAt != null) 'scheduled_at': scheduledAt,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (facilitatorId != null) 'facilitator_id': facilitatorId,
      if (status != null) 'status': status,
      if (location != null) 'location': location,
      if (meetingLink != null) 'meeting_link': meetingLink,
      if (agenda != null) 'agenda': agenda,
      if (notes != null) 'notes': notes,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (createdBy != null) 'created_by': createdBy,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CadenceMeetingsCompanion copyWith({
    Value<String>? id,
    Value<String>? configId,
    Value<String>? title,
    Value<DateTime>? scheduledAt,
    Value<int>? durationMinutes,
    Value<String>? facilitatorId,
    Value<String>? status,
    Value<String?>? location,
    Value<String?>? meetingLink,
    Value<String?>? agenda,
    Value<String?>? notes,
    Value<DateTime?>? startedAt,
    Value<DateTime?>? completedAt,
    Value<String>? createdBy,
    Value<bool>? isPendingSync,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? lastSyncAt,
    Value<int>? rowid,
  }) {
    return CadenceMeetingsCompanion(
      id: id ?? this.id,
      configId: configId ?? this.configId,
      title: title ?? this.title,
      scheduledAt: scheduledAt ?? this.scheduledAt,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      facilitatorId: facilitatorId ?? this.facilitatorId,
      status: status ?? this.status,
      location: location ?? this.location,
      meetingLink: meetingLink ?? this.meetingLink,
      agenda: agenda ?? this.agenda,
      notes: notes ?? this.notes,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      createdBy: createdBy ?? this.createdBy,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (configId.present) {
      map['config_id'] = Variable<String>(configId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (scheduledAt.present) {
      map['scheduled_at'] = Variable<DateTime>(scheduledAt.value);
    }
    if (durationMinutes.present) {
      map['duration_minutes'] = Variable<int>(durationMinutes.value);
    }
    if (facilitatorId.present) {
      map['facilitator_id'] = Variable<String>(facilitatorId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (location.present) {
      map['location'] = Variable<String>(location.value);
    }
    if (meetingLink.present) {
      map['meeting_link'] = Variable<String>(meetingLink.value);
    }
    if (agenda.present) {
      map['agenda'] = Variable<String>(agenda.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CadenceMeetingsCompanion(')
          ..write('id: $id, ')
          ..write('configId: $configId, ')
          ..write('title: $title, ')
          ..write('scheduledAt: $scheduledAt, ')
          ..write('durationMinutes: $durationMinutes, ')
          ..write('facilitatorId: $facilitatorId, ')
          ..write('status: $status, ')
          ..write('location: $location, ')
          ..write('meetingLink: $meetingLink, ')
          ..write('agenda: $agenda, ')
          ..write('notes: $notes, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('createdBy: $createdBy, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CadenceParticipantsTable extends CadenceParticipants
    with TableInfo<$CadenceParticipantsTable, CadenceParticipant> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CadenceParticipantsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _meetingIdMeta = const VerificationMeta(
    'meetingId',
  );
  @override
  late final GeneratedColumn<String> meetingId = GeneratedColumn<String>(
    'meeting_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES cadence_meetings (id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _attendanceStatusMeta = const VerificationMeta(
    'attendanceStatus',
  );
  @override
  late final GeneratedColumn<String> attendanceStatus = GeneratedColumn<String>(
    'attendance_status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('PENDING'),
  );
  static const VerificationMeta _arrivedAtMeta = const VerificationMeta(
    'arrivedAt',
  );
  @override
  late final GeneratedColumn<DateTime> arrivedAt = GeneratedColumn<DateTime>(
    'arrived_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _excusedReasonMeta = const VerificationMeta(
    'excusedReason',
  );
  @override
  late final GeneratedColumn<String> excusedReason = GeneratedColumn<String>(
    'excused_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _attendanceScoreImpactMeta =
      const VerificationMeta('attendanceScoreImpact');
  @override
  late final GeneratedColumn<int> attendanceScoreImpact = GeneratedColumn<int>(
    'attendance_score_impact',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _markedByMeta = const VerificationMeta(
    'markedBy',
  );
  @override
  late final GeneratedColumn<String> markedBy = GeneratedColumn<String>(
    'marked_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _markedAtMeta = const VerificationMeta(
    'markedAt',
  );
  @override
  late final GeneratedColumn<DateTime> markedAt = GeneratedColumn<DateTime>(
    'marked_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _preMeetingSubmittedMeta =
      const VerificationMeta('preMeetingSubmitted');
  @override
  late final GeneratedColumn<bool> preMeetingSubmitted = GeneratedColumn<bool>(
    'pre_meeting_submitted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("pre_meeting_submitted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _q1PreviousCommitmentMeta =
      const VerificationMeta('q1PreviousCommitment');
  @override
  late final GeneratedColumn<String> q1PreviousCommitment =
      GeneratedColumn<String>(
        'q1_previous_commitment',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _q1CompletionStatusMeta =
      const VerificationMeta('q1CompletionStatus');
  @override
  late final GeneratedColumn<String> q1CompletionStatus =
      GeneratedColumn<String>(
        'q1_completion_status',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _q2WhatAchievedMeta = const VerificationMeta(
    'q2WhatAchieved',
  );
  @override
  late final GeneratedColumn<String> q2WhatAchieved = GeneratedColumn<String>(
    'q2_what_achieved',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _q3ObstaclesMeta = const VerificationMeta(
    'q3Obstacles',
  );
  @override
  late final GeneratedColumn<String> q3Obstacles = GeneratedColumn<String>(
    'q3_obstacles',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _q4NextCommitmentMeta = const VerificationMeta(
    'q4NextCommitment',
  );
  @override
  late final GeneratedColumn<String> q4NextCommitment = GeneratedColumn<String>(
    'q4_next_commitment',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _formSubmittedAtMeta = const VerificationMeta(
    'formSubmittedAt',
  );
  @override
  late final GeneratedColumn<DateTime> formSubmittedAt =
      GeneratedColumn<DateTime>(
        'form_submitted_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _formSubmissionStatusMeta =
      const VerificationMeta('formSubmissionStatus');
  @override
  late final GeneratedColumn<String> formSubmissionStatus =
      GeneratedColumn<String>(
        'form_submission_status',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _formScoreImpactMeta = const VerificationMeta(
    'formScoreImpact',
  );
  @override
  late final GeneratedColumn<int> formScoreImpact = GeneratedColumn<int>(
    'form_score_impact',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _hostNotesMeta = const VerificationMeta(
    'hostNotes',
  );
  @override
  late final GeneratedColumn<String> hostNotes = GeneratedColumn<String>(
    'host_notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _feedbackTextMeta = const VerificationMeta(
    'feedbackText',
  );
  @override
  late final GeneratedColumn<String> feedbackText = GeneratedColumn<String>(
    'feedback_text',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _feedbackGivenAtMeta = const VerificationMeta(
    'feedbackGivenAt',
  );
  @override
  late final GeneratedColumn<DateTime> feedbackGivenAt =
      GeneratedColumn<DateTime>(
        'feedback_given_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _feedbackUpdatedAtMeta = const VerificationMeta(
    'feedbackUpdatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> feedbackUpdatedAt =
      GeneratedColumn<DateTime>(
        'feedback_updated_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    meetingId,
    userId,
    attendanceStatus,
    arrivedAt,
    excusedReason,
    attendanceScoreImpact,
    markedBy,
    markedAt,
    preMeetingSubmitted,
    q1PreviousCommitment,
    q1CompletionStatus,
    q2WhatAchieved,
    q3Obstacles,
    q4NextCommitment,
    formSubmittedAt,
    formSubmissionStatus,
    formScoreImpact,
    hostNotes,
    feedbackText,
    feedbackGivenAt,
    feedbackUpdatedAt,
    isPendingSync,
    lastSyncAt,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cadence_participants';
  @override
  VerificationContext validateIntegrity(
    Insertable<CadenceParticipant> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('meeting_id')) {
      context.handle(
        _meetingIdMeta,
        meetingId.isAcceptableOrUnknown(data['meeting_id']!, _meetingIdMeta),
      );
    } else if (isInserting) {
      context.missing(_meetingIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('attendance_status')) {
      context.handle(
        _attendanceStatusMeta,
        attendanceStatus.isAcceptableOrUnknown(
          data['attendance_status']!,
          _attendanceStatusMeta,
        ),
      );
    }
    if (data.containsKey('arrived_at')) {
      context.handle(
        _arrivedAtMeta,
        arrivedAt.isAcceptableOrUnknown(data['arrived_at']!, _arrivedAtMeta),
      );
    }
    if (data.containsKey('excused_reason')) {
      context.handle(
        _excusedReasonMeta,
        excusedReason.isAcceptableOrUnknown(
          data['excused_reason']!,
          _excusedReasonMeta,
        ),
      );
    }
    if (data.containsKey('attendance_score_impact')) {
      context.handle(
        _attendanceScoreImpactMeta,
        attendanceScoreImpact.isAcceptableOrUnknown(
          data['attendance_score_impact']!,
          _attendanceScoreImpactMeta,
        ),
      );
    }
    if (data.containsKey('marked_by')) {
      context.handle(
        _markedByMeta,
        markedBy.isAcceptableOrUnknown(data['marked_by']!, _markedByMeta),
      );
    }
    if (data.containsKey('marked_at')) {
      context.handle(
        _markedAtMeta,
        markedAt.isAcceptableOrUnknown(data['marked_at']!, _markedAtMeta),
      );
    }
    if (data.containsKey('pre_meeting_submitted')) {
      context.handle(
        _preMeetingSubmittedMeta,
        preMeetingSubmitted.isAcceptableOrUnknown(
          data['pre_meeting_submitted']!,
          _preMeetingSubmittedMeta,
        ),
      );
    }
    if (data.containsKey('q1_previous_commitment')) {
      context.handle(
        _q1PreviousCommitmentMeta,
        q1PreviousCommitment.isAcceptableOrUnknown(
          data['q1_previous_commitment']!,
          _q1PreviousCommitmentMeta,
        ),
      );
    }
    if (data.containsKey('q1_completion_status')) {
      context.handle(
        _q1CompletionStatusMeta,
        q1CompletionStatus.isAcceptableOrUnknown(
          data['q1_completion_status']!,
          _q1CompletionStatusMeta,
        ),
      );
    }
    if (data.containsKey('q2_what_achieved')) {
      context.handle(
        _q2WhatAchievedMeta,
        q2WhatAchieved.isAcceptableOrUnknown(
          data['q2_what_achieved']!,
          _q2WhatAchievedMeta,
        ),
      );
    }
    if (data.containsKey('q3_obstacles')) {
      context.handle(
        _q3ObstaclesMeta,
        q3Obstacles.isAcceptableOrUnknown(
          data['q3_obstacles']!,
          _q3ObstaclesMeta,
        ),
      );
    }
    if (data.containsKey('q4_next_commitment')) {
      context.handle(
        _q4NextCommitmentMeta,
        q4NextCommitment.isAcceptableOrUnknown(
          data['q4_next_commitment']!,
          _q4NextCommitmentMeta,
        ),
      );
    }
    if (data.containsKey('form_submitted_at')) {
      context.handle(
        _formSubmittedAtMeta,
        formSubmittedAt.isAcceptableOrUnknown(
          data['form_submitted_at']!,
          _formSubmittedAtMeta,
        ),
      );
    }
    if (data.containsKey('form_submission_status')) {
      context.handle(
        _formSubmissionStatusMeta,
        formSubmissionStatus.isAcceptableOrUnknown(
          data['form_submission_status']!,
          _formSubmissionStatusMeta,
        ),
      );
    }
    if (data.containsKey('form_score_impact')) {
      context.handle(
        _formScoreImpactMeta,
        formScoreImpact.isAcceptableOrUnknown(
          data['form_score_impact']!,
          _formScoreImpactMeta,
        ),
      );
    }
    if (data.containsKey('host_notes')) {
      context.handle(
        _hostNotesMeta,
        hostNotes.isAcceptableOrUnknown(data['host_notes']!, _hostNotesMeta),
      );
    }
    if (data.containsKey('feedback_text')) {
      context.handle(
        _feedbackTextMeta,
        feedbackText.isAcceptableOrUnknown(
          data['feedback_text']!,
          _feedbackTextMeta,
        ),
      );
    }
    if (data.containsKey('feedback_given_at')) {
      context.handle(
        _feedbackGivenAtMeta,
        feedbackGivenAt.isAcceptableOrUnknown(
          data['feedback_given_at']!,
          _feedbackGivenAtMeta,
        ),
      );
    }
    if (data.containsKey('feedback_updated_at')) {
      context.handle(
        _feedbackUpdatedAtMeta,
        feedbackUpdatedAt.isAcceptableOrUnknown(
          data['feedback_updated_at']!,
          _feedbackUpdatedAtMeta,
        ),
      );
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CadenceParticipant map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CadenceParticipant(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      meetingId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}meeting_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      attendanceStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}attendance_status'],
      )!,
      arrivedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}arrived_at'],
      ),
      excusedReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}excused_reason'],
      ),
      attendanceScoreImpact: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}attendance_score_impact'],
      ),
      markedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}marked_by'],
      ),
      markedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}marked_at'],
      ),
      preMeetingSubmitted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}pre_meeting_submitted'],
      )!,
      q1PreviousCommitment: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}q1_previous_commitment'],
      ),
      q1CompletionStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}q1_completion_status'],
      ),
      q2WhatAchieved: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}q2_what_achieved'],
      ),
      q3Obstacles: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}q3_obstacles'],
      ),
      q4NextCommitment: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}q4_next_commitment'],
      ),
      formSubmittedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}form_submitted_at'],
      ),
      formSubmissionStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}form_submission_status'],
      ),
      formScoreImpact: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}form_score_impact'],
      ),
      hostNotes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}host_notes'],
      ),
      feedbackText: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}feedback_text'],
      ),
      feedbackGivenAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}feedback_given_at'],
      ),
      feedbackUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}feedback_updated_at'],
      ),
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CadenceParticipantsTable createAlias(String alias) {
    return $CadenceParticipantsTable(attachedDatabase, alias);
  }
}

class CadenceParticipant extends DataClass
    implements Insertable<CadenceParticipant> {
  final String id;
  final String meetingId;
  final String userId;

  /// Status: PENDING, PRESENT, LATE, EXCUSED, ABSENT
  final String attendanceStatus;
  final DateTime? arrivedAt;
  final String? excusedReason;
  final int? attendanceScoreImpact;
  final String? markedBy;
  final DateTime? markedAt;
  final bool preMeetingSubmitted;

  /// Q1: Previous commitment (auto-filled from last meeting's Q4)
  final String? q1PreviousCommitment;

  /// Q1: Status of previous commitment
  final String? q1CompletionStatus;

  /// Q2: What was achieved this period (required)
  final String? q2WhatAchieved;

  /// Q3: Obstacles/blockers faced (optional)
  final String? q3Obstacles;

  /// Q4: Commitment for next period (required)
  final String? q4NextCommitment;
  final DateTime? formSubmittedAt;

  /// Status: ON_TIME, LATE, VERY_LATE, NOT_SUBMITTED
  final String? formSubmissionStatus;
  final int? formScoreImpact;

  /// Internal notes by host (not visible to participant)
  final String? hostNotes;

  /// Formal feedback visible to participant
  final String? feedbackText;
  final DateTime? feedbackGivenAt;
  final DateTime? feedbackUpdatedAt;
  final bool isPendingSync;
  final DateTime? lastSyncAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const CadenceParticipant({
    required this.id,
    required this.meetingId,
    required this.userId,
    required this.attendanceStatus,
    this.arrivedAt,
    this.excusedReason,
    this.attendanceScoreImpact,
    this.markedBy,
    this.markedAt,
    required this.preMeetingSubmitted,
    this.q1PreviousCommitment,
    this.q1CompletionStatus,
    this.q2WhatAchieved,
    this.q3Obstacles,
    this.q4NextCommitment,
    this.formSubmittedAt,
    this.formSubmissionStatus,
    this.formScoreImpact,
    this.hostNotes,
    this.feedbackText,
    this.feedbackGivenAt,
    this.feedbackUpdatedAt,
    required this.isPendingSync,
    this.lastSyncAt,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['meeting_id'] = Variable<String>(meetingId);
    map['user_id'] = Variable<String>(userId);
    map['attendance_status'] = Variable<String>(attendanceStatus);
    if (!nullToAbsent || arrivedAt != null) {
      map['arrived_at'] = Variable<DateTime>(arrivedAt);
    }
    if (!nullToAbsent || excusedReason != null) {
      map['excused_reason'] = Variable<String>(excusedReason);
    }
    if (!nullToAbsent || attendanceScoreImpact != null) {
      map['attendance_score_impact'] = Variable<int>(attendanceScoreImpact);
    }
    if (!nullToAbsent || markedBy != null) {
      map['marked_by'] = Variable<String>(markedBy);
    }
    if (!nullToAbsent || markedAt != null) {
      map['marked_at'] = Variable<DateTime>(markedAt);
    }
    map['pre_meeting_submitted'] = Variable<bool>(preMeetingSubmitted);
    if (!nullToAbsent || q1PreviousCommitment != null) {
      map['q1_previous_commitment'] = Variable<String>(q1PreviousCommitment);
    }
    if (!nullToAbsent || q1CompletionStatus != null) {
      map['q1_completion_status'] = Variable<String>(q1CompletionStatus);
    }
    if (!nullToAbsent || q2WhatAchieved != null) {
      map['q2_what_achieved'] = Variable<String>(q2WhatAchieved);
    }
    if (!nullToAbsent || q3Obstacles != null) {
      map['q3_obstacles'] = Variable<String>(q3Obstacles);
    }
    if (!nullToAbsent || q4NextCommitment != null) {
      map['q4_next_commitment'] = Variable<String>(q4NextCommitment);
    }
    if (!nullToAbsent || formSubmittedAt != null) {
      map['form_submitted_at'] = Variable<DateTime>(formSubmittedAt);
    }
    if (!nullToAbsent || formSubmissionStatus != null) {
      map['form_submission_status'] = Variable<String>(formSubmissionStatus);
    }
    if (!nullToAbsent || formScoreImpact != null) {
      map['form_score_impact'] = Variable<int>(formScoreImpact);
    }
    if (!nullToAbsent || hostNotes != null) {
      map['host_notes'] = Variable<String>(hostNotes);
    }
    if (!nullToAbsent || feedbackText != null) {
      map['feedback_text'] = Variable<String>(feedbackText);
    }
    if (!nullToAbsent || feedbackGivenAt != null) {
      map['feedback_given_at'] = Variable<DateTime>(feedbackGivenAt);
    }
    if (!nullToAbsent || feedbackUpdatedAt != null) {
      map['feedback_updated_at'] = Variable<DateTime>(feedbackUpdatedAt);
    }
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  CadenceParticipantsCompanion toCompanion(bool nullToAbsent) {
    return CadenceParticipantsCompanion(
      id: Value(id),
      meetingId: Value(meetingId),
      userId: Value(userId),
      attendanceStatus: Value(attendanceStatus),
      arrivedAt: arrivedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(arrivedAt),
      excusedReason: excusedReason == null && nullToAbsent
          ? const Value.absent()
          : Value(excusedReason),
      attendanceScoreImpact: attendanceScoreImpact == null && nullToAbsent
          ? const Value.absent()
          : Value(attendanceScoreImpact),
      markedBy: markedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(markedBy),
      markedAt: markedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(markedAt),
      preMeetingSubmitted: Value(preMeetingSubmitted),
      q1PreviousCommitment: q1PreviousCommitment == null && nullToAbsent
          ? const Value.absent()
          : Value(q1PreviousCommitment),
      q1CompletionStatus: q1CompletionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(q1CompletionStatus),
      q2WhatAchieved: q2WhatAchieved == null && nullToAbsent
          ? const Value.absent()
          : Value(q2WhatAchieved),
      q3Obstacles: q3Obstacles == null && nullToAbsent
          ? const Value.absent()
          : Value(q3Obstacles),
      q4NextCommitment: q4NextCommitment == null && nullToAbsent
          ? const Value.absent()
          : Value(q4NextCommitment),
      formSubmittedAt: formSubmittedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(formSubmittedAt),
      formSubmissionStatus: formSubmissionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(formSubmissionStatus),
      formScoreImpact: formScoreImpact == null && nullToAbsent
          ? const Value.absent()
          : Value(formScoreImpact),
      hostNotes: hostNotes == null && nullToAbsent
          ? const Value.absent()
          : Value(hostNotes),
      feedbackText: feedbackText == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackText),
      feedbackGivenAt: feedbackGivenAt == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackGivenAt),
      feedbackUpdatedAt: feedbackUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(feedbackUpdatedAt),
      isPendingSync: Value(isPendingSync),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory CadenceParticipant.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CadenceParticipant(
      id: serializer.fromJson<String>(json['id']),
      meetingId: serializer.fromJson<String>(json['meetingId']),
      userId: serializer.fromJson<String>(json['userId']),
      attendanceStatus: serializer.fromJson<String>(json['attendanceStatus']),
      arrivedAt: serializer.fromJson<DateTime?>(json['arrivedAt']),
      excusedReason: serializer.fromJson<String?>(json['excusedReason']),
      attendanceScoreImpact: serializer.fromJson<int?>(
        json['attendanceScoreImpact'],
      ),
      markedBy: serializer.fromJson<String?>(json['markedBy']),
      markedAt: serializer.fromJson<DateTime?>(json['markedAt']),
      preMeetingSubmitted: serializer.fromJson<bool>(
        json['preMeetingSubmitted'],
      ),
      q1PreviousCommitment: serializer.fromJson<String?>(
        json['q1PreviousCommitment'],
      ),
      q1CompletionStatus: serializer.fromJson<String?>(
        json['q1CompletionStatus'],
      ),
      q2WhatAchieved: serializer.fromJson<String?>(json['q2WhatAchieved']),
      q3Obstacles: serializer.fromJson<String?>(json['q3Obstacles']),
      q4NextCommitment: serializer.fromJson<String?>(json['q4NextCommitment']),
      formSubmittedAt: serializer.fromJson<DateTime?>(json['formSubmittedAt']),
      formSubmissionStatus: serializer.fromJson<String?>(
        json['formSubmissionStatus'],
      ),
      formScoreImpact: serializer.fromJson<int?>(json['formScoreImpact']),
      hostNotes: serializer.fromJson<String?>(json['hostNotes']),
      feedbackText: serializer.fromJson<String?>(json['feedbackText']),
      feedbackGivenAt: serializer.fromJson<DateTime?>(json['feedbackGivenAt']),
      feedbackUpdatedAt: serializer.fromJson<DateTime?>(
        json['feedbackUpdatedAt'],
      ),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'meetingId': serializer.toJson<String>(meetingId),
      'userId': serializer.toJson<String>(userId),
      'attendanceStatus': serializer.toJson<String>(attendanceStatus),
      'arrivedAt': serializer.toJson<DateTime?>(arrivedAt),
      'excusedReason': serializer.toJson<String?>(excusedReason),
      'attendanceScoreImpact': serializer.toJson<int?>(attendanceScoreImpact),
      'markedBy': serializer.toJson<String?>(markedBy),
      'markedAt': serializer.toJson<DateTime?>(markedAt),
      'preMeetingSubmitted': serializer.toJson<bool>(preMeetingSubmitted),
      'q1PreviousCommitment': serializer.toJson<String?>(q1PreviousCommitment),
      'q1CompletionStatus': serializer.toJson<String?>(q1CompletionStatus),
      'q2WhatAchieved': serializer.toJson<String?>(q2WhatAchieved),
      'q3Obstacles': serializer.toJson<String?>(q3Obstacles),
      'q4NextCommitment': serializer.toJson<String?>(q4NextCommitment),
      'formSubmittedAt': serializer.toJson<DateTime?>(formSubmittedAt),
      'formSubmissionStatus': serializer.toJson<String?>(formSubmissionStatus),
      'formScoreImpact': serializer.toJson<int?>(formScoreImpact),
      'hostNotes': serializer.toJson<String?>(hostNotes),
      'feedbackText': serializer.toJson<String?>(feedbackText),
      'feedbackGivenAt': serializer.toJson<DateTime?>(feedbackGivenAt),
      'feedbackUpdatedAt': serializer.toJson<DateTime?>(feedbackUpdatedAt),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  CadenceParticipant copyWith({
    String? id,
    String? meetingId,
    String? userId,
    String? attendanceStatus,
    Value<DateTime?> arrivedAt = const Value.absent(),
    Value<String?> excusedReason = const Value.absent(),
    Value<int?> attendanceScoreImpact = const Value.absent(),
    Value<String?> markedBy = const Value.absent(),
    Value<DateTime?> markedAt = const Value.absent(),
    bool? preMeetingSubmitted,
    Value<String?> q1PreviousCommitment = const Value.absent(),
    Value<String?> q1CompletionStatus = const Value.absent(),
    Value<String?> q2WhatAchieved = const Value.absent(),
    Value<String?> q3Obstacles = const Value.absent(),
    Value<String?> q4NextCommitment = const Value.absent(),
    Value<DateTime?> formSubmittedAt = const Value.absent(),
    Value<String?> formSubmissionStatus = const Value.absent(),
    Value<int?> formScoreImpact = const Value.absent(),
    Value<String?> hostNotes = const Value.absent(),
    Value<String?> feedbackText = const Value.absent(),
    Value<DateTime?> feedbackGivenAt = const Value.absent(),
    Value<DateTime?> feedbackUpdatedAt = const Value.absent(),
    bool? isPendingSync,
    Value<DateTime?> lastSyncAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => CadenceParticipant(
    id: id ?? this.id,
    meetingId: meetingId ?? this.meetingId,
    userId: userId ?? this.userId,
    attendanceStatus: attendanceStatus ?? this.attendanceStatus,
    arrivedAt: arrivedAt.present ? arrivedAt.value : this.arrivedAt,
    excusedReason: excusedReason.present
        ? excusedReason.value
        : this.excusedReason,
    attendanceScoreImpact: attendanceScoreImpact.present
        ? attendanceScoreImpact.value
        : this.attendanceScoreImpact,
    markedBy: markedBy.present ? markedBy.value : this.markedBy,
    markedAt: markedAt.present ? markedAt.value : this.markedAt,
    preMeetingSubmitted: preMeetingSubmitted ?? this.preMeetingSubmitted,
    q1PreviousCommitment: q1PreviousCommitment.present
        ? q1PreviousCommitment.value
        : this.q1PreviousCommitment,
    q1CompletionStatus: q1CompletionStatus.present
        ? q1CompletionStatus.value
        : this.q1CompletionStatus,
    q2WhatAchieved: q2WhatAchieved.present
        ? q2WhatAchieved.value
        : this.q2WhatAchieved,
    q3Obstacles: q3Obstacles.present ? q3Obstacles.value : this.q3Obstacles,
    q4NextCommitment: q4NextCommitment.present
        ? q4NextCommitment.value
        : this.q4NextCommitment,
    formSubmittedAt: formSubmittedAt.present
        ? formSubmittedAt.value
        : this.formSubmittedAt,
    formSubmissionStatus: formSubmissionStatus.present
        ? formSubmissionStatus.value
        : this.formSubmissionStatus,
    formScoreImpact: formScoreImpact.present
        ? formScoreImpact.value
        : this.formScoreImpact,
    hostNotes: hostNotes.present ? hostNotes.value : this.hostNotes,
    feedbackText: feedbackText.present ? feedbackText.value : this.feedbackText,
    feedbackGivenAt: feedbackGivenAt.present
        ? feedbackGivenAt.value
        : this.feedbackGivenAt,
    feedbackUpdatedAt: feedbackUpdatedAt.present
        ? feedbackUpdatedAt.value
        : this.feedbackUpdatedAt,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  CadenceParticipant copyWithCompanion(CadenceParticipantsCompanion data) {
    return CadenceParticipant(
      id: data.id.present ? data.id.value : this.id,
      meetingId: data.meetingId.present ? data.meetingId.value : this.meetingId,
      userId: data.userId.present ? data.userId.value : this.userId,
      attendanceStatus: data.attendanceStatus.present
          ? data.attendanceStatus.value
          : this.attendanceStatus,
      arrivedAt: data.arrivedAt.present ? data.arrivedAt.value : this.arrivedAt,
      excusedReason: data.excusedReason.present
          ? data.excusedReason.value
          : this.excusedReason,
      attendanceScoreImpact: data.attendanceScoreImpact.present
          ? data.attendanceScoreImpact.value
          : this.attendanceScoreImpact,
      markedBy: data.markedBy.present ? data.markedBy.value : this.markedBy,
      markedAt: data.markedAt.present ? data.markedAt.value : this.markedAt,
      preMeetingSubmitted: data.preMeetingSubmitted.present
          ? data.preMeetingSubmitted.value
          : this.preMeetingSubmitted,
      q1PreviousCommitment: data.q1PreviousCommitment.present
          ? data.q1PreviousCommitment.value
          : this.q1PreviousCommitment,
      q1CompletionStatus: data.q1CompletionStatus.present
          ? data.q1CompletionStatus.value
          : this.q1CompletionStatus,
      q2WhatAchieved: data.q2WhatAchieved.present
          ? data.q2WhatAchieved.value
          : this.q2WhatAchieved,
      q3Obstacles: data.q3Obstacles.present
          ? data.q3Obstacles.value
          : this.q3Obstacles,
      q4NextCommitment: data.q4NextCommitment.present
          ? data.q4NextCommitment.value
          : this.q4NextCommitment,
      formSubmittedAt: data.formSubmittedAt.present
          ? data.formSubmittedAt.value
          : this.formSubmittedAt,
      formSubmissionStatus: data.formSubmissionStatus.present
          ? data.formSubmissionStatus.value
          : this.formSubmissionStatus,
      formScoreImpact: data.formScoreImpact.present
          ? data.formScoreImpact.value
          : this.formScoreImpact,
      hostNotes: data.hostNotes.present ? data.hostNotes.value : this.hostNotes,
      feedbackText: data.feedbackText.present
          ? data.feedbackText.value
          : this.feedbackText,
      feedbackGivenAt: data.feedbackGivenAt.present
          ? data.feedbackGivenAt.value
          : this.feedbackGivenAt,
      feedbackUpdatedAt: data.feedbackUpdatedAt.present
          ? data.feedbackUpdatedAt.value
          : this.feedbackUpdatedAt,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CadenceParticipant(')
          ..write('id: $id, ')
          ..write('meetingId: $meetingId, ')
          ..write('userId: $userId, ')
          ..write('attendanceStatus: $attendanceStatus, ')
          ..write('arrivedAt: $arrivedAt, ')
          ..write('excusedReason: $excusedReason, ')
          ..write('attendanceScoreImpact: $attendanceScoreImpact, ')
          ..write('markedBy: $markedBy, ')
          ..write('markedAt: $markedAt, ')
          ..write('preMeetingSubmitted: $preMeetingSubmitted, ')
          ..write('q1PreviousCommitment: $q1PreviousCommitment, ')
          ..write('q1CompletionStatus: $q1CompletionStatus, ')
          ..write('q2WhatAchieved: $q2WhatAchieved, ')
          ..write('q3Obstacles: $q3Obstacles, ')
          ..write('q4NextCommitment: $q4NextCommitment, ')
          ..write('formSubmittedAt: $formSubmittedAt, ')
          ..write('formSubmissionStatus: $formSubmissionStatus, ')
          ..write('formScoreImpact: $formScoreImpact, ')
          ..write('hostNotes: $hostNotes, ')
          ..write('feedbackText: $feedbackText, ')
          ..write('feedbackGivenAt: $feedbackGivenAt, ')
          ..write('feedbackUpdatedAt: $feedbackUpdatedAt, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    meetingId,
    userId,
    attendanceStatus,
    arrivedAt,
    excusedReason,
    attendanceScoreImpact,
    markedBy,
    markedAt,
    preMeetingSubmitted,
    q1PreviousCommitment,
    q1CompletionStatus,
    q2WhatAchieved,
    q3Obstacles,
    q4NextCommitment,
    formSubmittedAt,
    formSubmissionStatus,
    formScoreImpact,
    hostNotes,
    feedbackText,
    feedbackGivenAt,
    feedbackUpdatedAt,
    isPendingSync,
    lastSyncAt,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CadenceParticipant &&
          other.id == this.id &&
          other.meetingId == this.meetingId &&
          other.userId == this.userId &&
          other.attendanceStatus == this.attendanceStatus &&
          other.arrivedAt == this.arrivedAt &&
          other.excusedReason == this.excusedReason &&
          other.attendanceScoreImpact == this.attendanceScoreImpact &&
          other.markedBy == this.markedBy &&
          other.markedAt == this.markedAt &&
          other.preMeetingSubmitted == this.preMeetingSubmitted &&
          other.q1PreviousCommitment == this.q1PreviousCommitment &&
          other.q1CompletionStatus == this.q1CompletionStatus &&
          other.q2WhatAchieved == this.q2WhatAchieved &&
          other.q3Obstacles == this.q3Obstacles &&
          other.q4NextCommitment == this.q4NextCommitment &&
          other.formSubmittedAt == this.formSubmittedAt &&
          other.formSubmissionStatus == this.formSubmissionStatus &&
          other.formScoreImpact == this.formScoreImpact &&
          other.hostNotes == this.hostNotes &&
          other.feedbackText == this.feedbackText &&
          other.feedbackGivenAt == this.feedbackGivenAt &&
          other.feedbackUpdatedAt == this.feedbackUpdatedAt &&
          other.isPendingSync == this.isPendingSync &&
          other.lastSyncAt == this.lastSyncAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CadenceParticipantsCompanion extends UpdateCompanion<CadenceParticipant> {
  final Value<String> id;
  final Value<String> meetingId;
  final Value<String> userId;
  final Value<String> attendanceStatus;
  final Value<DateTime?> arrivedAt;
  final Value<String?> excusedReason;
  final Value<int?> attendanceScoreImpact;
  final Value<String?> markedBy;
  final Value<DateTime?> markedAt;
  final Value<bool> preMeetingSubmitted;
  final Value<String?> q1PreviousCommitment;
  final Value<String?> q1CompletionStatus;
  final Value<String?> q2WhatAchieved;
  final Value<String?> q3Obstacles;
  final Value<String?> q4NextCommitment;
  final Value<DateTime?> formSubmittedAt;
  final Value<String?> formSubmissionStatus;
  final Value<int?> formScoreImpact;
  final Value<String?> hostNotes;
  final Value<String?> feedbackText;
  final Value<DateTime?> feedbackGivenAt;
  final Value<DateTime?> feedbackUpdatedAt;
  final Value<bool> isPendingSync;
  final Value<DateTime?> lastSyncAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const CadenceParticipantsCompanion({
    this.id = const Value.absent(),
    this.meetingId = const Value.absent(),
    this.userId = const Value.absent(),
    this.attendanceStatus = const Value.absent(),
    this.arrivedAt = const Value.absent(),
    this.excusedReason = const Value.absent(),
    this.attendanceScoreImpact = const Value.absent(),
    this.markedBy = const Value.absent(),
    this.markedAt = const Value.absent(),
    this.preMeetingSubmitted = const Value.absent(),
    this.q1PreviousCommitment = const Value.absent(),
    this.q1CompletionStatus = const Value.absent(),
    this.q2WhatAchieved = const Value.absent(),
    this.q3Obstacles = const Value.absent(),
    this.q4NextCommitment = const Value.absent(),
    this.formSubmittedAt = const Value.absent(),
    this.formSubmissionStatus = const Value.absent(),
    this.formScoreImpact = const Value.absent(),
    this.hostNotes = const Value.absent(),
    this.feedbackText = const Value.absent(),
    this.feedbackGivenAt = const Value.absent(),
    this.feedbackUpdatedAt = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CadenceParticipantsCompanion.insert({
    required String id,
    required String meetingId,
    required String userId,
    this.attendanceStatus = const Value.absent(),
    this.arrivedAt = const Value.absent(),
    this.excusedReason = const Value.absent(),
    this.attendanceScoreImpact = const Value.absent(),
    this.markedBy = const Value.absent(),
    this.markedAt = const Value.absent(),
    this.preMeetingSubmitted = const Value.absent(),
    this.q1PreviousCommitment = const Value.absent(),
    this.q1CompletionStatus = const Value.absent(),
    this.q2WhatAchieved = const Value.absent(),
    this.q3Obstacles = const Value.absent(),
    this.q4NextCommitment = const Value.absent(),
    this.formSubmittedAt = const Value.absent(),
    this.formSubmissionStatus = const Value.absent(),
    this.formScoreImpact = const Value.absent(),
    this.hostNotes = const Value.absent(),
    this.feedbackText = const Value.absent(),
    this.feedbackGivenAt = const Value.absent(),
    this.feedbackUpdatedAt = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       meetingId = Value(meetingId),
       userId = Value(userId),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<CadenceParticipant> custom({
    Expression<String>? id,
    Expression<String>? meetingId,
    Expression<String>? userId,
    Expression<String>? attendanceStatus,
    Expression<DateTime>? arrivedAt,
    Expression<String>? excusedReason,
    Expression<int>? attendanceScoreImpact,
    Expression<String>? markedBy,
    Expression<DateTime>? markedAt,
    Expression<bool>? preMeetingSubmitted,
    Expression<String>? q1PreviousCommitment,
    Expression<String>? q1CompletionStatus,
    Expression<String>? q2WhatAchieved,
    Expression<String>? q3Obstacles,
    Expression<String>? q4NextCommitment,
    Expression<DateTime>? formSubmittedAt,
    Expression<String>? formSubmissionStatus,
    Expression<int>? formScoreImpact,
    Expression<String>? hostNotes,
    Expression<String>? feedbackText,
    Expression<DateTime>? feedbackGivenAt,
    Expression<DateTime>? feedbackUpdatedAt,
    Expression<bool>? isPendingSync,
    Expression<DateTime>? lastSyncAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (meetingId != null) 'meeting_id': meetingId,
      if (userId != null) 'user_id': userId,
      if (attendanceStatus != null) 'attendance_status': attendanceStatus,
      if (arrivedAt != null) 'arrived_at': arrivedAt,
      if (excusedReason != null) 'excused_reason': excusedReason,
      if (attendanceScoreImpact != null)
        'attendance_score_impact': attendanceScoreImpact,
      if (markedBy != null) 'marked_by': markedBy,
      if (markedAt != null) 'marked_at': markedAt,
      if (preMeetingSubmitted != null)
        'pre_meeting_submitted': preMeetingSubmitted,
      if (q1PreviousCommitment != null)
        'q1_previous_commitment': q1PreviousCommitment,
      if (q1CompletionStatus != null)
        'q1_completion_status': q1CompletionStatus,
      if (q2WhatAchieved != null) 'q2_what_achieved': q2WhatAchieved,
      if (q3Obstacles != null) 'q3_obstacles': q3Obstacles,
      if (q4NextCommitment != null) 'q4_next_commitment': q4NextCommitment,
      if (formSubmittedAt != null) 'form_submitted_at': formSubmittedAt,
      if (formSubmissionStatus != null)
        'form_submission_status': formSubmissionStatus,
      if (formScoreImpact != null) 'form_score_impact': formScoreImpact,
      if (hostNotes != null) 'host_notes': hostNotes,
      if (feedbackText != null) 'feedback_text': feedbackText,
      if (feedbackGivenAt != null) 'feedback_given_at': feedbackGivenAt,
      if (feedbackUpdatedAt != null) 'feedback_updated_at': feedbackUpdatedAt,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CadenceParticipantsCompanion copyWith({
    Value<String>? id,
    Value<String>? meetingId,
    Value<String>? userId,
    Value<String>? attendanceStatus,
    Value<DateTime?>? arrivedAt,
    Value<String?>? excusedReason,
    Value<int?>? attendanceScoreImpact,
    Value<String?>? markedBy,
    Value<DateTime?>? markedAt,
    Value<bool>? preMeetingSubmitted,
    Value<String?>? q1PreviousCommitment,
    Value<String?>? q1CompletionStatus,
    Value<String?>? q2WhatAchieved,
    Value<String?>? q3Obstacles,
    Value<String?>? q4NextCommitment,
    Value<DateTime?>? formSubmittedAt,
    Value<String?>? formSubmissionStatus,
    Value<int?>? formScoreImpact,
    Value<String?>? hostNotes,
    Value<String?>? feedbackText,
    Value<DateTime?>? feedbackGivenAt,
    Value<DateTime?>? feedbackUpdatedAt,
    Value<bool>? isPendingSync,
    Value<DateTime?>? lastSyncAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return CadenceParticipantsCompanion(
      id: id ?? this.id,
      meetingId: meetingId ?? this.meetingId,
      userId: userId ?? this.userId,
      attendanceStatus: attendanceStatus ?? this.attendanceStatus,
      arrivedAt: arrivedAt ?? this.arrivedAt,
      excusedReason: excusedReason ?? this.excusedReason,
      attendanceScoreImpact:
          attendanceScoreImpact ?? this.attendanceScoreImpact,
      markedBy: markedBy ?? this.markedBy,
      markedAt: markedAt ?? this.markedAt,
      preMeetingSubmitted: preMeetingSubmitted ?? this.preMeetingSubmitted,
      q1PreviousCommitment: q1PreviousCommitment ?? this.q1PreviousCommitment,
      q1CompletionStatus: q1CompletionStatus ?? this.q1CompletionStatus,
      q2WhatAchieved: q2WhatAchieved ?? this.q2WhatAchieved,
      q3Obstacles: q3Obstacles ?? this.q3Obstacles,
      q4NextCommitment: q4NextCommitment ?? this.q4NextCommitment,
      formSubmittedAt: formSubmittedAt ?? this.formSubmittedAt,
      formSubmissionStatus: formSubmissionStatus ?? this.formSubmissionStatus,
      formScoreImpact: formScoreImpact ?? this.formScoreImpact,
      hostNotes: hostNotes ?? this.hostNotes,
      feedbackText: feedbackText ?? this.feedbackText,
      feedbackGivenAt: feedbackGivenAt ?? this.feedbackGivenAt,
      feedbackUpdatedAt: feedbackUpdatedAt ?? this.feedbackUpdatedAt,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (meetingId.present) {
      map['meeting_id'] = Variable<String>(meetingId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (attendanceStatus.present) {
      map['attendance_status'] = Variable<String>(attendanceStatus.value);
    }
    if (arrivedAt.present) {
      map['arrived_at'] = Variable<DateTime>(arrivedAt.value);
    }
    if (excusedReason.present) {
      map['excused_reason'] = Variable<String>(excusedReason.value);
    }
    if (attendanceScoreImpact.present) {
      map['attendance_score_impact'] = Variable<int>(
        attendanceScoreImpact.value,
      );
    }
    if (markedBy.present) {
      map['marked_by'] = Variable<String>(markedBy.value);
    }
    if (markedAt.present) {
      map['marked_at'] = Variable<DateTime>(markedAt.value);
    }
    if (preMeetingSubmitted.present) {
      map['pre_meeting_submitted'] = Variable<bool>(preMeetingSubmitted.value);
    }
    if (q1PreviousCommitment.present) {
      map['q1_previous_commitment'] = Variable<String>(
        q1PreviousCommitment.value,
      );
    }
    if (q1CompletionStatus.present) {
      map['q1_completion_status'] = Variable<String>(q1CompletionStatus.value);
    }
    if (q2WhatAchieved.present) {
      map['q2_what_achieved'] = Variable<String>(q2WhatAchieved.value);
    }
    if (q3Obstacles.present) {
      map['q3_obstacles'] = Variable<String>(q3Obstacles.value);
    }
    if (q4NextCommitment.present) {
      map['q4_next_commitment'] = Variable<String>(q4NextCommitment.value);
    }
    if (formSubmittedAt.present) {
      map['form_submitted_at'] = Variable<DateTime>(formSubmittedAt.value);
    }
    if (formSubmissionStatus.present) {
      map['form_submission_status'] = Variable<String>(
        formSubmissionStatus.value,
      );
    }
    if (formScoreImpact.present) {
      map['form_score_impact'] = Variable<int>(formScoreImpact.value);
    }
    if (hostNotes.present) {
      map['host_notes'] = Variable<String>(hostNotes.value);
    }
    if (feedbackText.present) {
      map['feedback_text'] = Variable<String>(feedbackText.value);
    }
    if (feedbackGivenAt.present) {
      map['feedback_given_at'] = Variable<DateTime>(feedbackGivenAt.value);
    }
    if (feedbackUpdatedAt.present) {
      map['feedback_updated_at'] = Variable<DateTime>(feedbackUpdatedAt.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CadenceParticipantsCompanion(')
          ..write('id: $id, ')
          ..write('meetingId: $meetingId, ')
          ..write('userId: $userId, ')
          ..write('attendanceStatus: $attendanceStatus, ')
          ..write('arrivedAt: $arrivedAt, ')
          ..write('excusedReason: $excusedReason, ')
          ..write('attendanceScoreImpact: $attendanceScoreImpact, ')
          ..write('markedBy: $markedBy, ')
          ..write('markedAt: $markedAt, ')
          ..write('preMeetingSubmitted: $preMeetingSubmitted, ')
          ..write('q1PreviousCommitment: $q1PreviousCommitment, ')
          ..write('q1CompletionStatus: $q1CompletionStatus, ')
          ..write('q2WhatAchieved: $q2WhatAchieved, ')
          ..write('q3Obstacles: $q3Obstacles, ')
          ..write('q4NextCommitment: $q4NextCommitment, ')
          ..write('formSubmittedAt: $formSubmittedAt, ')
          ..write('formSubmissionStatus: $formSubmissionStatus, ')
          ..write('formScoreImpact: $formScoreImpact, ')
          ..write('hostNotes: $hostNotes, ')
          ..write('feedbackText: $feedbackText, ')
          ..write('feedbackGivenAt: $feedbackGivenAt, ')
          ..write('feedbackUpdatedAt: $feedbackUpdatedAt, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NotificationsTable extends Notifications
    with TableInfo<$NotificationsTable, Notification> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NotificationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bodyMeta = const VerificationMeta('body');
  @override
  late final GeneratedColumn<String> body = GeneratedColumn<String>(
    'body',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dataMeta = const VerificationMeta('data');
  @override
  late final GeneratedColumn<String> data = GeneratedColumn<String>(
    'data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _actionTypeMeta = const VerificationMeta(
    'actionType',
  );
  @override
  late final GeneratedColumn<String> actionType = GeneratedColumn<String>(
    'action_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _actionTargetMeta = const VerificationMeta(
    'actionTarget',
  );
  @override
  late final GeneratedColumn<String> actionTarget = GeneratedColumn<String>(
    'action_target',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isReadMeta = const VerificationMeta('isRead');
  @override
  late final GeneratedColumn<bool> isRead = GeneratedColumn<bool>(
    'is_read',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_read" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _readAtMeta = const VerificationMeta('readAt');
  @override
  late final GeneratedColumn<DateTime> readAt = GeneratedColumn<DateTime>(
    'read_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    type,
    title,
    body,
    data,
    actionType,
    actionTarget,
    isRead,
    readAt,
    expiresAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'notifications';
  @override
  VerificationContext validateIntegrity(
    Insertable<Notification> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('body')) {
      context.handle(
        _bodyMeta,
        body.isAcceptableOrUnknown(data['body']!, _bodyMeta),
      );
    } else if (isInserting) {
      context.missing(_bodyMeta);
    }
    if (data.containsKey('data')) {
      context.handle(
        _dataMeta,
        this.data.isAcceptableOrUnknown(data['data']!, _dataMeta),
      );
    }
    if (data.containsKey('action_type')) {
      context.handle(
        _actionTypeMeta,
        actionType.isAcceptableOrUnknown(data['action_type']!, _actionTypeMeta),
      );
    }
    if (data.containsKey('action_target')) {
      context.handle(
        _actionTargetMeta,
        actionTarget.isAcceptableOrUnknown(
          data['action_target']!,
          _actionTargetMeta,
        ),
      );
    }
    if (data.containsKey('is_read')) {
      context.handle(
        _isReadMeta,
        isRead.isAcceptableOrUnknown(data['is_read']!, _isReadMeta),
      );
    }
    if (data.containsKey('read_at')) {
      context.handle(
        _readAtMeta,
        readAt.isAcceptableOrUnknown(data['read_at']!, _readAtMeta),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Notification map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Notification(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      body: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}body'],
      )!,
      data: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}data'],
      ),
      actionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action_type'],
      ),
      actionTarget: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action_target'],
      ),
      isRead: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_read'],
      )!,
      readAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}read_at'],
      ),
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $NotificationsTable createAlias(String alias) {
    return $NotificationsTable(attachedDatabase, alias);
  }
}

class Notification extends DataClass implements Insertable<Notification> {
  final String id;
  final String userId;
  final String type;
  final String title;
  final String body;
  final String? data;
  final String? actionType;
  final String? actionTarget;
  final bool isRead;
  final DateTime? readAt;
  final DateTime? expiresAt;
  final DateTime createdAt;
  const Notification({
    required this.id,
    required this.userId,
    required this.type,
    required this.title,
    required this.body,
    this.data,
    this.actionType,
    this.actionTarget,
    required this.isRead,
    this.readAt,
    this.expiresAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['type'] = Variable<String>(type);
    map['title'] = Variable<String>(title);
    map['body'] = Variable<String>(body);
    if (!nullToAbsent || data != null) {
      map['data'] = Variable<String>(data);
    }
    if (!nullToAbsent || actionType != null) {
      map['action_type'] = Variable<String>(actionType);
    }
    if (!nullToAbsent || actionTarget != null) {
      map['action_target'] = Variable<String>(actionTarget);
    }
    map['is_read'] = Variable<bool>(isRead);
    if (!nullToAbsent || readAt != null) {
      map['read_at'] = Variable<DateTime>(readAt);
    }
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  NotificationsCompanion toCompanion(bool nullToAbsent) {
    return NotificationsCompanion(
      id: Value(id),
      userId: Value(userId),
      type: Value(type),
      title: Value(title),
      body: Value(body),
      data: data == null && nullToAbsent ? const Value.absent() : Value(data),
      actionType: actionType == null && nullToAbsent
          ? const Value.absent()
          : Value(actionType),
      actionTarget: actionTarget == null && nullToAbsent
          ? const Value.absent()
          : Value(actionTarget),
      isRead: Value(isRead),
      readAt: readAt == null && nullToAbsent
          ? const Value.absent()
          : Value(readAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      createdAt: Value(createdAt),
    );
  }

  factory Notification.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Notification(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      type: serializer.fromJson<String>(json['type']),
      title: serializer.fromJson<String>(json['title']),
      body: serializer.fromJson<String>(json['body']),
      data: serializer.fromJson<String?>(json['data']),
      actionType: serializer.fromJson<String?>(json['actionType']),
      actionTarget: serializer.fromJson<String?>(json['actionTarget']),
      isRead: serializer.fromJson<bool>(json['isRead']),
      readAt: serializer.fromJson<DateTime?>(json['readAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'type': serializer.toJson<String>(type),
      'title': serializer.toJson<String>(title),
      'body': serializer.toJson<String>(body),
      'data': serializer.toJson<String?>(data),
      'actionType': serializer.toJson<String?>(actionType),
      'actionTarget': serializer.toJson<String?>(actionTarget),
      'isRead': serializer.toJson<bool>(isRead),
      'readAt': serializer.toJson<DateTime?>(readAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Notification copyWith({
    String? id,
    String? userId,
    String? type,
    String? title,
    String? body,
    Value<String?> data = const Value.absent(),
    Value<String?> actionType = const Value.absent(),
    Value<String?> actionTarget = const Value.absent(),
    bool? isRead,
    Value<DateTime?> readAt = const Value.absent(),
    Value<DateTime?> expiresAt = const Value.absent(),
    DateTime? createdAt,
  }) => Notification(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    type: type ?? this.type,
    title: title ?? this.title,
    body: body ?? this.body,
    data: data.present ? data.value : this.data,
    actionType: actionType.present ? actionType.value : this.actionType,
    actionTarget: actionTarget.present ? actionTarget.value : this.actionTarget,
    isRead: isRead ?? this.isRead,
    readAt: readAt.present ? readAt.value : this.readAt,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    createdAt: createdAt ?? this.createdAt,
  );
  Notification copyWithCompanion(NotificationsCompanion data) {
    return Notification(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      type: data.type.present ? data.type.value : this.type,
      title: data.title.present ? data.title.value : this.title,
      body: data.body.present ? data.body.value : this.body,
      data: data.data.present ? data.data.value : this.data,
      actionType: data.actionType.present
          ? data.actionType.value
          : this.actionType,
      actionTarget: data.actionTarget.present
          ? data.actionTarget.value
          : this.actionTarget,
      isRead: data.isRead.present ? data.isRead.value : this.isRead,
      readAt: data.readAt.present ? data.readAt.value : this.readAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Notification(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('type: $type, ')
          ..write('title: $title, ')
          ..write('body: $body, ')
          ..write('data: $data, ')
          ..write('actionType: $actionType, ')
          ..write('actionTarget: $actionTarget, ')
          ..write('isRead: $isRead, ')
          ..write('readAt: $readAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    type,
    title,
    body,
    data,
    actionType,
    actionTarget,
    isRead,
    readAt,
    expiresAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Notification &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.type == this.type &&
          other.title == this.title &&
          other.body == this.body &&
          other.data == this.data &&
          other.actionType == this.actionType &&
          other.actionTarget == this.actionTarget &&
          other.isRead == this.isRead &&
          other.readAt == this.readAt &&
          other.expiresAt == this.expiresAt &&
          other.createdAt == this.createdAt);
}

class NotificationsCompanion extends UpdateCompanion<Notification> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> type;
  final Value<String> title;
  final Value<String> body;
  final Value<String?> data;
  final Value<String?> actionType;
  final Value<String?> actionTarget;
  final Value<bool> isRead;
  final Value<DateTime?> readAt;
  final Value<DateTime?> expiresAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const NotificationsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.type = const Value.absent(),
    this.title = const Value.absent(),
    this.body = const Value.absent(),
    this.data = const Value.absent(),
    this.actionType = const Value.absent(),
    this.actionTarget = const Value.absent(),
    this.isRead = const Value.absent(),
    this.readAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NotificationsCompanion.insert({
    required String id,
    required String userId,
    required String type,
    required String title,
    required String body,
    this.data = const Value.absent(),
    this.actionType = const Value.absent(),
    this.actionTarget = const Value.absent(),
    this.isRead = const Value.absent(),
    this.readAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       type = Value(type),
       title = Value(title),
       body = Value(body),
       createdAt = Value(createdAt);
  static Insertable<Notification> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? type,
    Expression<String>? title,
    Expression<String>? body,
    Expression<String>? data,
    Expression<String>? actionType,
    Expression<String>? actionTarget,
    Expression<bool>? isRead,
    Expression<DateTime>? readAt,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (type != null) 'type': type,
      if (title != null) 'title': title,
      if (body != null) 'body': body,
      if (data != null) 'data': data,
      if (actionType != null) 'action_type': actionType,
      if (actionTarget != null) 'action_target': actionTarget,
      if (isRead != null) 'is_read': isRead,
      if (readAt != null) 'read_at': readAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NotificationsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? type,
    Value<String>? title,
    Value<String>? body,
    Value<String?>? data,
    Value<String?>? actionType,
    Value<String?>? actionTarget,
    Value<bool>? isRead,
    Value<DateTime?>? readAt,
    Value<DateTime?>? expiresAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return NotificationsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      type: type ?? this.type,
      title: title ?? this.title,
      body: body ?? this.body,
      data: data ?? this.data,
      actionType: actionType ?? this.actionType,
      actionTarget: actionTarget ?? this.actionTarget,
      isRead: isRead ?? this.isRead,
      readAt: readAt ?? this.readAt,
      expiresAt: expiresAt ?? this.expiresAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (body.present) {
      map['body'] = Variable<String>(body.value);
    }
    if (data.present) {
      map['data'] = Variable<String>(data.value);
    }
    if (actionType.present) {
      map['action_type'] = Variable<String>(actionType.value);
    }
    if (actionTarget.present) {
      map['action_target'] = Variable<String>(actionTarget.value);
    }
    if (isRead.present) {
      map['is_read'] = Variable<bool>(isRead.value);
    }
    if (readAt.present) {
      map['read_at'] = Variable<DateTime>(readAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NotificationsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('type: $type, ')
          ..write('title: $title, ')
          ..write('body: $body, ')
          ..write('data: $data, ')
          ..write('actionType: $actionType, ')
          ..write('actionTarget: $actionTarget, ')
          ..write('isRead: $isRead, ')
          ..write('readAt: $readAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NotificationSettingsTable extends NotificationSettings
    with TableInfo<$NotificationSettingsTable, NotificationSetting> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NotificationSettingsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'UNIQUE REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _pushEnabledMeta = const VerificationMeta(
    'pushEnabled',
  );
  @override
  late final GeneratedColumn<bool> pushEnabled = GeneratedColumn<bool>(
    'push_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("push_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _emailEnabledMeta = const VerificationMeta(
    'emailEnabled',
  );
  @override
  late final GeneratedColumn<bool> emailEnabled = GeneratedColumn<bool>(
    'email_enabled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("email_enabled" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _activityRemindersMeta = const VerificationMeta(
    'activityReminders',
  );
  @override
  late final GeneratedColumn<bool> activityReminders = GeneratedColumn<bool>(
    'activity_reminders',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("activity_reminders" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _pipelineUpdatesMeta = const VerificationMeta(
    'pipelineUpdates',
  );
  @override
  late final GeneratedColumn<bool> pipelineUpdates = GeneratedColumn<bool>(
    'pipeline_updates',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("pipeline_updates" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _referralNotificationsMeta =
      const VerificationMeta('referralNotifications');
  @override
  late final GeneratedColumn<bool> referralNotifications =
      GeneratedColumn<bool>(
        'referral_notifications',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("referral_notifications" IN (0, 1))',
        ),
        defaultValue: const Constant(true),
      );
  static const VerificationMeta _cadenceRemindersMeta = const VerificationMeta(
    'cadenceReminders',
  );
  @override
  late final GeneratedColumn<bool> cadenceReminders = GeneratedColumn<bool>(
    'cadence_reminders',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("cadence_reminders" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _systemNotificationsMeta =
      const VerificationMeta('systemNotifications');
  @override
  late final GeneratedColumn<bool> systemNotifications = GeneratedColumn<bool>(
    'system_notifications',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("system_notifications" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _reminderMinutesBeforeMeta =
      const VerificationMeta('reminderMinutesBefore');
  @override
  late final GeneratedColumn<int> reminderMinutesBefore = GeneratedColumn<int>(
    'reminder_minutes_before',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(30),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    pushEnabled,
    emailEnabled,
    activityReminders,
    pipelineUpdates,
    referralNotifications,
    cadenceReminders,
    systemNotifications,
    reminderMinutesBefore,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'notification_settings';
  @override
  VerificationContext validateIntegrity(
    Insertable<NotificationSetting> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('push_enabled')) {
      context.handle(
        _pushEnabledMeta,
        pushEnabled.isAcceptableOrUnknown(
          data['push_enabled']!,
          _pushEnabledMeta,
        ),
      );
    }
    if (data.containsKey('email_enabled')) {
      context.handle(
        _emailEnabledMeta,
        emailEnabled.isAcceptableOrUnknown(
          data['email_enabled']!,
          _emailEnabledMeta,
        ),
      );
    }
    if (data.containsKey('activity_reminders')) {
      context.handle(
        _activityRemindersMeta,
        activityReminders.isAcceptableOrUnknown(
          data['activity_reminders']!,
          _activityRemindersMeta,
        ),
      );
    }
    if (data.containsKey('pipeline_updates')) {
      context.handle(
        _pipelineUpdatesMeta,
        pipelineUpdates.isAcceptableOrUnknown(
          data['pipeline_updates']!,
          _pipelineUpdatesMeta,
        ),
      );
    }
    if (data.containsKey('referral_notifications')) {
      context.handle(
        _referralNotificationsMeta,
        referralNotifications.isAcceptableOrUnknown(
          data['referral_notifications']!,
          _referralNotificationsMeta,
        ),
      );
    }
    if (data.containsKey('cadence_reminders')) {
      context.handle(
        _cadenceRemindersMeta,
        cadenceReminders.isAcceptableOrUnknown(
          data['cadence_reminders']!,
          _cadenceRemindersMeta,
        ),
      );
    }
    if (data.containsKey('system_notifications')) {
      context.handle(
        _systemNotificationsMeta,
        systemNotifications.isAcceptableOrUnknown(
          data['system_notifications']!,
          _systemNotificationsMeta,
        ),
      );
    }
    if (data.containsKey('reminder_minutes_before')) {
      context.handle(
        _reminderMinutesBeforeMeta,
        reminderMinutesBefore.isAcceptableOrUnknown(
          data['reminder_minutes_before']!,
          _reminderMinutesBeforeMeta,
        ),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  NotificationSetting map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NotificationSetting(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      pushEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}push_enabled'],
      )!,
      emailEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}email_enabled'],
      )!,
      activityReminders: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}activity_reminders'],
      )!,
      pipelineUpdates: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}pipeline_updates'],
      )!,
      referralNotifications: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}referral_notifications'],
      )!,
      cadenceReminders: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}cadence_reminders'],
      )!,
      systemNotifications: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}system_notifications'],
      )!,
      reminderMinutesBefore: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}reminder_minutes_before'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $NotificationSettingsTable createAlias(String alias) {
    return $NotificationSettingsTable(attachedDatabase, alias);
  }
}

class NotificationSetting extends DataClass
    implements Insertable<NotificationSetting> {
  final String id;
  final String userId;
  final bool pushEnabled;
  final bool emailEnabled;
  final bool activityReminders;
  final bool pipelineUpdates;
  final bool referralNotifications;
  final bool cadenceReminders;
  final bool systemNotifications;
  final int reminderMinutesBefore;
  final DateTime updatedAt;
  const NotificationSetting({
    required this.id,
    required this.userId,
    required this.pushEnabled,
    required this.emailEnabled,
    required this.activityReminders,
    required this.pipelineUpdates,
    required this.referralNotifications,
    required this.cadenceReminders,
    required this.systemNotifications,
    required this.reminderMinutesBefore,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['push_enabled'] = Variable<bool>(pushEnabled);
    map['email_enabled'] = Variable<bool>(emailEnabled);
    map['activity_reminders'] = Variable<bool>(activityReminders);
    map['pipeline_updates'] = Variable<bool>(pipelineUpdates);
    map['referral_notifications'] = Variable<bool>(referralNotifications);
    map['cadence_reminders'] = Variable<bool>(cadenceReminders);
    map['system_notifications'] = Variable<bool>(systemNotifications);
    map['reminder_minutes_before'] = Variable<int>(reminderMinutesBefore);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  NotificationSettingsCompanion toCompanion(bool nullToAbsent) {
    return NotificationSettingsCompanion(
      id: Value(id),
      userId: Value(userId),
      pushEnabled: Value(pushEnabled),
      emailEnabled: Value(emailEnabled),
      activityReminders: Value(activityReminders),
      pipelineUpdates: Value(pipelineUpdates),
      referralNotifications: Value(referralNotifications),
      cadenceReminders: Value(cadenceReminders),
      systemNotifications: Value(systemNotifications),
      reminderMinutesBefore: Value(reminderMinutesBefore),
      updatedAt: Value(updatedAt),
    );
  }

  factory NotificationSetting.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NotificationSetting(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      pushEnabled: serializer.fromJson<bool>(json['pushEnabled']),
      emailEnabled: serializer.fromJson<bool>(json['emailEnabled']),
      activityReminders: serializer.fromJson<bool>(json['activityReminders']),
      pipelineUpdates: serializer.fromJson<bool>(json['pipelineUpdates']),
      referralNotifications: serializer.fromJson<bool>(
        json['referralNotifications'],
      ),
      cadenceReminders: serializer.fromJson<bool>(json['cadenceReminders']),
      systemNotifications: serializer.fromJson<bool>(
        json['systemNotifications'],
      ),
      reminderMinutesBefore: serializer.fromJson<int>(
        json['reminderMinutesBefore'],
      ),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'pushEnabled': serializer.toJson<bool>(pushEnabled),
      'emailEnabled': serializer.toJson<bool>(emailEnabled),
      'activityReminders': serializer.toJson<bool>(activityReminders),
      'pipelineUpdates': serializer.toJson<bool>(pipelineUpdates),
      'referralNotifications': serializer.toJson<bool>(referralNotifications),
      'cadenceReminders': serializer.toJson<bool>(cadenceReminders),
      'systemNotifications': serializer.toJson<bool>(systemNotifications),
      'reminderMinutesBefore': serializer.toJson<int>(reminderMinutesBefore),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  NotificationSetting copyWith({
    String? id,
    String? userId,
    bool? pushEnabled,
    bool? emailEnabled,
    bool? activityReminders,
    bool? pipelineUpdates,
    bool? referralNotifications,
    bool? cadenceReminders,
    bool? systemNotifications,
    int? reminderMinutesBefore,
    DateTime? updatedAt,
  }) => NotificationSetting(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    pushEnabled: pushEnabled ?? this.pushEnabled,
    emailEnabled: emailEnabled ?? this.emailEnabled,
    activityReminders: activityReminders ?? this.activityReminders,
    pipelineUpdates: pipelineUpdates ?? this.pipelineUpdates,
    referralNotifications: referralNotifications ?? this.referralNotifications,
    cadenceReminders: cadenceReminders ?? this.cadenceReminders,
    systemNotifications: systemNotifications ?? this.systemNotifications,
    reminderMinutesBefore: reminderMinutesBefore ?? this.reminderMinutesBefore,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  NotificationSetting copyWithCompanion(NotificationSettingsCompanion data) {
    return NotificationSetting(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      pushEnabled: data.pushEnabled.present
          ? data.pushEnabled.value
          : this.pushEnabled,
      emailEnabled: data.emailEnabled.present
          ? data.emailEnabled.value
          : this.emailEnabled,
      activityReminders: data.activityReminders.present
          ? data.activityReminders.value
          : this.activityReminders,
      pipelineUpdates: data.pipelineUpdates.present
          ? data.pipelineUpdates.value
          : this.pipelineUpdates,
      referralNotifications: data.referralNotifications.present
          ? data.referralNotifications.value
          : this.referralNotifications,
      cadenceReminders: data.cadenceReminders.present
          ? data.cadenceReminders.value
          : this.cadenceReminders,
      systemNotifications: data.systemNotifications.present
          ? data.systemNotifications.value
          : this.systemNotifications,
      reminderMinutesBefore: data.reminderMinutesBefore.present
          ? data.reminderMinutesBefore.value
          : this.reminderMinutesBefore,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('NotificationSetting(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('pushEnabled: $pushEnabled, ')
          ..write('emailEnabled: $emailEnabled, ')
          ..write('activityReminders: $activityReminders, ')
          ..write('pipelineUpdates: $pipelineUpdates, ')
          ..write('referralNotifications: $referralNotifications, ')
          ..write('cadenceReminders: $cadenceReminders, ')
          ..write('systemNotifications: $systemNotifications, ')
          ..write('reminderMinutesBefore: $reminderMinutesBefore, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    pushEnabled,
    emailEnabled,
    activityReminders,
    pipelineUpdates,
    referralNotifications,
    cadenceReminders,
    systemNotifications,
    reminderMinutesBefore,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NotificationSetting &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.pushEnabled == this.pushEnabled &&
          other.emailEnabled == this.emailEnabled &&
          other.activityReminders == this.activityReminders &&
          other.pipelineUpdates == this.pipelineUpdates &&
          other.referralNotifications == this.referralNotifications &&
          other.cadenceReminders == this.cadenceReminders &&
          other.systemNotifications == this.systemNotifications &&
          other.reminderMinutesBefore == this.reminderMinutesBefore &&
          other.updatedAt == this.updatedAt);
}

class NotificationSettingsCompanion
    extends UpdateCompanion<NotificationSetting> {
  final Value<String> id;
  final Value<String> userId;
  final Value<bool> pushEnabled;
  final Value<bool> emailEnabled;
  final Value<bool> activityReminders;
  final Value<bool> pipelineUpdates;
  final Value<bool> referralNotifications;
  final Value<bool> cadenceReminders;
  final Value<bool> systemNotifications;
  final Value<int> reminderMinutesBefore;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const NotificationSettingsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.pushEnabled = const Value.absent(),
    this.emailEnabled = const Value.absent(),
    this.activityReminders = const Value.absent(),
    this.pipelineUpdates = const Value.absent(),
    this.referralNotifications = const Value.absent(),
    this.cadenceReminders = const Value.absent(),
    this.systemNotifications = const Value.absent(),
    this.reminderMinutesBefore = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NotificationSettingsCompanion.insert({
    required String id,
    required String userId,
    this.pushEnabled = const Value.absent(),
    this.emailEnabled = const Value.absent(),
    this.activityReminders = const Value.absent(),
    this.pipelineUpdates = const Value.absent(),
    this.referralNotifications = const Value.absent(),
    this.cadenceReminders = const Value.absent(),
    this.systemNotifications = const Value.absent(),
    this.reminderMinutesBefore = const Value.absent(),
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       updatedAt = Value(updatedAt);
  static Insertable<NotificationSetting> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<bool>? pushEnabled,
    Expression<bool>? emailEnabled,
    Expression<bool>? activityReminders,
    Expression<bool>? pipelineUpdates,
    Expression<bool>? referralNotifications,
    Expression<bool>? cadenceReminders,
    Expression<bool>? systemNotifications,
    Expression<int>? reminderMinutesBefore,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (pushEnabled != null) 'push_enabled': pushEnabled,
      if (emailEnabled != null) 'email_enabled': emailEnabled,
      if (activityReminders != null) 'activity_reminders': activityReminders,
      if (pipelineUpdates != null) 'pipeline_updates': pipelineUpdates,
      if (referralNotifications != null)
        'referral_notifications': referralNotifications,
      if (cadenceReminders != null) 'cadence_reminders': cadenceReminders,
      if (systemNotifications != null)
        'system_notifications': systemNotifications,
      if (reminderMinutesBefore != null)
        'reminder_minutes_before': reminderMinutesBefore,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NotificationSettingsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<bool>? pushEnabled,
    Value<bool>? emailEnabled,
    Value<bool>? activityReminders,
    Value<bool>? pipelineUpdates,
    Value<bool>? referralNotifications,
    Value<bool>? cadenceReminders,
    Value<bool>? systemNotifications,
    Value<int>? reminderMinutesBefore,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return NotificationSettingsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      pushEnabled: pushEnabled ?? this.pushEnabled,
      emailEnabled: emailEnabled ?? this.emailEnabled,
      activityReminders: activityReminders ?? this.activityReminders,
      pipelineUpdates: pipelineUpdates ?? this.pipelineUpdates,
      referralNotifications:
          referralNotifications ?? this.referralNotifications,
      cadenceReminders: cadenceReminders ?? this.cadenceReminders,
      systemNotifications: systemNotifications ?? this.systemNotifications,
      reminderMinutesBefore:
          reminderMinutesBefore ?? this.reminderMinutesBefore,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (pushEnabled.present) {
      map['push_enabled'] = Variable<bool>(pushEnabled.value);
    }
    if (emailEnabled.present) {
      map['email_enabled'] = Variable<bool>(emailEnabled.value);
    }
    if (activityReminders.present) {
      map['activity_reminders'] = Variable<bool>(activityReminders.value);
    }
    if (pipelineUpdates.present) {
      map['pipeline_updates'] = Variable<bool>(pipelineUpdates.value);
    }
    if (referralNotifications.present) {
      map['referral_notifications'] = Variable<bool>(
        referralNotifications.value,
      );
    }
    if (cadenceReminders.present) {
      map['cadence_reminders'] = Variable<bool>(cadenceReminders.value);
    }
    if (systemNotifications.present) {
      map['system_notifications'] = Variable<bool>(systemNotifications.value);
    }
    if (reminderMinutesBefore.present) {
      map['reminder_minutes_before'] = Variable<int>(
        reminderMinutesBefore.value,
      );
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NotificationSettingsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('pushEnabled: $pushEnabled, ')
          ..write('emailEnabled: $emailEnabled, ')
          ..write('activityReminders: $activityReminders, ')
          ..write('pipelineUpdates: $pipelineUpdates, ')
          ..write('referralNotifications: $referralNotifications, ')
          ..write('cadenceReminders: $cadenceReminders, ')
          ..write('systemNotifications: $systemNotifications, ')
          ..write('reminderMinutesBefore: $reminderMinutesBefore, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AnnouncementsTable extends Announcements
    with TableInfo<$AnnouncementsTable, Announcement> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AnnouncementsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bodyMeta = const VerificationMeta('body');
  @override
  late final GeneratedColumn<String> body = GeneratedColumn<String>(
    'body',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('INFO'),
  );
  static const VerificationMeta _targetRolesMeta = const VerificationMeta(
    'targetRoles',
  );
  @override
  late final GeneratedColumn<String> targetRoles = GeneratedColumn<String>(
    'target_roles',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _targetBranchesMeta = const VerificationMeta(
    'targetBranches',
  );
  @override
  late final GeneratedColumn<String> targetBranches = GeneratedColumn<String>(
    'target_branches',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _publishAtMeta = const VerificationMeta(
    'publishAt',
  );
  @override
  late final GeneratedColumn<DateTime> publishAt = GeneratedColumn<DateTime>(
    'publish_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isPinnedMeta = const VerificationMeta(
    'isPinned',
  );
  @override
  late final GeneratedColumn<bool> isPinned = GeneratedColumn<bool>(
    'is_pinned',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pinned" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdByMeta = const VerificationMeta(
    'createdBy',
  );
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
    'created_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    title,
    body,
    type,
    targetRoles,
    targetBranches,
    publishAt,
    expiresAt,
    isPinned,
    createdBy,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'announcements';
  @override
  VerificationContext validateIntegrity(
    Insertable<Announcement> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('body')) {
      context.handle(
        _bodyMeta,
        body.isAcceptableOrUnknown(data['body']!, _bodyMeta),
      );
    } else if (isInserting) {
      context.missing(_bodyMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    }
    if (data.containsKey('target_roles')) {
      context.handle(
        _targetRolesMeta,
        targetRoles.isAcceptableOrUnknown(
          data['target_roles']!,
          _targetRolesMeta,
        ),
      );
    }
    if (data.containsKey('target_branches')) {
      context.handle(
        _targetBranchesMeta,
        targetBranches.isAcceptableOrUnknown(
          data['target_branches']!,
          _targetBranchesMeta,
        ),
      );
    }
    if (data.containsKey('publish_at')) {
      context.handle(
        _publishAtMeta,
        publishAt.isAcceptableOrUnknown(data['publish_at']!, _publishAtMeta),
      );
    } else if (isInserting) {
      context.missing(_publishAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('is_pinned')) {
      context.handle(
        _isPinnedMeta,
        isPinned.isAcceptableOrUnknown(data['is_pinned']!, _isPinnedMeta),
      );
    }
    if (data.containsKey('created_by')) {
      context.handle(
        _createdByMeta,
        createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta),
      );
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Announcement map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Announcement(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      body: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}body'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      targetRoles: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_roles'],
      ),
      targetBranches: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_branches'],
      ),
      publishAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}publish_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      isPinned: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pinned'],
      )!,
      createdBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_by'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $AnnouncementsTable createAlias(String alias) {
    return $AnnouncementsTable(attachedDatabase, alias);
  }
}

class Announcement extends DataClass implements Insertable<Announcement> {
  final String id;
  final String title;
  final String body;
  final String type;
  final String? targetRoles;
  final String? targetBranches;
  final DateTime publishAt;
  final DateTime? expiresAt;
  final bool isPinned;
  final String createdBy;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Announcement({
    required this.id,
    required this.title,
    required this.body,
    required this.type,
    this.targetRoles,
    this.targetBranches,
    required this.publishAt,
    this.expiresAt,
    required this.isPinned,
    required this.createdBy,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['title'] = Variable<String>(title);
    map['body'] = Variable<String>(body);
    map['type'] = Variable<String>(type);
    if (!nullToAbsent || targetRoles != null) {
      map['target_roles'] = Variable<String>(targetRoles);
    }
    if (!nullToAbsent || targetBranches != null) {
      map['target_branches'] = Variable<String>(targetBranches);
    }
    map['publish_at'] = Variable<DateTime>(publishAt);
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    map['is_pinned'] = Variable<bool>(isPinned);
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  AnnouncementsCompanion toCompanion(bool nullToAbsent) {
    return AnnouncementsCompanion(
      id: Value(id),
      title: Value(title),
      body: Value(body),
      type: Value(type),
      targetRoles: targetRoles == null && nullToAbsent
          ? const Value.absent()
          : Value(targetRoles),
      targetBranches: targetBranches == null && nullToAbsent
          ? const Value.absent()
          : Value(targetBranches),
      publishAt: Value(publishAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      isPinned: Value(isPinned),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Announcement.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Announcement(
      id: serializer.fromJson<String>(json['id']),
      title: serializer.fromJson<String>(json['title']),
      body: serializer.fromJson<String>(json['body']),
      type: serializer.fromJson<String>(json['type']),
      targetRoles: serializer.fromJson<String?>(json['targetRoles']),
      targetBranches: serializer.fromJson<String?>(json['targetBranches']),
      publishAt: serializer.fromJson<DateTime>(json['publishAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      isPinned: serializer.fromJson<bool>(json['isPinned']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'title': serializer.toJson<String>(title),
      'body': serializer.toJson<String>(body),
      'type': serializer.toJson<String>(type),
      'targetRoles': serializer.toJson<String?>(targetRoles),
      'targetBranches': serializer.toJson<String?>(targetBranches),
      'publishAt': serializer.toJson<DateTime>(publishAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'isPinned': serializer.toJson<bool>(isPinned),
      'createdBy': serializer.toJson<String>(createdBy),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Announcement copyWith({
    String? id,
    String? title,
    String? body,
    String? type,
    Value<String?> targetRoles = const Value.absent(),
    Value<String?> targetBranches = const Value.absent(),
    DateTime? publishAt,
    Value<DateTime?> expiresAt = const Value.absent(),
    bool? isPinned,
    String? createdBy,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Announcement(
    id: id ?? this.id,
    title: title ?? this.title,
    body: body ?? this.body,
    type: type ?? this.type,
    targetRoles: targetRoles.present ? targetRoles.value : this.targetRoles,
    targetBranches: targetBranches.present
        ? targetBranches.value
        : this.targetBranches,
    publishAt: publishAt ?? this.publishAt,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    isPinned: isPinned ?? this.isPinned,
    createdBy: createdBy ?? this.createdBy,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Announcement copyWithCompanion(AnnouncementsCompanion data) {
    return Announcement(
      id: data.id.present ? data.id.value : this.id,
      title: data.title.present ? data.title.value : this.title,
      body: data.body.present ? data.body.value : this.body,
      type: data.type.present ? data.type.value : this.type,
      targetRoles: data.targetRoles.present
          ? data.targetRoles.value
          : this.targetRoles,
      targetBranches: data.targetBranches.present
          ? data.targetBranches.value
          : this.targetBranches,
      publishAt: data.publishAt.present ? data.publishAt.value : this.publishAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      isPinned: data.isPinned.present ? data.isPinned.value : this.isPinned,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Announcement(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('body: $body, ')
          ..write('type: $type, ')
          ..write('targetRoles: $targetRoles, ')
          ..write('targetBranches: $targetBranches, ')
          ..write('publishAt: $publishAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('isPinned: $isPinned, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    title,
    body,
    type,
    targetRoles,
    targetBranches,
    publishAt,
    expiresAt,
    isPinned,
    createdBy,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Announcement &&
          other.id == this.id &&
          other.title == this.title &&
          other.body == this.body &&
          other.type == this.type &&
          other.targetRoles == this.targetRoles &&
          other.targetBranches == this.targetBranches &&
          other.publishAt == this.publishAt &&
          other.expiresAt == this.expiresAt &&
          other.isPinned == this.isPinned &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class AnnouncementsCompanion extends UpdateCompanion<Announcement> {
  final Value<String> id;
  final Value<String> title;
  final Value<String> body;
  final Value<String> type;
  final Value<String?> targetRoles;
  final Value<String?> targetBranches;
  final Value<DateTime> publishAt;
  final Value<DateTime?> expiresAt;
  final Value<bool> isPinned;
  final Value<String> createdBy;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const AnnouncementsCompanion({
    this.id = const Value.absent(),
    this.title = const Value.absent(),
    this.body = const Value.absent(),
    this.type = const Value.absent(),
    this.targetRoles = const Value.absent(),
    this.targetBranches = const Value.absent(),
    this.publishAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.isPinned = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AnnouncementsCompanion.insert({
    required String id,
    required String title,
    required String body,
    this.type = const Value.absent(),
    this.targetRoles = const Value.absent(),
    this.targetBranches = const Value.absent(),
    required DateTime publishAt,
    this.expiresAt = const Value.absent(),
    this.isPinned = const Value.absent(),
    required String createdBy,
    required DateTime createdAt,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       title = Value(title),
       body = Value(body),
       publishAt = Value(publishAt),
       createdBy = Value(createdBy),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Announcement> custom({
    Expression<String>? id,
    Expression<String>? title,
    Expression<String>? body,
    Expression<String>? type,
    Expression<String>? targetRoles,
    Expression<String>? targetBranches,
    Expression<DateTime>? publishAt,
    Expression<DateTime>? expiresAt,
    Expression<bool>? isPinned,
    Expression<String>? createdBy,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (title != null) 'title': title,
      if (body != null) 'body': body,
      if (type != null) 'type': type,
      if (targetRoles != null) 'target_roles': targetRoles,
      if (targetBranches != null) 'target_branches': targetBranches,
      if (publishAt != null) 'publish_at': publishAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (isPinned != null) 'is_pinned': isPinned,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AnnouncementsCompanion copyWith({
    Value<String>? id,
    Value<String>? title,
    Value<String>? body,
    Value<String>? type,
    Value<String?>? targetRoles,
    Value<String?>? targetBranches,
    Value<DateTime>? publishAt,
    Value<DateTime?>? expiresAt,
    Value<bool>? isPinned,
    Value<String>? createdBy,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return AnnouncementsCompanion(
      id: id ?? this.id,
      title: title ?? this.title,
      body: body ?? this.body,
      type: type ?? this.type,
      targetRoles: targetRoles ?? this.targetRoles,
      targetBranches: targetBranches ?? this.targetBranches,
      publishAt: publishAt ?? this.publishAt,
      expiresAt: expiresAt ?? this.expiresAt,
      isPinned: isPinned ?? this.isPinned,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (body.present) {
      map['body'] = Variable<String>(body.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (targetRoles.present) {
      map['target_roles'] = Variable<String>(targetRoles.value);
    }
    if (targetBranches.present) {
      map['target_branches'] = Variable<String>(targetBranches.value);
    }
    if (publishAt.present) {
      map['publish_at'] = Variable<DateTime>(publishAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (isPinned.present) {
      map['is_pinned'] = Variable<bool>(isPinned.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AnnouncementsCompanion(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('body: $body, ')
          ..write('type: $type, ')
          ..write('targetRoles: $targetRoles, ')
          ..write('targetBranches: $targetBranches, ')
          ..write('publishAt: $publishAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('isPinned: $isPinned, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AnnouncementReadsTable extends AnnouncementReads
    with TableInfo<$AnnouncementReadsTable, AnnouncementRead> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AnnouncementReadsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _announcementIdMeta = const VerificationMeta(
    'announcementId',
  );
  @override
  late final GeneratedColumn<String> announcementId = GeneratedColumn<String>(
    'announcement_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES announcements (id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _readAtMeta = const VerificationMeta('readAt');
  @override
  late final GeneratedColumn<DateTime> readAt = GeneratedColumn<DateTime>(
    'read_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [id, announcementId, userId, readAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'announcement_reads';
  @override
  VerificationContext validateIntegrity(
    Insertable<AnnouncementRead> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('announcement_id')) {
      context.handle(
        _announcementIdMeta,
        announcementId.isAcceptableOrUnknown(
          data['announcement_id']!,
          _announcementIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_announcementIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('read_at')) {
      context.handle(
        _readAtMeta,
        readAt.isAcceptableOrUnknown(data['read_at']!, _readAtMeta),
      );
    } else if (isInserting) {
      context.missing(_readAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AnnouncementRead map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AnnouncementRead(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      announcementId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}announcement_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      readAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}read_at'],
      )!,
    );
  }

  @override
  $AnnouncementReadsTable createAlias(String alias) {
    return $AnnouncementReadsTable(attachedDatabase, alias);
  }
}

class AnnouncementRead extends DataClass
    implements Insertable<AnnouncementRead> {
  final String id;
  final String announcementId;
  final String userId;
  final DateTime readAt;
  const AnnouncementRead({
    required this.id,
    required this.announcementId,
    required this.userId,
    required this.readAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['announcement_id'] = Variable<String>(announcementId);
    map['user_id'] = Variable<String>(userId);
    map['read_at'] = Variable<DateTime>(readAt);
    return map;
  }

  AnnouncementReadsCompanion toCompanion(bool nullToAbsent) {
    return AnnouncementReadsCompanion(
      id: Value(id),
      announcementId: Value(announcementId),
      userId: Value(userId),
      readAt: Value(readAt),
    );
  }

  factory AnnouncementRead.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AnnouncementRead(
      id: serializer.fromJson<String>(json['id']),
      announcementId: serializer.fromJson<String>(json['announcementId']),
      userId: serializer.fromJson<String>(json['userId']),
      readAt: serializer.fromJson<DateTime>(json['readAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'announcementId': serializer.toJson<String>(announcementId),
      'userId': serializer.toJson<String>(userId),
      'readAt': serializer.toJson<DateTime>(readAt),
    };
  }

  AnnouncementRead copyWith({
    String? id,
    String? announcementId,
    String? userId,
    DateTime? readAt,
  }) => AnnouncementRead(
    id: id ?? this.id,
    announcementId: announcementId ?? this.announcementId,
    userId: userId ?? this.userId,
    readAt: readAt ?? this.readAt,
  );
  AnnouncementRead copyWithCompanion(AnnouncementReadsCompanion data) {
    return AnnouncementRead(
      id: data.id.present ? data.id.value : this.id,
      announcementId: data.announcementId.present
          ? data.announcementId.value
          : this.announcementId,
      userId: data.userId.present ? data.userId.value : this.userId,
      readAt: data.readAt.present ? data.readAt.value : this.readAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AnnouncementRead(')
          ..write('id: $id, ')
          ..write('announcementId: $announcementId, ')
          ..write('userId: $userId, ')
          ..write('readAt: $readAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, announcementId, userId, readAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AnnouncementRead &&
          other.id == this.id &&
          other.announcementId == this.announcementId &&
          other.userId == this.userId &&
          other.readAt == this.readAt);
}

class AnnouncementReadsCompanion extends UpdateCompanion<AnnouncementRead> {
  final Value<String> id;
  final Value<String> announcementId;
  final Value<String> userId;
  final Value<DateTime> readAt;
  final Value<int> rowid;
  const AnnouncementReadsCompanion({
    this.id = const Value.absent(),
    this.announcementId = const Value.absent(),
    this.userId = const Value.absent(),
    this.readAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AnnouncementReadsCompanion.insert({
    required String id,
    required String announcementId,
    required String userId,
    required DateTime readAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       announcementId = Value(announcementId),
       userId = Value(userId),
       readAt = Value(readAt);
  static Insertable<AnnouncementRead> custom({
    Expression<String>? id,
    Expression<String>? announcementId,
    Expression<String>? userId,
    Expression<DateTime>? readAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (announcementId != null) 'announcement_id': announcementId,
      if (userId != null) 'user_id': userId,
      if (readAt != null) 'read_at': readAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AnnouncementReadsCompanion copyWith({
    Value<String>? id,
    Value<String>? announcementId,
    Value<String>? userId,
    Value<DateTime>? readAt,
    Value<int>? rowid,
  }) {
    return AnnouncementReadsCompanion(
      id: id ?? this.id,
      announcementId: announcementId ?? this.announcementId,
      userId: userId ?? this.userId,
      readAt: readAt ?? this.readAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (announcementId.present) {
      map['announcement_id'] = Variable<String>(announcementId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (readAt.present) {
      map['read_at'] = Variable<DateTime>(readAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AnnouncementReadsCompanion(')
          ..write('id: $id, ')
          ..write('announcementId: $announcementId, ')
          ..write('userId: $userId, ')
          ..write('readAt: $readAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncQueueItemsTable extends SyncQueueItems
    with TableInfo<$SyncQueueItemsTable, SyncQueueItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncQueueItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _operationMeta = const VerificationMeta(
    'operation',
  );
  @override
  late final GeneratedColumn<String> operation = GeneratedColumn<String>(
    'operation',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _payloadMeta = const VerificationMeta(
    'payload',
  );
  @override
  late final GeneratedColumn<String> payload = GeneratedColumn<String>(
    'payload',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastErrorMeta = const VerificationMeta(
    'lastError',
  );
  @override
  late final GeneratedColumn<String> lastError = GeneratedColumn<String>(
    'last_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('pending'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lastAttemptAtMeta = const VerificationMeta(
    'lastAttemptAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastAttemptAt =
      GeneratedColumn<DateTime>(
        'last_attempt_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    operation,
    payload,
    retryCount,
    lastError,
    status,
    createdAt,
    lastAttemptAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_queue';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncQueueItem> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('operation')) {
      context.handle(
        _operationMeta,
        operation.isAcceptableOrUnknown(data['operation']!, _operationMeta),
      );
    } else if (isInserting) {
      context.missing(_operationMeta);
    }
    if (data.containsKey('payload')) {
      context.handle(
        _payloadMeta,
        payload.isAcceptableOrUnknown(data['payload']!, _payloadMeta),
      );
    } else if (isInserting) {
      context.missing(_payloadMeta);
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('last_error')) {
      context.handle(
        _lastErrorMeta,
        lastError.isAcceptableOrUnknown(data['last_error']!, _lastErrorMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('last_attempt_at')) {
      context.handle(
        _lastAttemptAtMeta,
        lastAttemptAt.isAcceptableOrUnknown(
          data['last_attempt_at']!,
          _lastAttemptAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncQueueItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncQueueItem(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      operation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation'],
      )!,
      payload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payload'],
      )!,
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      lastError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_error'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      lastAttemptAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_attempt_at'],
      ),
    );
  }

  @override
  $SyncQueueItemsTable createAlias(String alias) {
    return $SyncQueueItemsTable(attachedDatabase, alias);
  }
}

class SyncQueueItem extends DataClass implements Insertable<SyncQueueItem> {
  final int id;
  final String entityType;
  final String entityId;
  final String operation;
  final String payload;
  final int retryCount;
  final String? lastError;

  /// Status lifecycle: pending -> failed -> dead_letter
  /// No 'completed' status because completed items are deleted immediately via markAsCompleted().
  final String status;
  final DateTime createdAt;
  final DateTime? lastAttemptAt;
  const SyncQueueItem({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.operation,
    required this.payload,
    required this.retryCount,
    this.lastError,
    required this.status,
    required this.createdAt,
    this.lastAttemptAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['operation'] = Variable<String>(operation);
    map['payload'] = Variable<String>(payload);
    map['retry_count'] = Variable<int>(retryCount);
    if (!nullToAbsent || lastError != null) {
      map['last_error'] = Variable<String>(lastError);
    }
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || lastAttemptAt != null) {
      map['last_attempt_at'] = Variable<DateTime>(lastAttemptAt);
    }
    return map;
  }

  SyncQueueItemsCompanion toCompanion(bool nullToAbsent) {
    return SyncQueueItemsCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      operation: Value(operation),
      payload: Value(payload),
      retryCount: Value(retryCount),
      lastError: lastError == null && nullToAbsent
          ? const Value.absent()
          : Value(lastError),
      status: Value(status),
      createdAt: Value(createdAt),
      lastAttemptAt: lastAttemptAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastAttemptAt),
    );
  }

  factory SyncQueueItem.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncQueueItem(
      id: serializer.fromJson<int>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      operation: serializer.fromJson<String>(json['operation']),
      payload: serializer.fromJson<String>(json['payload']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      lastError: serializer.fromJson<String?>(json['lastError']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      lastAttemptAt: serializer.fromJson<DateTime?>(json['lastAttemptAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'operation': serializer.toJson<String>(operation),
      'payload': serializer.toJson<String>(payload),
      'retryCount': serializer.toJson<int>(retryCount),
      'lastError': serializer.toJson<String?>(lastError),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'lastAttemptAt': serializer.toJson<DateTime?>(lastAttemptAt),
    };
  }

  SyncQueueItem copyWith({
    int? id,
    String? entityType,
    String? entityId,
    String? operation,
    String? payload,
    int? retryCount,
    Value<String?> lastError = const Value.absent(),
    String? status,
    DateTime? createdAt,
    Value<DateTime?> lastAttemptAt = const Value.absent(),
  }) => SyncQueueItem(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    operation: operation ?? this.operation,
    payload: payload ?? this.payload,
    retryCount: retryCount ?? this.retryCount,
    lastError: lastError.present ? lastError.value : this.lastError,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    lastAttemptAt: lastAttemptAt.present
        ? lastAttemptAt.value
        : this.lastAttemptAt,
  );
  SyncQueueItem copyWithCompanion(SyncQueueItemsCompanion data) {
    return SyncQueueItem(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      operation: data.operation.present ? data.operation.value : this.operation,
      payload: data.payload.present ? data.payload.value : this.payload,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      lastError: data.lastError.present ? data.lastError.value : this.lastError,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      lastAttemptAt: data.lastAttemptAt.present
          ? data.lastAttemptAt.value
          : this.lastAttemptAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueItem(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('retryCount: $retryCount, ')
          ..write('lastError: $lastError, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastAttemptAt: $lastAttemptAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    operation,
    payload,
    retryCount,
    lastError,
    status,
    createdAt,
    lastAttemptAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncQueueItem &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.operation == this.operation &&
          other.payload == this.payload &&
          other.retryCount == this.retryCount &&
          other.lastError == this.lastError &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.lastAttemptAt == this.lastAttemptAt);
}

class SyncQueueItemsCompanion extends UpdateCompanion<SyncQueueItem> {
  final Value<int> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> operation;
  final Value<String> payload;
  final Value<int> retryCount;
  final Value<String?> lastError;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime?> lastAttemptAt;
  const SyncQueueItemsCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.operation = const Value.absent(),
    this.payload = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.lastError = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastAttemptAt = const Value.absent(),
  });
  SyncQueueItemsCompanion.insert({
    this.id = const Value.absent(),
    required String entityType,
    required String entityId,
    required String operation,
    required String payload,
    this.retryCount = const Value.absent(),
    this.lastError = const Value.absent(),
    this.status = const Value.absent(),
    required DateTime createdAt,
    this.lastAttemptAt = const Value.absent(),
  }) : entityType = Value(entityType),
       entityId = Value(entityId),
       operation = Value(operation),
       payload = Value(payload),
       createdAt = Value(createdAt);
  static Insertable<SyncQueueItem> custom({
    Expression<int>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? operation,
    Expression<String>? payload,
    Expression<int>? retryCount,
    Expression<String>? lastError,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? lastAttemptAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (operation != null) 'operation': operation,
      if (payload != null) 'payload': payload,
      if (retryCount != null) 'retry_count': retryCount,
      if (lastError != null) 'last_error': lastError,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (lastAttemptAt != null) 'last_attempt_at': lastAttemptAt,
    });
  }

  SyncQueueItemsCompanion copyWith({
    Value<int>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? operation,
    Value<String>? payload,
    Value<int>? retryCount,
    Value<String?>? lastError,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<DateTime?>? lastAttemptAt,
  }) {
    return SyncQueueItemsCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      operation: operation ?? this.operation,
      payload: payload ?? this.payload,
      retryCount: retryCount ?? this.retryCount,
      lastError: lastError ?? this.lastError,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      lastAttemptAt: lastAttemptAt ?? this.lastAttemptAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (operation.present) {
      map['operation'] = Variable<String>(operation.value);
    }
    if (payload.present) {
      map['payload'] = Variable<String>(payload.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (lastError.present) {
      map['last_error'] = Variable<String>(lastError.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (lastAttemptAt.present) {
      map['last_attempt_at'] = Variable<DateTime>(lastAttemptAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueItemsCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('retryCount: $retryCount, ')
          ..write('lastError: $lastError, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastAttemptAt: $lastAttemptAt')
          ..write(')'))
        .toString();
  }
}

class $AuditLogsTable extends AuditLogs
    with TableInfo<$AuditLogsTable, AuditLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AuditLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetTableMeta = const VerificationMeta(
    'targetTable',
  );
  @override
  late final GeneratedColumn<String> targetTable = GeneratedColumn<String>(
    'target_table',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _recordIdMeta = const VerificationMeta(
    'recordId',
  );
  @override
  late final GeneratedColumn<String> recordId = GeneratedColumn<String>(
    'record_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _oldValuesMeta = const VerificationMeta(
    'oldValues',
  );
  @override
  late final GeneratedColumn<String> oldValues = GeneratedColumn<String>(
    'old_values',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _newValuesMeta = const VerificationMeta(
    'newValues',
  );
  @override
  late final GeneratedColumn<String> newValues = GeneratedColumn<String>(
    'new_values',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _changedByMeta = const VerificationMeta(
    'changedBy',
  );
  @override
  late final GeneratedColumn<String> changedBy = GeneratedColumn<String>(
    'changed_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _changedAtMeta = const VerificationMeta(
    'changedAt',
  );
  @override
  late final GeneratedColumn<DateTime> changedAt = GeneratedColumn<DateTime>(
    'changed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ipAddressMeta = const VerificationMeta(
    'ipAddress',
  );
  @override
  late final GeneratedColumn<String> ipAddress = GeneratedColumn<String>(
    'ip_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userAgentMeta = const VerificationMeta(
    'userAgent',
  );
  @override
  late final GeneratedColumn<String> userAgent = GeneratedColumn<String>(
    'user_agent',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    targetTable,
    recordId,
    action,
    oldValues,
    newValues,
    changedBy,
    changedAt,
    ipAddress,
    userAgent,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<AuditLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('target_table')) {
      context.handle(
        _targetTableMeta,
        targetTable.isAcceptableOrUnknown(
          data['target_table']!,
          _targetTableMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetTableMeta);
    }
    if (data.containsKey('record_id')) {
      context.handle(
        _recordIdMeta,
        recordId.isAcceptableOrUnknown(data['record_id']!, _recordIdMeta),
      );
    } else if (isInserting) {
      context.missing(_recordIdMeta);
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('old_values')) {
      context.handle(
        _oldValuesMeta,
        oldValues.isAcceptableOrUnknown(data['old_values']!, _oldValuesMeta),
      );
    }
    if (data.containsKey('new_values')) {
      context.handle(
        _newValuesMeta,
        newValues.isAcceptableOrUnknown(data['new_values']!, _newValuesMeta),
      );
    }
    if (data.containsKey('changed_by')) {
      context.handle(
        _changedByMeta,
        changedBy.isAcceptableOrUnknown(data['changed_by']!, _changedByMeta),
      );
    }
    if (data.containsKey('changed_at')) {
      context.handle(
        _changedAtMeta,
        changedAt.isAcceptableOrUnknown(data['changed_at']!, _changedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_changedAtMeta);
    }
    if (data.containsKey('ip_address')) {
      context.handle(
        _ipAddressMeta,
        ipAddress.isAcceptableOrUnknown(data['ip_address']!, _ipAddressMeta),
      );
    }
    if (data.containsKey('user_agent')) {
      context.handle(
        _userAgentMeta,
        userAgent.isAcceptableOrUnknown(data['user_agent']!, _userAgentMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AuditLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      targetTable: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_table'],
      )!,
      recordId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}record_id'],
      )!,
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      oldValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}old_values'],
      ),
      newValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}new_values'],
      ),
      changedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}changed_by'],
      ),
      changedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}changed_at'],
      )!,
      ipAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ip_address'],
      ),
      userAgent: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_agent'],
      ),
    );
  }

  @override
  $AuditLogsTable createAlias(String alias) {
    return $AuditLogsTable(attachedDatabase, alias);
  }
}

class AuditLog extends DataClass implements Insertable<AuditLog> {
  final String id;
  final String targetTable;
  final String recordId;
  final String action;
  final String? oldValues;
  final String? newValues;
  final String? changedBy;
  final DateTime changedAt;
  final String? ipAddress;
  final String? userAgent;
  const AuditLog({
    required this.id,
    required this.targetTable,
    required this.recordId,
    required this.action,
    this.oldValues,
    this.newValues,
    this.changedBy,
    required this.changedAt,
    this.ipAddress,
    this.userAgent,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['target_table'] = Variable<String>(targetTable);
    map['record_id'] = Variable<String>(recordId);
    map['action'] = Variable<String>(action);
    if (!nullToAbsent || oldValues != null) {
      map['old_values'] = Variable<String>(oldValues);
    }
    if (!nullToAbsent || newValues != null) {
      map['new_values'] = Variable<String>(newValues);
    }
    if (!nullToAbsent || changedBy != null) {
      map['changed_by'] = Variable<String>(changedBy);
    }
    map['changed_at'] = Variable<DateTime>(changedAt);
    if (!nullToAbsent || ipAddress != null) {
      map['ip_address'] = Variable<String>(ipAddress);
    }
    if (!nullToAbsent || userAgent != null) {
      map['user_agent'] = Variable<String>(userAgent);
    }
    return map;
  }

  AuditLogsCompanion toCompanion(bool nullToAbsent) {
    return AuditLogsCompanion(
      id: Value(id),
      targetTable: Value(targetTable),
      recordId: Value(recordId),
      action: Value(action),
      oldValues: oldValues == null && nullToAbsent
          ? const Value.absent()
          : Value(oldValues),
      newValues: newValues == null && nullToAbsent
          ? const Value.absent()
          : Value(newValues),
      changedBy: changedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(changedBy),
      changedAt: Value(changedAt),
      ipAddress: ipAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(ipAddress),
      userAgent: userAgent == null && nullToAbsent
          ? const Value.absent()
          : Value(userAgent),
    );
  }

  factory AuditLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditLog(
      id: serializer.fromJson<String>(json['id']),
      targetTable: serializer.fromJson<String>(json['targetTable']),
      recordId: serializer.fromJson<String>(json['recordId']),
      action: serializer.fromJson<String>(json['action']),
      oldValues: serializer.fromJson<String?>(json['oldValues']),
      newValues: serializer.fromJson<String?>(json['newValues']),
      changedBy: serializer.fromJson<String?>(json['changedBy']),
      changedAt: serializer.fromJson<DateTime>(json['changedAt']),
      ipAddress: serializer.fromJson<String?>(json['ipAddress']),
      userAgent: serializer.fromJson<String?>(json['userAgent']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'targetTable': serializer.toJson<String>(targetTable),
      'recordId': serializer.toJson<String>(recordId),
      'action': serializer.toJson<String>(action),
      'oldValues': serializer.toJson<String?>(oldValues),
      'newValues': serializer.toJson<String?>(newValues),
      'changedBy': serializer.toJson<String?>(changedBy),
      'changedAt': serializer.toJson<DateTime>(changedAt),
      'ipAddress': serializer.toJson<String?>(ipAddress),
      'userAgent': serializer.toJson<String?>(userAgent),
    };
  }

  AuditLog copyWith({
    String? id,
    String? targetTable,
    String? recordId,
    String? action,
    Value<String?> oldValues = const Value.absent(),
    Value<String?> newValues = const Value.absent(),
    Value<String?> changedBy = const Value.absent(),
    DateTime? changedAt,
    Value<String?> ipAddress = const Value.absent(),
    Value<String?> userAgent = const Value.absent(),
  }) => AuditLog(
    id: id ?? this.id,
    targetTable: targetTable ?? this.targetTable,
    recordId: recordId ?? this.recordId,
    action: action ?? this.action,
    oldValues: oldValues.present ? oldValues.value : this.oldValues,
    newValues: newValues.present ? newValues.value : this.newValues,
    changedBy: changedBy.present ? changedBy.value : this.changedBy,
    changedAt: changedAt ?? this.changedAt,
    ipAddress: ipAddress.present ? ipAddress.value : this.ipAddress,
    userAgent: userAgent.present ? userAgent.value : this.userAgent,
  );
  AuditLog copyWithCompanion(AuditLogsCompanion data) {
    return AuditLog(
      id: data.id.present ? data.id.value : this.id,
      targetTable: data.targetTable.present
          ? data.targetTable.value
          : this.targetTable,
      recordId: data.recordId.present ? data.recordId.value : this.recordId,
      action: data.action.present ? data.action.value : this.action,
      oldValues: data.oldValues.present ? data.oldValues.value : this.oldValues,
      newValues: data.newValues.present ? data.newValues.value : this.newValues,
      changedBy: data.changedBy.present ? data.changedBy.value : this.changedBy,
      changedAt: data.changedAt.present ? data.changedAt.value : this.changedAt,
      ipAddress: data.ipAddress.present ? data.ipAddress.value : this.ipAddress,
      userAgent: data.userAgent.present ? data.userAgent.value : this.userAgent,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditLog(')
          ..write('id: $id, ')
          ..write('targetTable: $targetTable, ')
          ..write('recordId: $recordId, ')
          ..write('action: $action, ')
          ..write('oldValues: $oldValues, ')
          ..write('newValues: $newValues, ')
          ..write('changedBy: $changedBy, ')
          ..write('changedAt: $changedAt, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('userAgent: $userAgent')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    targetTable,
    recordId,
    action,
    oldValues,
    newValues,
    changedBy,
    changedAt,
    ipAddress,
    userAgent,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditLog &&
          other.id == this.id &&
          other.targetTable == this.targetTable &&
          other.recordId == this.recordId &&
          other.action == this.action &&
          other.oldValues == this.oldValues &&
          other.newValues == this.newValues &&
          other.changedBy == this.changedBy &&
          other.changedAt == this.changedAt &&
          other.ipAddress == this.ipAddress &&
          other.userAgent == this.userAgent);
}

class AuditLogsCompanion extends UpdateCompanion<AuditLog> {
  final Value<String> id;
  final Value<String> targetTable;
  final Value<String> recordId;
  final Value<String> action;
  final Value<String?> oldValues;
  final Value<String?> newValues;
  final Value<String?> changedBy;
  final Value<DateTime> changedAt;
  final Value<String?> ipAddress;
  final Value<String?> userAgent;
  final Value<int> rowid;
  const AuditLogsCompanion({
    this.id = const Value.absent(),
    this.targetTable = const Value.absent(),
    this.recordId = const Value.absent(),
    this.action = const Value.absent(),
    this.oldValues = const Value.absent(),
    this.newValues = const Value.absent(),
    this.changedBy = const Value.absent(),
    this.changedAt = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.userAgent = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AuditLogsCompanion.insert({
    required String id,
    required String targetTable,
    required String recordId,
    required String action,
    this.oldValues = const Value.absent(),
    this.newValues = const Value.absent(),
    this.changedBy = const Value.absent(),
    required DateTime changedAt,
    this.ipAddress = const Value.absent(),
    this.userAgent = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       targetTable = Value(targetTable),
       recordId = Value(recordId),
       action = Value(action),
       changedAt = Value(changedAt);
  static Insertable<AuditLog> custom({
    Expression<String>? id,
    Expression<String>? targetTable,
    Expression<String>? recordId,
    Expression<String>? action,
    Expression<String>? oldValues,
    Expression<String>? newValues,
    Expression<String>? changedBy,
    Expression<DateTime>? changedAt,
    Expression<String>? ipAddress,
    Expression<String>? userAgent,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (targetTable != null) 'target_table': targetTable,
      if (recordId != null) 'record_id': recordId,
      if (action != null) 'action': action,
      if (oldValues != null) 'old_values': oldValues,
      if (newValues != null) 'new_values': newValues,
      if (changedBy != null) 'changed_by': changedBy,
      if (changedAt != null) 'changed_at': changedAt,
      if (ipAddress != null) 'ip_address': ipAddress,
      if (userAgent != null) 'user_agent': userAgent,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AuditLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? targetTable,
    Value<String>? recordId,
    Value<String>? action,
    Value<String?>? oldValues,
    Value<String?>? newValues,
    Value<String?>? changedBy,
    Value<DateTime>? changedAt,
    Value<String?>? ipAddress,
    Value<String?>? userAgent,
    Value<int>? rowid,
  }) {
    return AuditLogsCompanion(
      id: id ?? this.id,
      targetTable: targetTable ?? this.targetTable,
      recordId: recordId ?? this.recordId,
      action: action ?? this.action,
      oldValues: oldValues ?? this.oldValues,
      newValues: newValues ?? this.newValues,
      changedBy: changedBy ?? this.changedBy,
      changedAt: changedAt ?? this.changedAt,
      ipAddress: ipAddress ?? this.ipAddress,
      userAgent: userAgent ?? this.userAgent,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (targetTable.present) {
      map['target_table'] = Variable<String>(targetTable.value);
    }
    if (recordId.present) {
      map['record_id'] = Variable<String>(recordId.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (oldValues.present) {
      map['old_values'] = Variable<String>(oldValues.value);
    }
    if (newValues.present) {
      map['new_values'] = Variable<String>(newValues.value);
    }
    if (changedBy.present) {
      map['changed_by'] = Variable<String>(changedBy.value);
    }
    if (changedAt.present) {
      map['changed_at'] = Variable<DateTime>(changedAt.value);
    }
    if (ipAddress.present) {
      map['ip_address'] = Variable<String>(ipAddress.value);
    }
    if (userAgent.present) {
      map['user_agent'] = Variable<String>(userAgent.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogsCompanion(')
          ..write('id: $id, ')
          ..write('targetTable: $targetTable, ')
          ..write('recordId: $recordId, ')
          ..write('action: $action, ')
          ..write('oldValues: $oldValues, ')
          ..write('newValues: $newValues, ')
          ..write('changedBy: $changedBy, ')
          ..write('changedAt: $changedAt, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('userAgent: $userAgent, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AppSettingsTable extends AppSettings
    with TableInfo<$AppSettingsTable, AppSetting> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AppSettingsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _keyMeta = const VerificationMeta('key');
  @override
  late final GeneratedColumn<String> key = GeneratedColumn<String>(
    'key',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
    'value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [key, value, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'app_settings';
  @override
  VerificationContext validateIntegrity(
    Insertable<AppSetting> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('key')) {
      context.handle(
        _keyMeta,
        key.isAcceptableOrUnknown(data['key']!, _keyMeta),
      );
    } else if (isInserting) {
      context.missing(_keyMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
        _valueMeta,
        value.isAcceptableOrUnknown(data['value']!, _valueMeta),
      );
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {key};
  @override
  AppSetting map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AppSetting(
      key: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}key'],
      )!,
      value: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}value'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $AppSettingsTable createAlias(String alias) {
    return $AppSettingsTable(attachedDatabase, alias);
  }
}

class AppSetting extends DataClass implements Insertable<AppSetting> {
  final String key;
  final String value;
  final DateTime updatedAt;
  const AppSetting({
    required this.key,
    required this.value,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['key'] = Variable<String>(key);
    map['value'] = Variable<String>(value);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  AppSettingsCompanion toCompanion(bool nullToAbsent) {
    return AppSettingsCompanion(
      key: Value(key),
      value: Value(value),
      updatedAt: Value(updatedAt),
    );
  }

  factory AppSetting.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AppSetting(
      key: serializer.fromJson<String>(json['key']),
      value: serializer.fromJson<String>(json['value']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'key': serializer.toJson<String>(key),
      'value': serializer.toJson<String>(value),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  AppSetting copyWith({String? key, String? value, DateTime? updatedAt}) =>
      AppSetting(
        key: key ?? this.key,
        value: value ?? this.value,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  AppSetting copyWithCompanion(AppSettingsCompanion data) {
    return AppSetting(
      key: data.key.present ? data.key.value : this.key,
      value: data.value.present ? data.value.value : this.value,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AppSetting(')
          ..write('key: $key, ')
          ..write('value: $value, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(key, value, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AppSetting &&
          other.key == this.key &&
          other.value == this.value &&
          other.updatedAt == this.updatedAt);
}

class AppSettingsCompanion extends UpdateCompanion<AppSetting> {
  final Value<String> key;
  final Value<String> value;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const AppSettingsCompanion({
    this.key = const Value.absent(),
    this.value = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AppSettingsCompanion.insert({
    required String key,
    required String value,
    required DateTime updatedAt,
    this.rowid = const Value.absent(),
  }) : key = Value(key),
       value = Value(value),
       updatedAt = Value(updatedAt);
  static Insertable<AppSetting> custom({
    Expression<String>? key,
    Expression<String>? value,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (key != null) 'key': key,
      if (value != null) 'value': value,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AppSettingsCompanion copyWith({
    Value<String>? key,
    Value<String>? value,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return AppSettingsCompanion(
      key: key ?? this.key,
      value: value ?? this.value,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (key.present) {
      map['key'] = Variable<String>(key.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AppSettingsCompanion(')
          ..write('key: $key, ')
          ..write('value: $value, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncConflictsTable extends SyncConflicts
    with TableInfo<$SyncConflictsTable, SyncConflict> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncConflictsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localPayloadMeta = const VerificationMeta(
    'localPayload',
  );
  @override
  late final GeneratedColumn<String> localPayload = GeneratedColumn<String>(
    'local_payload',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _serverPayloadMeta = const VerificationMeta(
    'serverPayload',
  );
  @override
  late final GeneratedColumn<String> serverPayload = GeneratedColumn<String>(
    'server_payload',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localUpdatedAtMeta = const VerificationMeta(
    'localUpdatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> localUpdatedAt =
      GeneratedColumn<DateTime>(
        'local_updated_at',
        aliasedName,
        false,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _serverUpdatedAtMeta = const VerificationMeta(
    'serverUpdatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> serverUpdatedAt =
      GeneratedColumn<DateTime>(
        'server_updated_at',
        aliasedName,
        false,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _winnerMeta = const VerificationMeta('winner');
  @override
  late final GeneratedColumn<String> winner = GeneratedColumn<String>(
    'winner',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _resolutionMeta = const VerificationMeta(
    'resolution',
  );
  @override
  late final GeneratedColumn<String> resolution = GeneratedColumn<String>(
    'resolution',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('lww'),
  );
  static const VerificationMeta _detectedAtMeta = const VerificationMeta(
    'detectedAt',
  );
  @override
  late final GeneratedColumn<DateTime> detectedAt = GeneratedColumn<DateTime>(
    'detected_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    localPayload,
    serverPayload,
    localUpdatedAt,
    serverUpdatedAt,
    winner,
    resolution,
    detectedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_conflicts';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncConflict> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('local_payload')) {
      context.handle(
        _localPayloadMeta,
        localPayload.isAcceptableOrUnknown(
          data['local_payload']!,
          _localPayloadMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_localPayloadMeta);
    }
    if (data.containsKey('server_payload')) {
      context.handle(
        _serverPayloadMeta,
        serverPayload.isAcceptableOrUnknown(
          data['server_payload']!,
          _serverPayloadMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_serverPayloadMeta);
    }
    if (data.containsKey('local_updated_at')) {
      context.handle(
        _localUpdatedAtMeta,
        localUpdatedAt.isAcceptableOrUnknown(
          data['local_updated_at']!,
          _localUpdatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_localUpdatedAtMeta);
    }
    if (data.containsKey('server_updated_at')) {
      context.handle(
        _serverUpdatedAtMeta,
        serverUpdatedAt.isAcceptableOrUnknown(
          data['server_updated_at']!,
          _serverUpdatedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_serverUpdatedAtMeta);
    }
    if (data.containsKey('winner')) {
      context.handle(
        _winnerMeta,
        winner.isAcceptableOrUnknown(data['winner']!, _winnerMeta),
      );
    } else if (isInserting) {
      context.missing(_winnerMeta);
    }
    if (data.containsKey('resolution')) {
      context.handle(
        _resolutionMeta,
        resolution.isAcceptableOrUnknown(data['resolution']!, _resolutionMeta),
      );
    }
    if (data.containsKey('detected_at')) {
      context.handle(
        _detectedAtMeta,
        detectedAt.isAcceptableOrUnknown(data['detected_at']!, _detectedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_detectedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncConflict map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncConflict(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      localPayload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}local_payload'],
      )!,
      serverPayload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}server_payload'],
      )!,
      localUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}local_updated_at'],
      )!,
      serverUpdatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}server_updated_at'],
      )!,
      winner: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}winner'],
      )!,
      resolution: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}resolution'],
      )!,
      detectedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}detected_at'],
      )!,
    );
  }

  @override
  $SyncConflictsTable createAlias(String alias) {
    return $SyncConflictsTable(attachedDatabase, alias);
  }
}

class SyncConflict extends DataClass implements Insertable<SyncConflict> {
  final int id;
  final String entityType;
  final String entityId;
  final String localPayload;
  final String serverPayload;
  final DateTime localUpdatedAt;
  final DateTime serverUpdatedAt;
  final String winner;
  final String resolution;
  final DateTime detectedAt;
  const SyncConflict({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.localPayload,
    required this.serverPayload,
    required this.localUpdatedAt,
    required this.serverUpdatedAt,
    required this.winner,
    required this.resolution,
    required this.detectedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['local_payload'] = Variable<String>(localPayload);
    map['server_payload'] = Variable<String>(serverPayload);
    map['local_updated_at'] = Variable<DateTime>(localUpdatedAt);
    map['server_updated_at'] = Variable<DateTime>(serverUpdatedAt);
    map['winner'] = Variable<String>(winner);
    map['resolution'] = Variable<String>(resolution);
    map['detected_at'] = Variable<DateTime>(detectedAt);
    return map;
  }

  SyncConflictsCompanion toCompanion(bool nullToAbsent) {
    return SyncConflictsCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      localPayload: Value(localPayload),
      serverPayload: Value(serverPayload),
      localUpdatedAt: Value(localUpdatedAt),
      serverUpdatedAt: Value(serverUpdatedAt),
      winner: Value(winner),
      resolution: Value(resolution),
      detectedAt: Value(detectedAt),
    );
  }

  factory SyncConflict.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncConflict(
      id: serializer.fromJson<int>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      localPayload: serializer.fromJson<String>(json['localPayload']),
      serverPayload: serializer.fromJson<String>(json['serverPayload']),
      localUpdatedAt: serializer.fromJson<DateTime>(json['localUpdatedAt']),
      serverUpdatedAt: serializer.fromJson<DateTime>(json['serverUpdatedAt']),
      winner: serializer.fromJson<String>(json['winner']),
      resolution: serializer.fromJson<String>(json['resolution']),
      detectedAt: serializer.fromJson<DateTime>(json['detectedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'localPayload': serializer.toJson<String>(localPayload),
      'serverPayload': serializer.toJson<String>(serverPayload),
      'localUpdatedAt': serializer.toJson<DateTime>(localUpdatedAt),
      'serverUpdatedAt': serializer.toJson<DateTime>(serverUpdatedAt),
      'winner': serializer.toJson<String>(winner),
      'resolution': serializer.toJson<String>(resolution),
      'detectedAt': serializer.toJson<DateTime>(detectedAt),
    };
  }

  SyncConflict copyWith({
    int? id,
    String? entityType,
    String? entityId,
    String? localPayload,
    String? serverPayload,
    DateTime? localUpdatedAt,
    DateTime? serverUpdatedAt,
    String? winner,
    String? resolution,
    DateTime? detectedAt,
  }) => SyncConflict(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    localPayload: localPayload ?? this.localPayload,
    serverPayload: serverPayload ?? this.serverPayload,
    localUpdatedAt: localUpdatedAt ?? this.localUpdatedAt,
    serverUpdatedAt: serverUpdatedAt ?? this.serverUpdatedAt,
    winner: winner ?? this.winner,
    resolution: resolution ?? this.resolution,
    detectedAt: detectedAt ?? this.detectedAt,
  );
  SyncConflict copyWithCompanion(SyncConflictsCompanion data) {
    return SyncConflict(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      localPayload: data.localPayload.present
          ? data.localPayload.value
          : this.localPayload,
      serverPayload: data.serverPayload.present
          ? data.serverPayload.value
          : this.serverPayload,
      localUpdatedAt: data.localUpdatedAt.present
          ? data.localUpdatedAt.value
          : this.localUpdatedAt,
      serverUpdatedAt: data.serverUpdatedAt.present
          ? data.serverUpdatedAt.value
          : this.serverUpdatedAt,
      winner: data.winner.present ? data.winner.value : this.winner,
      resolution: data.resolution.present
          ? data.resolution.value
          : this.resolution,
      detectedAt: data.detectedAt.present
          ? data.detectedAt.value
          : this.detectedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncConflict(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('localPayload: $localPayload, ')
          ..write('serverPayload: $serverPayload, ')
          ..write('localUpdatedAt: $localUpdatedAt, ')
          ..write('serverUpdatedAt: $serverUpdatedAt, ')
          ..write('winner: $winner, ')
          ..write('resolution: $resolution, ')
          ..write('detectedAt: $detectedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    localPayload,
    serverPayload,
    localUpdatedAt,
    serverUpdatedAt,
    winner,
    resolution,
    detectedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncConflict &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.localPayload == this.localPayload &&
          other.serverPayload == this.serverPayload &&
          other.localUpdatedAt == this.localUpdatedAt &&
          other.serverUpdatedAt == this.serverUpdatedAt &&
          other.winner == this.winner &&
          other.resolution == this.resolution &&
          other.detectedAt == this.detectedAt);
}

class SyncConflictsCompanion extends UpdateCompanion<SyncConflict> {
  final Value<int> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> localPayload;
  final Value<String> serverPayload;
  final Value<DateTime> localUpdatedAt;
  final Value<DateTime> serverUpdatedAt;
  final Value<String> winner;
  final Value<String> resolution;
  final Value<DateTime> detectedAt;
  const SyncConflictsCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.localPayload = const Value.absent(),
    this.serverPayload = const Value.absent(),
    this.localUpdatedAt = const Value.absent(),
    this.serverUpdatedAt = const Value.absent(),
    this.winner = const Value.absent(),
    this.resolution = const Value.absent(),
    this.detectedAt = const Value.absent(),
  });
  SyncConflictsCompanion.insert({
    this.id = const Value.absent(),
    required String entityType,
    required String entityId,
    required String localPayload,
    required String serverPayload,
    required DateTime localUpdatedAt,
    required DateTime serverUpdatedAt,
    required String winner,
    this.resolution = const Value.absent(),
    required DateTime detectedAt,
  }) : entityType = Value(entityType),
       entityId = Value(entityId),
       localPayload = Value(localPayload),
       serverPayload = Value(serverPayload),
       localUpdatedAt = Value(localUpdatedAt),
       serverUpdatedAt = Value(serverUpdatedAt),
       winner = Value(winner),
       detectedAt = Value(detectedAt);
  static Insertable<SyncConflict> custom({
    Expression<int>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? localPayload,
    Expression<String>? serverPayload,
    Expression<DateTime>? localUpdatedAt,
    Expression<DateTime>? serverUpdatedAt,
    Expression<String>? winner,
    Expression<String>? resolution,
    Expression<DateTime>? detectedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (localPayload != null) 'local_payload': localPayload,
      if (serverPayload != null) 'server_payload': serverPayload,
      if (localUpdatedAt != null) 'local_updated_at': localUpdatedAt,
      if (serverUpdatedAt != null) 'server_updated_at': serverUpdatedAt,
      if (winner != null) 'winner': winner,
      if (resolution != null) 'resolution': resolution,
      if (detectedAt != null) 'detected_at': detectedAt,
    });
  }

  SyncConflictsCompanion copyWith({
    Value<int>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? localPayload,
    Value<String>? serverPayload,
    Value<DateTime>? localUpdatedAt,
    Value<DateTime>? serverUpdatedAt,
    Value<String>? winner,
    Value<String>? resolution,
    Value<DateTime>? detectedAt,
  }) {
    return SyncConflictsCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      localPayload: localPayload ?? this.localPayload,
      serverPayload: serverPayload ?? this.serverPayload,
      localUpdatedAt: localUpdatedAt ?? this.localUpdatedAt,
      serverUpdatedAt: serverUpdatedAt ?? this.serverUpdatedAt,
      winner: winner ?? this.winner,
      resolution: resolution ?? this.resolution,
      detectedAt: detectedAt ?? this.detectedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (localPayload.present) {
      map['local_payload'] = Variable<String>(localPayload.value);
    }
    if (serverPayload.present) {
      map['server_payload'] = Variable<String>(serverPayload.value);
    }
    if (localUpdatedAt.present) {
      map['local_updated_at'] = Variable<DateTime>(localUpdatedAt.value);
    }
    if (serverUpdatedAt.present) {
      map['server_updated_at'] = Variable<DateTime>(serverUpdatedAt.value);
    }
    if (winner.present) {
      map['winner'] = Variable<String>(winner.value);
    }
    if (resolution.present) {
      map['resolution'] = Variable<String>(resolution.value);
    }
    if (detectedAt.present) {
      map['detected_at'] = Variable<DateTime>(detectedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncConflictsCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('localPayload: $localPayload, ')
          ..write('serverPayload: $serverPayload, ')
          ..write('localUpdatedAt: $localUpdatedAt, ')
          ..write('serverUpdatedAt: $serverUpdatedAt, ')
          ..write('winner: $winner, ')
          ..write('resolution: $resolution, ')
          ..write('detectedAt: $detectedAt')
          ..write(')'))
        .toString();
  }
}

class $PipelineStageHistoryItemsTable extends PipelineStageHistoryItems
    with TableInfo<$PipelineStageHistoryItemsTable, PipelineStageHistoryItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PipelineStageHistoryItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _pipelineIdMeta = const VerificationMeta(
    'pipelineId',
  );
  @override
  late final GeneratedColumn<String> pipelineId = GeneratedColumn<String>(
    'pipeline_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fromStageIdMeta = const VerificationMeta(
    'fromStageId',
  );
  @override
  late final GeneratedColumn<String> fromStageId = GeneratedColumn<String>(
    'from_stage_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _toStageIdMeta = const VerificationMeta(
    'toStageId',
  );
  @override
  late final GeneratedColumn<String> toStageId = GeneratedColumn<String>(
    'to_stage_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fromStatusIdMeta = const VerificationMeta(
    'fromStatusId',
  );
  @override
  late final GeneratedColumn<String> fromStatusId = GeneratedColumn<String>(
    'from_status_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _toStatusIdMeta = const VerificationMeta(
    'toStatusId',
  );
  @override
  late final GeneratedColumn<String> toStatusId = GeneratedColumn<String>(
    'to_status_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _changedByMeta = const VerificationMeta(
    'changedBy',
  );
  @override
  late final GeneratedColumn<String> changedBy = GeneratedColumn<String>(
    'changed_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _changedAtMeta = const VerificationMeta(
    'changedAt',
  );
  @override
  late final GeneratedColumn<DateTime> changedAt = GeneratedColumn<DateTime>(
    'changed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cachedAtMeta = const VerificationMeta(
    'cachedAt',
  );
  @override
  late final GeneratedColumn<DateTime> cachedAt = GeneratedColumn<DateTime>(
    'cached_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isPendingSyncMeta = const VerificationMeta(
    'isPendingSync',
  );
  @override
  late final GeneratedColumn<bool> isPendingSync = GeneratedColumn<bool>(
    'is_pending_sync',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_pending_sync" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdLocallyMeta = const VerificationMeta(
    'createdLocally',
  );
  @override
  late final GeneratedColumn<bool> createdLocally = GeneratedColumn<bool>(
    'created_locally',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("created_locally" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lastSyncAtMeta = const VerificationMeta(
    'lastSyncAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAt = GeneratedColumn<DateTime>(
    'last_sync_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    pipelineId,
    fromStageId,
    toStageId,
    fromStatusId,
    toStatusId,
    notes,
    changedBy,
    changedAt,
    latitude,
    longitude,
    cachedAt,
    isPendingSync,
    createdLocally,
    lastSyncAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pipeline_stage_history_cache';
  @override
  VerificationContext validateIntegrity(
    Insertable<PipelineStageHistoryItem> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('pipeline_id')) {
      context.handle(
        _pipelineIdMeta,
        pipelineId.isAcceptableOrUnknown(data['pipeline_id']!, _pipelineIdMeta),
      );
    } else if (isInserting) {
      context.missing(_pipelineIdMeta);
    }
    if (data.containsKey('from_stage_id')) {
      context.handle(
        _fromStageIdMeta,
        fromStageId.isAcceptableOrUnknown(
          data['from_stage_id']!,
          _fromStageIdMeta,
        ),
      );
    }
    if (data.containsKey('to_stage_id')) {
      context.handle(
        _toStageIdMeta,
        toStageId.isAcceptableOrUnknown(data['to_stage_id']!, _toStageIdMeta),
      );
    } else if (isInserting) {
      context.missing(_toStageIdMeta);
    }
    if (data.containsKey('from_status_id')) {
      context.handle(
        _fromStatusIdMeta,
        fromStatusId.isAcceptableOrUnknown(
          data['from_status_id']!,
          _fromStatusIdMeta,
        ),
      );
    }
    if (data.containsKey('to_status_id')) {
      context.handle(
        _toStatusIdMeta,
        toStatusId.isAcceptableOrUnknown(
          data['to_status_id']!,
          _toStatusIdMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('changed_by')) {
      context.handle(
        _changedByMeta,
        changedBy.isAcceptableOrUnknown(data['changed_by']!, _changedByMeta),
      );
    }
    if (data.containsKey('changed_at')) {
      context.handle(
        _changedAtMeta,
        changedAt.isAcceptableOrUnknown(data['changed_at']!, _changedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_changedAtMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('cached_at')) {
      context.handle(
        _cachedAtMeta,
        cachedAt.isAcceptableOrUnknown(data['cached_at']!, _cachedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_cachedAtMeta);
    }
    if (data.containsKey('is_pending_sync')) {
      context.handle(
        _isPendingSyncMeta,
        isPendingSync.isAcceptableOrUnknown(
          data['is_pending_sync']!,
          _isPendingSyncMeta,
        ),
      );
    }
    if (data.containsKey('created_locally')) {
      context.handle(
        _createdLocallyMeta,
        createdLocally.isAcceptableOrUnknown(
          data['created_locally']!,
          _createdLocallyMeta,
        ),
      );
    }
    if (data.containsKey('last_sync_at')) {
      context.handle(
        _lastSyncAtMeta,
        lastSyncAt.isAcceptableOrUnknown(
          data['last_sync_at']!,
          _lastSyncAtMeta,
        ),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PipelineStageHistoryItem map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PipelineStageHistoryItem(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      pipelineId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}pipeline_id'],
      )!,
      fromStageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}from_stage_id'],
      ),
      toStageId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}to_stage_id'],
      )!,
      fromStatusId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}from_status_id'],
      ),
      toStatusId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}to_status_id'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      changedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}changed_by'],
      ),
      changedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}changed_at'],
      )!,
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      cachedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}cached_at'],
      )!,
      isPendingSync: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_pending_sync'],
      )!,
      createdLocally: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}created_locally'],
      )!,
      lastSyncAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_at'],
      ),
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $PipelineStageHistoryItemsTable createAlias(String alias) {
    return $PipelineStageHistoryItemsTable(attachedDatabase, alias);
  }
}

class PipelineStageHistoryItem extends DataClass
    implements Insertable<PipelineStageHistoryItem> {
  final String id;
  final String pipelineId;
  final String? fromStageId;
  final String toStageId;
  final String? fromStatusId;
  final String? toStatusId;
  final String? notes;
  final String? changedBy;
  final DateTime changedAt;
  final double? latitude;
  final double? longitude;
  final DateTime cachedAt;
  final bool isPendingSync;
  final bool createdLocally;
  final DateTime? lastSyncAt;
  final DateTime? updatedAt;
  const PipelineStageHistoryItem({
    required this.id,
    required this.pipelineId,
    this.fromStageId,
    required this.toStageId,
    this.fromStatusId,
    this.toStatusId,
    this.notes,
    this.changedBy,
    required this.changedAt,
    this.latitude,
    this.longitude,
    required this.cachedAt,
    required this.isPendingSync,
    required this.createdLocally,
    this.lastSyncAt,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['pipeline_id'] = Variable<String>(pipelineId);
    if (!nullToAbsent || fromStageId != null) {
      map['from_stage_id'] = Variable<String>(fromStageId);
    }
    map['to_stage_id'] = Variable<String>(toStageId);
    if (!nullToAbsent || fromStatusId != null) {
      map['from_status_id'] = Variable<String>(fromStatusId);
    }
    if (!nullToAbsent || toStatusId != null) {
      map['to_status_id'] = Variable<String>(toStatusId);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || changedBy != null) {
      map['changed_by'] = Variable<String>(changedBy);
    }
    map['changed_at'] = Variable<DateTime>(changedAt);
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    map['cached_at'] = Variable<DateTime>(cachedAt);
    map['is_pending_sync'] = Variable<bool>(isPendingSync);
    map['created_locally'] = Variable<bool>(createdLocally);
    if (!nullToAbsent || lastSyncAt != null) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt);
    }
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  PipelineStageHistoryItemsCompanion toCompanion(bool nullToAbsent) {
    return PipelineStageHistoryItemsCompanion(
      id: Value(id),
      pipelineId: Value(pipelineId),
      fromStageId: fromStageId == null && nullToAbsent
          ? const Value.absent()
          : Value(fromStageId),
      toStageId: Value(toStageId),
      fromStatusId: fromStatusId == null && nullToAbsent
          ? const Value.absent()
          : Value(fromStatusId),
      toStatusId: toStatusId == null && nullToAbsent
          ? const Value.absent()
          : Value(toStatusId),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      changedBy: changedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(changedBy),
      changedAt: Value(changedAt),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      cachedAt: Value(cachedAt),
      isPendingSync: Value(isPendingSync),
      createdLocally: Value(createdLocally),
      lastSyncAt: lastSyncAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory PipelineStageHistoryItem.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PipelineStageHistoryItem(
      id: serializer.fromJson<String>(json['id']),
      pipelineId: serializer.fromJson<String>(json['pipelineId']),
      fromStageId: serializer.fromJson<String?>(json['fromStageId']),
      toStageId: serializer.fromJson<String>(json['toStageId']),
      fromStatusId: serializer.fromJson<String?>(json['fromStatusId']),
      toStatusId: serializer.fromJson<String?>(json['toStatusId']),
      notes: serializer.fromJson<String?>(json['notes']),
      changedBy: serializer.fromJson<String?>(json['changedBy']),
      changedAt: serializer.fromJson<DateTime>(json['changedAt']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      cachedAt: serializer.fromJson<DateTime>(json['cachedAt']),
      isPendingSync: serializer.fromJson<bool>(json['isPendingSync']),
      createdLocally: serializer.fromJson<bool>(json['createdLocally']),
      lastSyncAt: serializer.fromJson<DateTime?>(json['lastSyncAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'pipelineId': serializer.toJson<String>(pipelineId),
      'fromStageId': serializer.toJson<String?>(fromStageId),
      'toStageId': serializer.toJson<String>(toStageId),
      'fromStatusId': serializer.toJson<String?>(fromStatusId),
      'toStatusId': serializer.toJson<String?>(toStatusId),
      'notes': serializer.toJson<String?>(notes),
      'changedBy': serializer.toJson<String?>(changedBy),
      'changedAt': serializer.toJson<DateTime>(changedAt),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'cachedAt': serializer.toJson<DateTime>(cachedAt),
      'isPendingSync': serializer.toJson<bool>(isPendingSync),
      'createdLocally': serializer.toJson<bool>(createdLocally),
      'lastSyncAt': serializer.toJson<DateTime?>(lastSyncAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  PipelineStageHistoryItem copyWith({
    String? id,
    String? pipelineId,
    Value<String?> fromStageId = const Value.absent(),
    String? toStageId,
    Value<String?> fromStatusId = const Value.absent(),
    Value<String?> toStatusId = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<String?> changedBy = const Value.absent(),
    DateTime? changedAt,
    Value<double?> latitude = const Value.absent(),
    Value<double?> longitude = const Value.absent(),
    DateTime? cachedAt,
    bool? isPendingSync,
    bool? createdLocally,
    Value<DateTime?> lastSyncAt = const Value.absent(),
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => PipelineStageHistoryItem(
    id: id ?? this.id,
    pipelineId: pipelineId ?? this.pipelineId,
    fromStageId: fromStageId.present ? fromStageId.value : this.fromStageId,
    toStageId: toStageId ?? this.toStageId,
    fromStatusId: fromStatusId.present ? fromStatusId.value : this.fromStatusId,
    toStatusId: toStatusId.present ? toStatusId.value : this.toStatusId,
    notes: notes.present ? notes.value : this.notes,
    changedBy: changedBy.present ? changedBy.value : this.changedBy,
    changedAt: changedAt ?? this.changedAt,
    latitude: latitude.present ? latitude.value : this.latitude,
    longitude: longitude.present ? longitude.value : this.longitude,
    cachedAt: cachedAt ?? this.cachedAt,
    isPendingSync: isPendingSync ?? this.isPendingSync,
    createdLocally: createdLocally ?? this.createdLocally,
    lastSyncAt: lastSyncAt.present ? lastSyncAt.value : this.lastSyncAt,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  PipelineStageHistoryItem copyWithCompanion(
    PipelineStageHistoryItemsCompanion data,
  ) {
    return PipelineStageHistoryItem(
      id: data.id.present ? data.id.value : this.id,
      pipelineId: data.pipelineId.present
          ? data.pipelineId.value
          : this.pipelineId,
      fromStageId: data.fromStageId.present
          ? data.fromStageId.value
          : this.fromStageId,
      toStageId: data.toStageId.present ? data.toStageId.value : this.toStageId,
      fromStatusId: data.fromStatusId.present
          ? data.fromStatusId.value
          : this.fromStatusId,
      toStatusId: data.toStatusId.present
          ? data.toStatusId.value
          : this.toStatusId,
      notes: data.notes.present ? data.notes.value : this.notes,
      changedBy: data.changedBy.present ? data.changedBy.value : this.changedBy,
      changedAt: data.changedAt.present ? data.changedAt.value : this.changedAt,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      cachedAt: data.cachedAt.present ? data.cachedAt.value : this.cachedAt,
      isPendingSync: data.isPendingSync.present
          ? data.isPendingSync.value
          : this.isPendingSync,
      createdLocally: data.createdLocally.present
          ? data.createdLocally.value
          : this.createdLocally,
      lastSyncAt: data.lastSyncAt.present
          ? data.lastSyncAt.value
          : this.lastSyncAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PipelineStageHistoryItem(')
          ..write('id: $id, ')
          ..write('pipelineId: $pipelineId, ')
          ..write('fromStageId: $fromStageId, ')
          ..write('toStageId: $toStageId, ')
          ..write('fromStatusId: $fromStatusId, ')
          ..write('toStatusId: $toStatusId, ')
          ..write('notes: $notes, ')
          ..write('changedBy: $changedBy, ')
          ..write('changedAt: $changedAt, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('cachedAt: $cachedAt, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdLocally: $createdLocally, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    pipelineId,
    fromStageId,
    toStageId,
    fromStatusId,
    toStatusId,
    notes,
    changedBy,
    changedAt,
    latitude,
    longitude,
    cachedAt,
    isPendingSync,
    createdLocally,
    lastSyncAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PipelineStageHistoryItem &&
          other.id == this.id &&
          other.pipelineId == this.pipelineId &&
          other.fromStageId == this.fromStageId &&
          other.toStageId == this.toStageId &&
          other.fromStatusId == this.fromStatusId &&
          other.toStatusId == this.toStatusId &&
          other.notes == this.notes &&
          other.changedBy == this.changedBy &&
          other.changedAt == this.changedAt &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.cachedAt == this.cachedAt &&
          other.isPendingSync == this.isPendingSync &&
          other.createdLocally == this.createdLocally &&
          other.lastSyncAt == this.lastSyncAt &&
          other.updatedAt == this.updatedAt);
}

class PipelineStageHistoryItemsCompanion
    extends UpdateCompanion<PipelineStageHistoryItem> {
  final Value<String> id;
  final Value<String> pipelineId;
  final Value<String?> fromStageId;
  final Value<String> toStageId;
  final Value<String?> fromStatusId;
  final Value<String?> toStatusId;
  final Value<String?> notes;
  final Value<String?> changedBy;
  final Value<DateTime> changedAt;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<DateTime> cachedAt;
  final Value<bool> isPendingSync;
  final Value<bool> createdLocally;
  final Value<DateTime?> lastSyncAt;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const PipelineStageHistoryItemsCompanion({
    this.id = const Value.absent(),
    this.pipelineId = const Value.absent(),
    this.fromStageId = const Value.absent(),
    this.toStageId = const Value.absent(),
    this.fromStatusId = const Value.absent(),
    this.toStatusId = const Value.absent(),
    this.notes = const Value.absent(),
    this.changedBy = const Value.absent(),
    this.changedAt = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.cachedAt = const Value.absent(),
    this.isPendingSync = const Value.absent(),
    this.createdLocally = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PipelineStageHistoryItemsCompanion.insert({
    required String id,
    required String pipelineId,
    this.fromStageId = const Value.absent(),
    required String toStageId,
    this.fromStatusId = const Value.absent(),
    this.toStatusId = const Value.absent(),
    this.notes = const Value.absent(),
    this.changedBy = const Value.absent(),
    required DateTime changedAt,
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    required DateTime cachedAt,
    this.isPendingSync = const Value.absent(),
    this.createdLocally = const Value.absent(),
    this.lastSyncAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       pipelineId = Value(pipelineId),
       toStageId = Value(toStageId),
       changedAt = Value(changedAt),
       cachedAt = Value(cachedAt);
  static Insertable<PipelineStageHistoryItem> custom({
    Expression<String>? id,
    Expression<String>? pipelineId,
    Expression<String>? fromStageId,
    Expression<String>? toStageId,
    Expression<String>? fromStatusId,
    Expression<String>? toStatusId,
    Expression<String>? notes,
    Expression<String>? changedBy,
    Expression<DateTime>? changedAt,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<DateTime>? cachedAt,
    Expression<bool>? isPendingSync,
    Expression<bool>? createdLocally,
    Expression<DateTime>? lastSyncAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (pipelineId != null) 'pipeline_id': pipelineId,
      if (fromStageId != null) 'from_stage_id': fromStageId,
      if (toStageId != null) 'to_stage_id': toStageId,
      if (fromStatusId != null) 'from_status_id': fromStatusId,
      if (toStatusId != null) 'to_status_id': toStatusId,
      if (notes != null) 'notes': notes,
      if (changedBy != null) 'changed_by': changedBy,
      if (changedAt != null) 'changed_at': changedAt,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (cachedAt != null) 'cached_at': cachedAt,
      if (isPendingSync != null) 'is_pending_sync': isPendingSync,
      if (createdLocally != null) 'created_locally': createdLocally,
      if (lastSyncAt != null) 'last_sync_at': lastSyncAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PipelineStageHistoryItemsCompanion copyWith({
    Value<String>? id,
    Value<String>? pipelineId,
    Value<String?>? fromStageId,
    Value<String>? toStageId,
    Value<String?>? fromStatusId,
    Value<String?>? toStatusId,
    Value<String?>? notes,
    Value<String?>? changedBy,
    Value<DateTime>? changedAt,
    Value<double?>? latitude,
    Value<double?>? longitude,
    Value<DateTime>? cachedAt,
    Value<bool>? isPendingSync,
    Value<bool>? createdLocally,
    Value<DateTime?>? lastSyncAt,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return PipelineStageHistoryItemsCompanion(
      id: id ?? this.id,
      pipelineId: pipelineId ?? this.pipelineId,
      fromStageId: fromStageId ?? this.fromStageId,
      toStageId: toStageId ?? this.toStageId,
      fromStatusId: fromStatusId ?? this.fromStatusId,
      toStatusId: toStatusId ?? this.toStatusId,
      notes: notes ?? this.notes,
      changedBy: changedBy ?? this.changedBy,
      changedAt: changedAt ?? this.changedAt,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      cachedAt: cachedAt ?? this.cachedAt,
      isPendingSync: isPendingSync ?? this.isPendingSync,
      createdLocally: createdLocally ?? this.createdLocally,
      lastSyncAt: lastSyncAt ?? this.lastSyncAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (pipelineId.present) {
      map['pipeline_id'] = Variable<String>(pipelineId.value);
    }
    if (fromStageId.present) {
      map['from_stage_id'] = Variable<String>(fromStageId.value);
    }
    if (toStageId.present) {
      map['to_stage_id'] = Variable<String>(toStageId.value);
    }
    if (fromStatusId.present) {
      map['from_status_id'] = Variable<String>(fromStatusId.value);
    }
    if (toStatusId.present) {
      map['to_status_id'] = Variable<String>(toStatusId.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (changedBy.present) {
      map['changed_by'] = Variable<String>(changedBy.value);
    }
    if (changedAt.present) {
      map['changed_at'] = Variable<DateTime>(changedAt.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (cachedAt.present) {
      map['cached_at'] = Variable<DateTime>(cachedAt.value);
    }
    if (isPendingSync.present) {
      map['is_pending_sync'] = Variable<bool>(isPendingSync.value);
    }
    if (createdLocally.present) {
      map['created_locally'] = Variable<bool>(createdLocally.value);
    }
    if (lastSyncAt.present) {
      map['last_sync_at'] = Variable<DateTime>(lastSyncAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PipelineStageHistoryItemsCompanion(')
          ..write('id: $id, ')
          ..write('pipelineId: $pipelineId, ')
          ..write('fromStageId: $fromStageId, ')
          ..write('toStageId: $toStageId, ')
          ..write('fromStatusId: $fromStatusId, ')
          ..write('toStatusId: $toStatusId, ')
          ..write('notes: $notes, ')
          ..write('changedBy: $changedBy, ')
          ..write('changedAt: $changedAt, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('cachedAt: $cachedAt, ')
          ..write('isPendingSync: $isPendingSync, ')
          ..write('createdLocally: $createdLocally, ')
          ..write('lastSyncAt: $lastSyncAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AuditLogCacheTable extends AuditLogCache
    with TableInfo<$AuditLogCacheTable, AuditLogCacheData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AuditLogCacheTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userEmailMeta = const VerificationMeta(
    'userEmail',
  );
  @override
  late final GeneratedColumn<String> userEmail = GeneratedColumn<String>(
    'user_email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetTableMeta = const VerificationMeta(
    'targetTable',
  );
  @override
  late final GeneratedColumn<String> targetTable = GeneratedColumn<String>(
    'target_table',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetIdMeta = const VerificationMeta(
    'targetId',
  );
  @override
  late final GeneratedColumn<String> targetId = GeneratedColumn<String>(
    'target_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _oldValuesMeta = const VerificationMeta(
    'oldValues',
  );
  @override
  late final GeneratedColumn<String> oldValues = GeneratedColumn<String>(
    'old_values',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _newValuesMeta = const VerificationMeta(
    'newValues',
  );
  @override
  late final GeneratedColumn<String> newValues = GeneratedColumn<String>(
    'new_values',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ipAddressMeta = const VerificationMeta(
    'ipAddress',
  );
  @override
  late final GeneratedColumn<String> ipAddress = GeneratedColumn<String>(
    'ip_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _userAgentMeta = const VerificationMeta(
    'userAgent',
  );
  @override
  late final GeneratedColumn<String> userAgent = GeneratedColumn<String>(
    'user_agent',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _cachedAtMeta = const VerificationMeta(
    'cachedAt',
  );
  @override
  late final GeneratedColumn<DateTime> cachedAt = GeneratedColumn<DateTime>(
    'cached_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    userEmail,
    action,
    targetTable,
    targetId,
    oldValues,
    newValues,
    ipAddress,
    userAgent,
    createdAt,
    cachedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_log_cache';
  @override
  VerificationContext validateIntegrity(
    Insertable<AuditLogCacheData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    }
    if (data.containsKey('user_email')) {
      context.handle(
        _userEmailMeta,
        userEmail.isAcceptableOrUnknown(data['user_email']!, _userEmailMeta),
      );
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('target_table')) {
      context.handle(
        _targetTableMeta,
        targetTable.isAcceptableOrUnknown(
          data['target_table']!,
          _targetTableMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetTableMeta);
    }
    if (data.containsKey('target_id')) {
      context.handle(
        _targetIdMeta,
        targetId.isAcceptableOrUnknown(data['target_id']!, _targetIdMeta),
      );
    } else if (isInserting) {
      context.missing(_targetIdMeta);
    }
    if (data.containsKey('old_values')) {
      context.handle(
        _oldValuesMeta,
        oldValues.isAcceptableOrUnknown(data['old_values']!, _oldValuesMeta),
      );
    }
    if (data.containsKey('new_values')) {
      context.handle(
        _newValuesMeta,
        newValues.isAcceptableOrUnknown(data['new_values']!, _newValuesMeta),
      );
    }
    if (data.containsKey('ip_address')) {
      context.handle(
        _ipAddressMeta,
        ipAddress.isAcceptableOrUnknown(data['ip_address']!, _ipAddressMeta),
      );
    }
    if (data.containsKey('user_agent')) {
      context.handle(
        _userAgentMeta,
        userAgent.isAcceptableOrUnknown(data['user_agent']!, _userAgentMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('cached_at')) {
      context.handle(
        _cachedAtMeta,
        cachedAt.isAcceptableOrUnknown(data['cached_at']!, _cachedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_cachedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AuditLogCacheData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditLogCacheData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      ),
      userEmail: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_email'],
      ),
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      targetTable: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_table'],
      )!,
      targetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_id'],
      )!,
      oldValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}old_values'],
      ),
      newValues: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}new_values'],
      ),
      ipAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ip_address'],
      ),
      userAgent: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_agent'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      cachedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}cached_at'],
      )!,
    );
  }

  @override
  $AuditLogCacheTable createAlias(String alias) {
    return $AuditLogCacheTable(attachedDatabase, alias);
  }
}

class AuditLogCacheData extends DataClass
    implements Insertable<AuditLogCacheData> {
  final String id;
  final String? userId;
  final String? userEmail;
  final String action;
  final String targetTable;
  final String targetId;
  final String? oldValues;
  final String? newValues;
  final String? ipAddress;
  final String? userAgent;
  final DateTime createdAt;
  final DateTime cachedAt;
  const AuditLogCacheData({
    required this.id,
    this.userId,
    this.userEmail,
    required this.action,
    required this.targetTable,
    required this.targetId,
    this.oldValues,
    this.newValues,
    this.ipAddress,
    this.userAgent,
    required this.createdAt,
    required this.cachedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || userEmail != null) {
      map['user_email'] = Variable<String>(userEmail);
    }
    map['action'] = Variable<String>(action);
    map['target_table'] = Variable<String>(targetTable);
    map['target_id'] = Variable<String>(targetId);
    if (!nullToAbsent || oldValues != null) {
      map['old_values'] = Variable<String>(oldValues);
    }
    if (!nullToAbsent || newValues != null) {
      map['new_values'] = Variable<String>(newValues);
    }
    if (!nullToAbsent || ipAddress != null) {
      map['ip_address'] = Variable<String>(ipAddress);
    }
    if (!nullToAbsent || userAgent != null) {
      map['user_agent'] = Variable<String>(userAgent);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['cached_at'] = Variable<DateTime>(cachedAt);
    return map;
  }

  AuditLogCacheCompanion toCompanion(bool nullToAbsent) {
    return AuditLogCacheCompanion(
      id: Value(id),
      userId: userId == null && nullToAbsent
          ? const Value.absent()
          : Value(userId),
      userEmail: userEmail == null && nullToAbsent
          ? const Value.absent()
          : Value(userEmail),
      action: Value(action),
      targetTable: Value(targetTable),
      targetId: Value(targetId),
      oldValues: oldValues == null && nullToAbsent
          ? const Value.absent()
          : Value(oldValues),
      newValues: newValues == null && nullToAbsent
          ? const Value.absent()
          : Value(newValues),
      ipAddress: ipAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(ipAddress),
      userAgent: userAgent == null && nullToAbsent
          ? const Value.absent()
          : Value(userAgent),
      createdAt: Value(createdAt),
      cachedAt: Value(cachedAt),
    );
  }

  factory AuditLogCacheData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditLogCacheData(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String?>(json['userId']),
      userEmail: serializer.fromJson<String?>(json['userEmail']),
      action: serializer.fromJson<String>(json['action']),
      targetTable: serializer.fromJson<String>(json['targetTable']),
      targetId: serializer.fromJson<String>(json['targetId']),
      oldValues: serializer.fromJson<String?>(json['oldValues']),
      newValues: serializer.fromJson<String?>(json['newValues']),
      ipAddress: serializer.fromJson<String?>(json['ipAddress']),
      userAgent: serializer.fromJson<String?>(json['userAgent']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      cachedAt: serializer.fromJson<DateTime>(json['cachedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String?>(userId),
      'userEmail': serializer.toJson<String?>(userEmail),
      'action': serializer.toJson<String>(action),
      'targetTable': serializer.toJson<String>(targetTable),
      'targetId': serializer.toJson<String>(targetId),
      'oldValues': serializer.toJson<String?>(oldValues),
      'newValues': serializer.toJson<String?>(newValues),
      'ipAddress': serializer.toJson<String?>(ipAddress),
      'userAgent': serializer.toJson<String?>(userAgent),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'cachedAt': serializer.toJson<DateTime>(cachedAt),
    };
  }

  AuditLogCacheData copyWith({
    String? id,
    Value<String?> userId = const Value.absent(),
    Value<String?> userEmail = const Value.absent(),
    String? action,
    String? targetTable,
    String? targetId,
    Value<String?> oldValues = const Value.absent(),
    Value<String?> newValues = const Value.absent(),
    Value<String?> ipAddress = const Value.absent(),
    Value<String?> userAgent = const Value.absent(),
    DateTime? createdAt,
    DateTime? cachedAt,
  }) => AuditLogCacheData(
    id: id ?? this.id,
    userId: userId.present ? userId.value : this.userId,
    userEmail: userEmail.present ? userEmail.value : this.userEmail,
    action: action ?? this.action,
    targetTable: targetTable ?? this.targetTable,
    targetId: targetId ?? this.targetId,
    oldValues: oldValues.present ? oldValues.value : this.oldValues,
    newValues: newValues.present ? newValues.value : this.newValues,
    ipAddress: ipAddress.present ? ipAddress.value : this.ipAddress,
    userAgent: userAgent.present ? userAgent.value : this.userAgent,
    createdAt: createdAt ?? this.createdAt,
    cachedAt: cachedAt ?? this.cachedAt,
  );
  AuditLogCacheData copyWithCompanion(AuditLogCacheCompanion data) {
    return AuditLogCacheData(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      userEmail: data.userEmail.present ? data.userEmail.value : this.userEmail,
      action: data.action.present ? data.action.value : this.action,
      targetTable: data.targetTable.present
          ? data.targetTable.value
          : this.targetTable,
      targetId: data.targetId.present ? data.targetId.value : this.targetId,
      oldValues: data.oldValues.present ? data.oldValues.value : this.oldValues,
      newValues: data.newValues.present ? data.newValues.value : this.newValues,
      ipAddress: data.ipAddress.present ? data.ipAddress.value : this.ipAddress,
      userAgent: data.userAgent.present ? data.userAgent.value : this.userAgent,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      cachedAt: data.cachedAt.present ? data.cachedAt.value : this.cachedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogCacheData(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('userEmail: $userEmail, ')
          ..write('action: $action, ')
          ..write('targetTable: $targetTable, ')
          ..write('targetId: $targetId, ')
          ..write('oldValues: $oldValues, ')
          ..write('newValues: $newValues, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('userAgent: $userAgent, ')
          ..write('createdAt: $createdAt, ')
          ..write('cachedAt: $cachedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    userEmail,
    action,
    targetTable,
    targetId,
    oldValues,
    newValues,
    ipAddress,
    userAgent,
    createdAt,
    cachedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditLogCacheData &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.userEmail == this.userEmail &&
          other.action == this.action &&
          other.targetTable == this.targetTable &&
          other.targetId == this.targetId &&
          other.oldValues == this.oldValues &&
          other.newValues == this.newValues &&
          other.ipAddress == this.ipAddress &&
          other.userAgent == this.userAgent &&
          other.createdAt == this.createdAt &&
          other.cachedAt == this.cachedAt);
}

class AuditLogCacheCompanion extends UpdateCompanion<AuditLogCacheData> {
  final Value<String> id;
  final Value<String?> userId;
  final Value<String?> userEmail;
  final Value<String> action;
  final Value<String> targetTable;
  final Value<String> targetId;
  final Value<String?> oldValues;
  final Value<String?> newValues;
  final Value<String?> ipAddress;
  final Value<String?> userAgent;
  final Value<DateTime> createdAt;
  final Value<DateTime> cachedAt;
  final Value<int> rowid;
  const AuditLogCacheCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.userEmail = const Value.absent(),
    this.action = const Value.absent(),
    this.targetTable = const Value.absent(),
    this.targetId = const Value.absent(),
    this.oldValues = const Value.absent(),
    this.newValues = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.userAgent = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.cachedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AuditLogCacheCompanion.insert({
    required String id,
    this.userId = const Value.absent(),
    this.userEmail = const Value.absent(),
    required String action,
    required String targetTable,
    required String targetId,
    this.oldValues = const Value.absent(),
    this.newValues = const Value.absent(),
    this.ipAddress = const Value.absent(),
    this.userAgent = const Value.absent(),
    required DateTime createdAt,
    required DateTime cachedAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       action = Value(action),
       targetTable = Value(targetTable),
       targetId = Value(targetId),
       createdAt = Value(createdAt),
       cachedAt = Value(cachedAt);
  static Insertable<AuditLogCacheData> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? userEmail,
    Expression<String>? action,
    Expression<String>? targetTable,
    Expression<String>? targetId,
    Expression<String>? oldValues,
    Expression<String>? newValues,
    Expression<String>? ipAddress,
    Expression<String>? userAgent,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? cachedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (userEmail != null) 'user_email': userEmail,
      if (action != null) 'action': action,
      if (targetTable != null) 'target_table': targetTable,
      if (targetId != null) 'target_id': targetId,
      if (oldValues != null) 'old_values': oldValues,
      if (newValues != null) 'new_values': newValues,
      if (ipAddress != null) 'ip_address': ipAddress,
      if (userAgent != null) 'user_agent': userAgent,
      if (createdAt != null) 'created_at': createdAt,
      if (cachedAt != null) 'cached_at': cachedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AuditLogCacheCompanion copyWith({
    Value<String>? id,
    Value<String?>? userId,
    Value<String?>? userEmail,
    Value<String>? action,
    Value<String>? targetTable,
    Value<String>? targetId,
    Value<String?>? oldValues,
    Value<String?>? newValues,
    Value<String?>? ipAddress,
    Value<String?>? userAgent,
    Value<DateTime>? createdAt,
    Value<DateTime>? cachedAt,
    Value<int>? rowid,
  }) {
    return AuditLogCacheCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      userEmail: userEmail ?? this.userEmail,
      action: action ?? this.action,
      targetTable: targetTable ?? this.targetTable,
      targetId: targetId ?? this.targetId,
      oldValues: oldValues ?? this.oldValues,
      newValues: newValues ?? this.newValues,
      ipAddress: ipAddress ?? this.ipAddress,
      userAgent: userAgent ?? this.userAgent,
      createdAt: createdAt ?? this.createdAt,
      cachedAt: cachedAt ?? this.cachedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (userEmail.present) {
      map['user_email'] = Variable<String>(userEmail.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (targetTable.present) {
      map['target_table'] = Variable<String>(targetTable.value);
    }
    if (targetId.present) {
      map['target_id'] = Variable<String>(targetId.value);
    }
    if (oldValues.present) {
      map['old_values'] = Variable<String>(oldValues.value);
    }
    if (newValues.present) {
      map['new_values'] = Variable<String>(newValues.value);
    }
    if (ipAddress.present) {
      map['ip_address'] = Variable<String>(ipAddress.value);
    }
    if (userAgent.present) {
      map['user_agent'] = Variable<String>(userAgent.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (cachedAt.present) {
      map['cached_at'] = Variable<DateTime>(cachedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogCacheCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('userEmail: $userEmail, ')
          ..write('action: $action, ')
          ..write('targetTable: $targetTable, ')
          ..write('targetId: $targetId, ')
          ..write('oldValues: $oldValues, ')
          ..write('newValues: $newValues, ')
          ..write('ipAddress: $ipAddress, ')
          ..write('userAgent: $userAgent, ')
          ..write('createdAt: $createdAt, ')
          ..write('cachedAt: $cachedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $RegionalOfficesTable regionalOffices = $RegionalOfficesTable(
    this,
  );
  late final $BranchesTable branches = $BranchesTable(this);
  late final $UsersTable users = $UsersTable(this);
  late final $UserHierarchyTable userHierarchy = $UserHierarchyTable(this);
  late final $ProvincesTable provinces = $ProvincesTable(this);
  late final $CitiesTable cities = $CitiesTable(this);
  late final $CompanyTypesTable companyTypes = $CompanyTypesTable(this);
  late final $OwnershipTypesTable ownershipTypes = $OwnershipTypesTable(this);
  late final $IndustriesTable industries = $IndustriesTable(this);
  late final $CobsTable cobs = $CobsTable(this);
  late final $LobsTable lobs = $LobsTable(this);
  late final $PipelineStagesTable pipelineStages = $PipelineStagesTable(this);
  late final $PipelineStatusesTable pipelineStatuses = $PipelineStatusesTable(
    this,
  );
  late final $ActivityTypesTable activityTypes = $ActivityTypesTable(this);
  late final $LeadSourcesTable leadSources = $LeadSourcesTable(this);
  late final $DeclineReasonsTable declineReasons = $DeclineReasonsTable(this);
  late final $CustomersTable customers = $CustomersTable(this);
  late final $KeyPersonsTable keyPersons = $KeyPersonsTable(this);
  late final $PipelinesTable pipelines = $PipelinesTable(this);
  late final $PipelineReferralsTable pipelineReferrals =
      $PipelineReferralsTable(this);
  late final $ActivitiesTable activities = $ActivitiesTable(this);
  late final $ActivityPhotosTable activityPhotos = $ActivityPhotosTable(this);
  late final $ActivityAuditLogsTable activityAuditLogs =
      $ActivityAuditLogsTable(this);
  late final $HvcTypesTable hvcTypes = $HvcTypesTable(this);
  late final $HvcsTable hvcs = $HvcsTable(this);
  late final $CustomerHvcLinksTable customerHvcLinks = $CustomerHvcLinksTable(
    this,
  );
  late final $BrokersTable brokers = $BrokersTable(this);
  late final $MeasureDefinitionsTable measureDefinitions =
      $MeasureDefinitionsTable(this);
  late final $ScoringPeriodsTable scoringPeriods = $ScoringPeriodsTable(this);
  late final $UserTargetsTable userTargets = $UserTargetsTable(this);
  late final $UserScoresTable userScores = $UserScoresTable(this);
  late final $UserScoreAggregatesTable userScoreAggregates =
      $UserScoreAggregatesTable(this);
  late final $CadenceScheduleConfigTable cadenceScheduleConfig =
      $CadenceScheduleConfigTable(this);
  late final $CadenceMeetingsTable cadenceMeetings = $CadenceMeetingsTable(
    this,
  );
  late final $CadenceParticipantsTable cadenceParticipants =
      $CadenceParticipantsTable(this);
  late final $NotificationsTable notifications = $NotificationsTable(this);
  late final $NotificationSettingsTable notificationSettings =
      $NotificationSettingsTable(this);
  late final $AnnouncementsTable announcements = $AnnouncementsTable(this);
  late final $AnnouncementReadsTable announcementReads =
      $AnnouncementReadsTable(this);
  late final $SyncQueueItemsTable syncQueueItems = $SyncQueueItemsTable(this);
  late final $AuditLogsTable auditLogs = $AuditLogsTable(this);
  late final $AppSettingsTable appSettings = $AppSettingsTable(this);
  late final $SyncConflictsTable syncConflicts = $SyncConflictsTable(this);
  late final $PipelineStageHistoryItemsTable pipelineStageHistoryItems =
      $PipelineStageHistoryItemsTable(this);
  late final $AuditLogCacheTable auditLogCache = $AuditLogCacheTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    regionalOffices,
    branches,
    users,
    userHierarchy,
    provinces,
    cities,
    companyTypes,
    ownershipTypes,
    industries,
    cobs,
    lobs,
    pipelineStages,
    pipelineStatuses,
    activityTypes,
    leadSources,
    declineReasons,
    customers,
    keyPersons,
    pipelines,
    pipelineReferrals,
    activities,
    activityPhotos,
    activityAuditLogs,
    hvcTypes,
    hvcs,
    customerHvcLinks,
    brokers,
    measureDefinitions,
    scoringPeriods,
    userTargets,
    userScores,
    userScoreAggregates,
    cadenceScheduleConfig,
    cadenceMeetings,
    cadenceParticipants,
    notifications,
    notificationSettings,
    announcements,
    announcementReads,
    syncQueueItems,
    auditLogs,
    appSettings,
    syncConflicts,
    pipelineStageHistoryItems,
    auditLogCache,
  ];
}

typedef $$RegionalOfficesTableCreateCompanionBuilder =
    RegionalOfficesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> description,
      Value<String?> address,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<bool> isActive,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$RegionalOfficesTableUpdateCompanionBuilder =
    RegionalOfficesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<String?> address,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$RegionalOfficesTableReferences
    extends
        BaseReferences<_$AppDatabase, $RegionalOfficesTable, RegionalOffice> {
  $$RegionalOfficesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$BranchesTable, List<Branche>> _branchesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.branches,
    aliasName: $_aliasNameGenerator(
      db.regionalOffices.id,
      db.branches.regionalOfficeId,
    ),
  );

  $$BranchesTableProcessedTableManager get branchesRefs {
    final manager = $$BranchesTableTableManager($_db, $_db.branches).filter(
      (f) => f.regionalOfficeId.id.sqlEquals($_itemColumn<String>('id')!),
    );

    final cache = $_typedResult.readTableOrNull(_branchesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$UsersTable, List<User>> _usersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.users,
    aliasName: $_aliasNameGenerator(
      db.regionalOffices.id,
      db.users.regionalOfficeId,
    ),
  );

  $$UsersTableProcessedTableManager get usersRefs {
    final manager = $$UsersTableTableManager($_db, $_db.users).filter(
      (f) => f.regionalOfficeId.id.sqlEquals($_itemColumn<String>('id')!),
    );

    final cache = $_typedResult.readTableOrNull(_usersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$RegionalOfficesTableFilterComposer
    extends Composer<_$AppDatabase, $RegionalOfficesTable> {
  $$RegionalOfficesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> branchesRefs(
    Expression<bool> Function($$BranchesTableFilterComposer f) f,
  ) {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.regionalOfficeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> usersRefs(
    Expression<bool> Function($$UsersTableFilterComposer f) f,
  ) {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.regionalOfficeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RegionalOfficesTableOrderingComposer
    extends Composer<_$AppDatabase, $RegionalOfficesTable> {
  $$RegionalOfficesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RegionalOfficesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RegionalOfficesTable> {
  $$RegionalOfficesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> branchesRefs<T extends Object>(
    Expression<T> Function($$BranchesTableAnnotationComposer a) f,
  ) {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.regionalOfficeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> usersRefs<T extends Object>(
    Expression<T> Function($$UsersTableAnnotationComposer a) f,
  ) {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.regionalOfficeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$RegionalOfficesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RegionalOfficesTable,
          RegionalOffice,
          $$RegionalOfficesTableFilterComposer,
          $$RegionalOfficesTableOrderingComposer,
          $$RegionalOfficesTableAnnotationComposer,
          $$RegionalOfficesTableCreateCompanionBuilder,
          $$RegionalOfficesTableUpdateCompanionBuilder,
          (RegionalOffice, $$RegionalOfficesTableReferences),
          RegionalOffice,
          PrefetchHooks Function({bool branchesRefs, bool usersRefs})
        > {
  $$RegionalOfficesTableTableManager(
    _$AppDatabase db,
    $RegionalOfficesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RegionalOfficesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RegionalOfficesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RegionalOfficesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RegionalOfficesCompanion(
                id: id,
                code: code,
                name: name,
                description: description,
                address: address,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => RegionalOfficesCompanion.insert(
                id: id,
                code: code,
                name: name,
                description: description,
                address: address,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$RegionalOfficesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({branchesRefs = false, usersRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (branchesRefs) db.branches,
                if (usersRefs) db.users,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (branchesRefs)
                    await $_getPrefetchedData<
                      RegionalOffice,
                      $RegionalOfficesTable,
                      Branche
                    >(
                      currentTable: table,
                      referencedTable: $$RegionalOfficesTableReferences
                          ._branchesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$RegionalOfficesTableReferences(
                            db,
                            table,
                            p0,
                          ).branchesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.regionalOfficeId == item.id,
                          ),
                      typedResults: items,
                    ),
                  if (usersRefs)
                    await $_getPrefetchedData<
                      RegionalOffice,
                      $RegionalOfficesTable,
                      User
                    >(
                      currentTable: table,
                      referencedTable: $$RegionalOfficesTableReferences
                          ._usersRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$RegionalOfficesTableReferences(
                            db,
                            table,
                            p0,
                          ).usersRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.regionalOfficeId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$RegionalOfficesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RegionalOfficesTable,
      RegionalOffice,
      $$RegionalOfficesTableFilterComposer,
      $$RegionalOfficesTableOrderingComposer,
      $$RegionalOfficesTableAnnotationComposer,
      $$RegionalOfficesTableCreateCompanionBuilder,
      $$RegionalOfficesTableUpdateCompanionBuilder,
      (RegionalOffice, $$RegionalOfficesTableReferences),
      RegionalOffice,
      PrefetchHooks Function({bool branchesRefs, bool usersRefs})
    >;
typedef $$BranchesTableCreateCompanionBuilder =
    BranchesCompanion Function({
      required String id,
      required String code,
      required String name,
      required String regionalOfficeId,
      Value<String?> address,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<bool> isActive,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$BranchesTableUpdateCompanionBuilder =
    BranchesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String> regionalOfficeId,
      Value<String?> address,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$BranchesTableReferences
    extends BaseReferences<_$AppDatabase, $BranchesTable, Branche> {
  $$BranchesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $RegionalOfficesTable _regionalOfficeIdTable(_$AppDatabase db) =>
      db.regionalOffices.createAlias(
        $_aliasNameGenerator(
          db.branches.regionalOfficeId,
          db.regionalOffices.id,
        ),
      );

  $$RegionalOfficesTableProcessedTableManager get regionalOfficeId {
    final $_column = $_itemColumn<String>('regional_office_id')!;

    final manager = $$RegionalOfficesTableTableManager(
      $_db,
      $_db.regionalOffices,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_regionalOfficeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$UsersTable, List<User>> _usersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.users,
    aliasName: $_aliasNameGenerator(db.branches.id, db.users.branchId),
  );

  $$UsersTableProcessedTableManager get usersRefs {
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.branchId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_usersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BranchesTableFilterComposer
    extends Composer<_$AppDatabase, $BranchesTable> {
  $$BranchesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$RegionalOfficesTableFilterComposer get regionalOfficeId {
    final $$RegionalOfficesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.regionalOfficeId,
      referencedTable: $db.regionalOffices,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegionalOfficesTableFilterComposer(
            $db: $db,
            $table: $db.regionalOffices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> usersRefs(
    Expression<bool> Function($$UsersTableFilterComposer f) f,
  ) {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BranchesTableOrderingComposer
    extends Composer<_$AppDatabase, $BranchesTable> {
  $$BranchesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$RegionalOfficesTableOrderingComposer get regionalOfficeId {
    final $$RegionalOfficesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.regionalOfficeId,
      referencedTable: $db.regionalOffices,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegionalOfficesTableOrderingComposer(
            $db: $db,
            $table: $db.regionalOffices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BranchesTableAnnotationComposer
    extends Composer<_$AppDatabase, $BranchesTable> {
  $$BranchesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$RegionalOfficesTableAnnotationComposer get regionalOfficeId {
    final $$RegionalOfficesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.regionalOfficeId,
      referencedTable: $db.regionalOffices,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegionalOfficesTableAnnotationComposer(
            $db: $db,
            $table: $db.regionalOffices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> usersRefs<T extends Object>(
    Expression<T> Function($$UsersTableAnnotationComposer a) f,
  ) {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.branchId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BranchesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BranchesTable,
          Branche,
          $$BranchesTableFilterComposer,
          $$BranchesTableOrderingComposer,
          $$BranchesTableAnnotationComposer,
          $$BranchesTableCreateCompanionBuilder,
          $$BranchesTableUpdateCompanionBuilder,
          (Branche, $$BranchesTableReferences),
          Branche,
          PrefetchHooks Function({bool regionalOfficeId, bool usersRefs})
        > {
  $$BranchesTableTableManager(_$AppDatabase db, $BranchesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BranchesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BranchesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BranchesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> regionalOfficeId = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BranchesCompanion(
                id: id,
                code: code,
                name: name,
                regionalOfficeId: regionalOfficeId,
                address: address,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                required String regionalOfficeId,
                Value<String?> address = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => BranchesCompanion.insert(
                id: id,
                code: code,
                name: name,
                regionalOfficeId: regionalOfficeId,
                address: address,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BranchesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({regionalOfficeId = false, usersRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [if (usersRefs) db.users],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (regionalOfficeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.regionalOfficeId,
                                    referencedTable: $$BranchesTableReferences
                                        ._regionalOfficeIdTable(db),
                                    referencedColumn: $$BranchesTableReferences
                                        ._regionalOfficeIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (usersRefs)
                        await $_getPrefetchedData<
                          Branche,
                          $BranchesTable,
                          User
                        >(
                          currentTable: table,
                          referencedTable: $$BranchesTableReferences
                              ._usersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BranchesTableReferences(
                                db,
                                table,
                                p0,
                              ).usersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.branchId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$BranchesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BranchesTable,
      Branche,
      $$BranchesTableFilterComposer,
      $$BranchesTableOrderingComposer,
      $$BranchesTableAnnotationComposer,
      $$BranchesTableCreateCompanionBuilder,
      $$BranchesTableUpdateCompanionBuilder,
      (Branche, $$BranchesTableReferences),
      Branche,
      PrefetchHooks Function({bool regionalOfficeId, bool usersRefs})
    >;
typedef $$UsersTableCreateCompanionBuilder =
    UsersCompanion Function({
      required String id,
      required String email,
      required String name,
      Value<String?> nip,
      Value<String?> phone,
      required String role,
      Value<String?> parentId,
      Value<String?> branchId,
      Value<String?> regionalOfficeId,
      Value<String?> photoUrl,
      Value<bool> isActive,
      Value<DateTime?> lastLoginAt,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$UsersTableUpdateCompanionBuilder =
    UsersCompanion Function({
      Value<String> id,
      Value<String> email,
      Value<String> name,
      Value<String?> nip,
      Value<String?> phone,
      Value<String> role,
      Value<String?> parentId,
      Value<String?> branchId,
      Value<String?> regionalOfficeId,
      Value<String?> photoUrl,
      Value<bool> isActive,
      Value<DateTime?> lastLoginAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$UsersTableReferences
    extends BaseReferences<_$AppDatabase, $UsersTable, User> {
  $$UsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _parentIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.users.parentId, db.users.id),
  );

  $$UsersTableProcessedTableManager? get parentId {
    final $_column = $_itemColumn<String>('parent_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_parentIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $BranchesTable _branchIdTable(_$AppDatabase db) => db.branches
      .createAlias($_aliasNameGenerator(db.users.branchId, db.branches.id));

  $$BranchesTableProcessedTableManager? get branchId {
    final $_column = $_itemColumn<String>('branch_id');
    if ($_column == null) return null;
    final manager = $$BranchesTableTableManager(
      $_db,
      $_db.branches,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $RegionalOfficesTable _regionalOfficeIdTable(_$AppDatabase db) =>
      db.regionalOffices.createAlias(
        $_aliasNameGenerator(db.users.regionalOfficeId, db.regionalOffices.id),
      );

  $$RegionalOfficesTableProcessedTableManager? get regionalOfficeId {
    final $_column = $_itemColumn<String>('regional_office_id');
    if ($_column == null) return null;
    final manager = $$RegionalOfficesTableTableManager(
      $_db,
      $_db.regionalOffices,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_regionalOfficeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$KeyPersonsTable, List<KeyPerson>>
  _keyPersonsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.keyPersons,
    aliasName: $_aliasNameGenerator(db.users.id, db.keyPersons.createdBy),
  );

  $$KeyPersonsTableProcessedTableManager get keyPersonsRefs {
    final manager = $$KeyPersonsTableTableManager(
      $_db,
      $_db.keyPersons,
    ).filter((f) => f.createdBy.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_keyPersonsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ActivityAuditLogsTable, List<ActivityAuditLog>>
  _activityAuditLogsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.activityAuditLogs,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.activityAuditLogs.performedBy,
        ),
      );

  $$ActivityAuditLogsTableProcessedTableManager get activityAuditLogsRefs {
    final manager = $$ActivityAuditLogsTableTableManager(
      $_db,
      $_db.activityAuditLogs,
    ).filter((f) => f.performedBy.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _activityAuditLogsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CustomerHvcLinksTable, List<CustomerHvcLink>>
  _customerHvcLinksRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.customerHvcLinks,
    aliasName: $_aliasNameGenerator(db.users.id, db.customerHvcLinks.createdBy),
  );

  $$CustomerHvcLinksTableProcessedTableManager get customerHvcLinksRefs {
    final manager = $$CustomerHvcLinksTableTableManager(
      $_db,
      $_db.customerHvcLinks,
    ).filter((f) => f.createdBy.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _customerHvcLinksRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$UserScoresTable, List<UserScore>>
  _userScoresRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.userScores,
    aliasName: $_aliasNameGenerator(db.users.id, db.userScores.userId),
  );

  $$UserScoresTableProcessedTableManager get userScoresRefs {
    final manager = $$UserScoresTableTableManager(
      $_db,
      $_db.userScores,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userScoresRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $UserScoreAggregatesTable,
    List<UserScoreAggregate>
  >
  _userScoreAggregatesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.userScoreAggregates,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.userScoreAggregates.userId,
        ),
      );

  $$UserScoreAggregatesTableProcessedTableManager get userScoreAggregatesRefs {
    final manager = $$UserScoreAggregatesTableTableManager(
      $_db,
      $_db.userScoreAggregates,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _userScoreAggregatesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $CadenceParticipantsTable,
    List<CadenceParticipant>
  >
  _cadenceParticipantsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.cadenceParticipants,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.cadenceParticipants.userId,
        ),
      );

  $$CadenceParticipantsTableProcessedTableManager get cadenceParticipantsRefs {
    final manager = $$CadenceParticipantsTableTableManager(
      $_db,
      $_db.cadenceParticipants,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _cadenceParticipantsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$NotificationsTable, List<Notification>>
  _notificationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.notifications,
    aliasName: $_aliasNameGenerator(db.users.id, db.notifications.userId),
  );

  $$NotificationsTableProcessedTableManager get notificationsRefs {
    final manager = $$NotificationsTableTableManager(
      $_db,
      $_db.notifications,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_notificationsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $NotificationSettingsTable,
    List<NotificationSetting>
  >
  _notificationSettingsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.notificationSettings,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.notificationSettings.userId,
        ),
      );

  $$NotificationSettingsTableProcessedTableManager
  get notificationSettingsRefs {
    final manager = $$NotificationSettingsTableTableManager(
      $_db,
      $_db.notificationSettings,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _notificationSettingsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AnnouncementsTable, List<Announcement>>
  _announcementsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.announcements,
    aliasName: $_aliasNameGenerator(db.users.id, db.announcements.createdBy),
  );

  $$AnnouncementsTableProcessedTableManager get announcementsRefs {
    final manager = $$AnnouncementsTableTableManager(
      $_db,
      $_db.announcements,
    ).filter((f) => f.createdBy.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_announcementsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AnnouncementReadsTable, List<AnnouncementRead>>
  _announcementReadsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.announcementReads,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.announcementReads.userId,
        ),
      );

  $$AnnouncementReadsTableProcessedTableManager get announcementReadsRefs {
    final manager = $$AnnouncementReadsTableTableManager(
      $_db,
      $_db.announcementReads,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _announcementReadsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AuditLogsTable, List<AuditLog>>
  _auditLogsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.auditLogs,
    aliasName: $_aliasNameGenerator(db.users.id, db.auditLogs.changedBy),
  );

  $$AuditLogsTableProcessedTableManager get auditLogsRefs {
    final manager = $$AuditLogsTableTableManager(
      $_db,
      $_db.auditLogs,
    ).filter((f) => f.changedBy.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_auditLogsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UsersTableFilterComposer extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nip => $composableBuilder(
    column: $table.nip,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get photoUrl => $composableBuilder(
    column: $table.photoUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastLoginAt => $composableBuilder(
    column: $table.lastLoginAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get parentId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableFilterComposer get branchId {
    final $$BranchesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableFilterComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$RegionalOfficesTableFilterComposer get regionalOfficeId {
    final $$RegionalOfficesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.regionalOfficeId,
      referencedTable: $db.regionalOffices,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegionalOfficesTableFilterComposer(
            $db: $db,
            $table: $db.regionalOffices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> keyPersonsRefs(
    Expression<bool> Function($$KeyPersonsTableFilterComposer f) f,
  ) {
    final $$KeyPersonsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.keyPersons,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$KeyPersonsTableFilterComposer(
            $db: $db,
            $table: $db.keyPersons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> activityAuditLogsRefs(
    Expression<bool> Function($$ActivityAuditLogsTableFilterComposer f) f,
  ) {
    final $$ActivityAuditLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityAuditLogs,
      getReferencedColumn: (t) => t.performedBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityAuditLogsTableFilterComposer(
            $db: $db,
            $table: $db.activityAuditLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> customerHvcLinksRefs(
    Expression<bool> Function($$CustomerHvcLinksTableFilterComposer f) f,
  ) {
    final $$CustomerHvcLinksTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.customerHvcLinks,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerHvcLinksTableFilterComposer(
            $db: $db,
            $table: $db.customerHvcLinks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> userScoresRefs(
    Expression<bool> Function($$UserScoresTableFilterComposer f) f,
  ) {
    final $$UserScoresTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScores,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoresTableFilterComposer(
            $db: $db,
            $table: $db.userScores,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> userScoreAggregatesRefs(
    Expression<bool> Function($$UserScoreAggregatesTableFilterComposer f) f,
  ) {
    final $$UserScoreAggregatesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScoreAggregates,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoreAggregatesTableFilterComposer(
            $db: $db,
            $table: $db.userScoreAggregates,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> cadenceParticipantsRefs(
    Expression<bool> Function($$CadenceParticipantsTableFilterComposer f) f,
  ) {
    final $$CadenceParticipantsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cadenceParticipants,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceParticipantsTableFilterComposer(
            $db: $db,
            $table: $db.cadenceParticipants,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> notificationsRefs(
    Expression<bool> Function($$NotificationsTableFilterComposer f) f,
  ) {
    final $$NotificationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.notifications,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NotificationsTableFilterComposer(
            $db: $db,
            $table: $db.notifications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> notificationSettingsRefs(
    Expression<bool> Function($$NotificationSettingsTableFilterComposer f) f,
  ) {
    final $$NotificationSettingsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.notificationSettings,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NotificationSettingsTableFilterComposer(
            $db: $db,
            $table: $db.notificationSettings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> announcementsRefs(
    Expression<bool> Function($$AnnouncementsTableFilterComposer f) f,
  ) {
    final $$AnnouncementsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.announcements,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementsTableFilterComposer(
            $db: $db,
            $table: $db.announcements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> announcementReadsRefs(
    Expression<bool> Function($$AnnouncementReadsTableFilterComposer f) f,
  ) {
    final $$AnnouncementReadsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.announcementReads,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementReadsTableFilterComposer(
            $db: $db,
            $table: $db.announcementReads,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> auditLogsRefs(
    Expression<bool> Function($$AuditLogsTableFilterComposer f) f,
  ) {
    final $$AuditLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.auditLogs,
      getReferencedColumn: (t) => t.changedBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AuditLogsTableFilterComposer(
            $db: $db,
            $table: $db.auditLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UsersTableOrderingComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nip => $composableBuilder(
    column: $table.nip,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get photoUrl => $composableBuilder(
    column: $table.photoUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastLoginAt => $composableBuilder(
    column: $table.lastLoginAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get parentId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableOrderingComposer get branchId {
    final $$BranchesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableOrderingComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$RegionalOfficesTableOrderingComposer get regionalOfficeId {
    final $$RegionalOfficesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.regionalOfficeId,
      referencedTable: $db.regionalOffices,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegionalOfficesTableOrderingComposer(
            $db: $db,
            $table: $db.regionalOffices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get nip =>
      $composableBuilder(column: $table.nip, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<String> get photoUrl =>
      $composableBuilder(column: $table.photoUrl, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get lastLoginAt => $composableBuilder(
    column: $table.lastLoginAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get parentId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$BranchesTableAnnotationComposer get branchId {
    final $$BranchesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.branchId,
      referencedTable: $db.branches,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BranchesTableAnnotationComposer(
            $db: $db,
            $table: $db.branches,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$RegionalOfficesTableAnnotationComposer get regionalOfficeId {
    final $$RegionalOfficesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.regionalOfficeId,
      referencedTable: $db.regionalOffices,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RegionalOfficesTableAnnotationComposer(
            $db: $db,
            $table: $db.regionalOffices,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> keyPersonsRefs<T extends Object>(
    Expression<T> Function($$KeyPersonsTableAnnotationComposer a) f,
  ) {
    final $$KeyPersonsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.keyPersons,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$KeyPersonsTableAnnotationComposer(
            $db: $db,
            $table: $db.keyPersons,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> activityAuditLogsRefs<T extends Object>(
    Expression<T> Function($$ActivityAuditLogsTableAnnotationComposer a) f,
  ) {
    final $$ActivityAuditLogsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.activityAuditLogs,
          getReferencedColumn: (t) => t.performedBy,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$ActivityAuditLogsTableAnnotationComposer(
                $db: $db,
                $table: $db.activityAuditLogs,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> customerHvcLinksRefs<T extends Object>(
    Expression<T> Function($$CustomerHvcLinksTableAnnotationComposer a) f,
  ) {
    final $$CustomerHvcLinksTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.customerHvcLinks,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerHvcLinksTableAnnotationComposer(
            $db: $db,
            $table: $db.customerHvcLinks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> userScoresRefs<T extends Object>(
    Expression<T> Function($$UserScoresTableAnnotationComposer a) f,
  ) {
    final $$UserScoresTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScores,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoresTableAnnotationComposer(
            $db: $db,
            $table: $db.userScores,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> userScoreAggregatesRefs<T extends Object>(
    Expression<T> Function($$UserScoreAggregatesTableAnnotationComposer a) f,
  ) {
    final $$UserScoreAggregatesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.userScoreAggregates,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$UserScoreAggregatesTableAnnotationComposer(
                $db: $db,
                $table: $db.userScoreAggregates,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> cadenceParticipantsRefs<T extends Object>(
    Expression<T> Function($$CadenceParticipantsTableAnnotationComposer a) f,
  ) {
    final $$CadenceParticipantsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.cadenceParticipants,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$CadenceParticipantsTableAnnotationComposer(
                $db: $db,
                $table: $db.cadenceParticipants,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> notificationsRefs<T extends Object>(
    Expression<T> Function($$NotificationsTableAnnotationComposer a) f,
  ) {
    final $$NotificationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.notifications,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$NotificationsTableAnnotationComposer(
            $db: $db,
            $table: $db.notifications,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> notificationSettingsRefs<T extends Object>(
    Expression<T> Function($$NotificationSettingsTableAnnotationComposer a) f,
  ) {
    final $$NotificationSettingsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.notificationSettings,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$NotificationSettingsTableAnnotationComposer(
                $db: $db,
                $table: $db.notificationSettings,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> announcementsRefs<T extends Object>(
    Expression<T> Function($$AnnouncementsTableAnnotationComposer a) f,
  ) {
    final $$AnnouncementsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.announcements,
      getReferencedColumn: (t) => t.createdBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementsTableAnnotationComposer(
            $db: $db,
            $table: $db.announcements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> announcementReadsRefs<T extends Object>(
    Expression<T> Function($$AnnouncementReadsTableAnnotationComposer a) f,
  ) {
    final $$AnnouncementReadsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.announcementReads,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AnnouncementReadsTableAnnotationComposer(
                $db: $db,
                $table: $db.announcementReads,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> auditLogsRefs<T extends Object>(
    Expression<T> Function($$AuditLogsTableAnnotationComposer a) f,
  ) {
    final $$AuditLogsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.auditLogs,
      getReferencedColumn: (t) => t.changedBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AuditLogsTableAnnotationComposer(
            $db: $db,
            $table: $db.auditLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UsersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UsersTable,
          User,
          $$UsersTableFilterComposer,
          $$UsersTableOrderingComposer,
          $$UsersTableAnnotationComposer,
          $$UsersTableCreateCompanionBuilder,
          $$UsersTableUpdateCompanionBuilder,
          (User, $$UsersTableReferences),
          User,
          PrefetchHooks Function({
            bool parentId,
            bool branchId,
            bool regionalOfficeId,
            bool keyPersonsRefs,
            bool activityAuditLogsRefs,
            bool customerHvcLinksRefs,
            bool userScoresRefs,
            bool userScoreAggregatesRefs,
            bool cadenceParticipantsRefs,
            bool notificationsRefs,
            bool notificationSettingsRefs,
            bool announcementsRefs,
            bool announcementReadsRefs,
            bool auditLogsRefs,
          })
        > {
  $$UsersTableTableManager(_$AppDatabase db, $UsersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> email = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> nip = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String> role = const Value.absent(),
                Value<String?> parentId = const Value.absent(),
                Value<String?> branchId = const Value.absent(),
                Value<String?> regionalOfficeId = const Value.absent(),
                Value<String?> photoUrl = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> lastLoginAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UsersCompanion(
                id: id,
                email: email,
                name: name,
                nip: nip,
                phone: phone,
                role: role,
                parentId: parentId,
                branchId: branchId,
                regionalOfficeId: regionalOfficeId,
                photoUrl: photoUrl,
                isActive: isActive,
                lastLoginAt: lastLoginAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String email,
                required String name,
                Value<String?> nip = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                required String role,
                Value<String?> parentId = const Value.absent(),
                Value<String?> branchId = const Value.absent(),
                Value<String?> regionalOfficeId = const Value.absent(),
                Value<String?> photoUrl = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime?> lastLoginAt = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UsersCompanion.insert(
                id: id,
                email: email,
                name: name,
                nip: nip,
                phone: phone,
                role: role,
                parentId: parentId,
                branchId: branchId,
                regionalOfficeId: regionalOfficeId,
                photoUrl: photoUrl,
                isActive: isActive,
                lastLoginAt: lastLoginAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$UsersTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                parentId = false,
                branchId = false,
                regionalOfficeId = false,
                keyPersonsRefs = false,
                activityAuditLogsRefs = false,
                customerHvcLinksRefs = false,
                userScoresRefs = false,
                userScoreAggregatesRefs = false,
                cadenceParticipantsRefs = false,
                notificationsRefs = false,
                notificationSettingsRefs = false,
                announcementsRefs = false,
                announcementReadsRefs = false,
                auditLogsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (keyPersonsRefs) db.keyPersons,
                    if (activityAuditLogsRefs) db.activityAuditLogs,
                    if (customerHvcLinksRefs) db.customerHvcLinks,
                    if (userScoresRefs) db.userScores,
                    if (userScoreAggregatesRefs) db.userScoreAggregates,
                    if (cadenceParticipantsRefs) db.cadenceParticipants,
                    if (notificationsRefs) db.notifications,
                    if (notificationSettingsRefs) db.notificationSettings,
                    if (announcementsRefs) db.announcements,
                    if (announcementReadsRefs) db.announcementReads,
                    if (auditLogsRefs) db.auditLogs,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (parentId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.parentId,
                                    referencedTable: $$UsersTableReferences
                                        ._parentIdTable(db),
                                    referencedColumn: $$UsersTableReferences
                                        ._parentIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (branchId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.branchId,
                                    referencedTable: $$UsersTableReferences
                                        ._branchIdTable(db),
                                    referencedColumn: $$UsersTableReferences
                                        ._branchIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (regionalOfficeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.regionalOfficeId,
                                    referencedTable: $$UsersTableReferences
                                        ._regionalOfficeIdTable(db),
                                    referencedColumn: $$UsersTableReferences
                                        ._regionalOfficeIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (keyPersonsRefs)
                        await $_getPrefetchedData<User, $UsersTable, KeyPerson>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._keyPersonsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).keyPersonsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.createdBy == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (activityAuditLogsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          ActivityAuditLog
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._activityAuditLogsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).activityAuditLogsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.performedBy == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (customerHvcLinksRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          CustomerHvcLink
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._customerHvcLinksRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).customerHvcLinksRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.createdBy == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (userScoresRefs)
                        await $_getPrefetchedData<User, $UsersTable, UserScore>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._userScoresRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).userScoresRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (userScoreAggregatesRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          UserScoreAggregate
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._userScoreAggregatesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).userScoreAggregatesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (cadenceParticipantsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          CadenceParticipant
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._cadenceParticipantsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).cadenceParticipantsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (notificationsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          Notification
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._notificationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).notificationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (notificationSettingsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          NotificationSetting
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._notificationSettingsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).notificationSettingsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (announcementsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          Announcement
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._announcementsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).announcementsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.createdBy == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (announcementReadsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          AnnouncementRead
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._announcementReadsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).announcementReadsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (auditLogsRefs)
                        await $_getPrefetchedData<User, $UsersTable, AuditLog>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._auditLogsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).auditLogsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.changedBy == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$UsersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UsersTable,
      User,
      $$UsersTableFilterComposer,
      $$UsersTableOrderingComposer,
      $$UsersTableAnnotationComposer,
      $$UsersTableCreateCompanionBuilder,
      $$UsersTableUpdateCompanionBuilder,
      (User, $$UsersTableReferences),
      User,
      PrefetchHooks Function({
        bool parentId,
        bool branchId,
        bool regionalOfficeId,
        bool keyPersonsRefs,
        bool activityAuditLogsRefs,
        bool customerHvcLinksRefs,
        bool userScoresRefs,
        bool userScoreAggregatesRefs,
        bool cadenceParticipantsRefs,
        bool notificationsRefs,
        bool notificationSettingsRefs,
        bool announcementsRefs,
        bool announcementReadsRefs,
        bool auditLogsRefs,
      })
    >;
typedef $$UserHierarchyTableCreateCompanionBuilder =
    UserHierarchyCompanion Function({
      required String ancestorId,
      required String descendantId,
      required int depth,
      Value<int> rowid,
    });
typedef $$UserHierarchyTableUpdateCompanionBuilder =
    UserHierarchyCompanion Function({
      Value<String> ancestorId,
      Value<String> descendantId,
      Value<int> depth,
      Value<int> rowid,
    });

final class $$UserHierarchyTableReferences
    extends
        BaseReferences<_$AppDatabase, $UserHierarchyTable, UserHierarchyData> {
  $$UserHierarchyTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _ancestorIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.userHierarchy.ancestorId, db.users.id),
  );

  $$UsersTableProcessedTableManager get ancestorId {
    final $_column = $_itemColumn<String>('ancestor_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ancestorIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _descendantIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.userHierarchy.descendantId, db.users.id),
      );

  $$UsersTableProcessedTableManager get descendantId {
    final $_column = $_itemColumn<String>('descendant_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_descendantIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$UserHierarchyTableFilterComposer
    extends Composer<_$AppDatabase, $UserHierarchyTable> {
  $$UserHierarchyTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get depth => $composableBuilder(
    column: $table.depth,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get ancestorId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ancestorId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get descendantId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.descendantId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserHierarchyTableOrderingComposer
    extends Composer<_$AppDatabase, $UserHierarchyTable> {
  $$UserHierarchyTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get depth => $composableBuilder(
    column: $table.depth,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get ancestorId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ancestorId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get descendantId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.descendantId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserHierarchyTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserHierarchyTable> {
  $$UserHierarchyTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get depth =>
      $composableBuilder(column: $table.depth, builder: (column) => column);

  $$UsersTableAnnotationComposer get ancestorId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ancestorId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get descendantId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.descendantId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserHierarchyTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserHierarchyTable,
          UserHierarchyData,
          $$UserHierarchyTableFilterComposer,
          $$UserHierarchyTableOrderingComposer,
          $$UserHierarchyTableAnnotationComposer,
          $$UserHierarchyTableCreateCompanionBuilder,
          $$UserHierarchyTableUpdateCompanionBuilder,
          (UserHierarchyData, $$UserHierarchyTableReferences),
          UserHierarchyData,
          PrefetchHooks Function({bool ancestorId, bool descendantId})
        > {
  $$UserHierarchyTableTableManager(_$AppDatabase db, $UserHierarchyTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserHierarchyTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserHierarchyTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserHierarchyTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> ancestorId = const Value.absent(),
                Value<String> descendantId = const Value.absent(),
                Value<int> depth = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserHierarchyCompanion(
                ancestorId: ancestorId,
                descendantId: descendantId,
                depth: depth,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String ancestorId,
                required String descendantId,
                required int depth,
                Value<int> rowid = const Value.absent(),
              }) => UserHierarchyCompanion.insert(
                ancestorId: ancestorId,
                descendantId: descendantId,
                depth: depth,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserHierarchyTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ancestorId = false, descendantId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ancestorId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ancestorId,
                                referencedTable: $$UserHierarchyTableReferences
                                    ._ancestorIdTable(db),
                                referencedColumn: $$UserHierarchyTableReferences
                                    ._ancestorIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (descendantId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.descendantId,
                                referencedTable: $$UserHierarchyTableReferences
                                    ._descendantIdTable(db),
                                referencedColumn: $$UserHierarchyTableReferences
                                    ._descendantIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$UserHierarchyTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserHierarchyTable,
      UserHierarchyData,
      $$UserHierarchyTableFilterComposer,
      $$UserHierarchyTableOrderingComposer,
      $$UserHierarchyTableAnnotationComposer,
      $$UserHierarchyTableCreateCompanionBuilder,
      $$UserHierarchyTableUpdateCompanionBuilder,
      (UserHierarchyData, $$UserHierarchyTableReferences),
      UserHierarchyData,
      PrefetchHooks Function({bool ancestorId, bool descendantId})
    >;
typedef $$ProvincesTableCreateCompanionBuilder =
    ProvincesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$ProvincesTableUpdateCompanionBuilder =
    ProvincesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<bool> isActive,
      Value<int> rowid,
    });

final class $$ProvincesTableReferences
    extends BaseReferences<_$AppDatabase, $ProvincesTable, Province> {
  $$ProvincesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$CitiesTable, List<City>> _citiesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.cities,
    aliasName: $_aliasNameGenerator(db.provinces.id, db.cities.provinceId),
  );

  $$CitiesTableProcessedTableManager get citiesRefs {
    final manager = $$CitiesTableTableManager(
      $_db,
      $_db.cities,
    ).filter((f) => f.provinceId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_citiesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$BrokersTable, List<Broker>> _brokersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.brokers,
    aliasName: $_aliasNameGenerator(db.provinces.id, db.brokers.provinceId),
  );

  $$BrokersTableProcessedTableManager get brokersRefs {
    final manager = $$BrokersTableTableManager(
      $_db,
      $_db.brokers,
    ).filter((f) => f.provinceId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_brokersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProvincesTableFilterComposer
    extends Composer<_$AppDatabase, $ProvincesTable> {
  $$ProvincesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> citiesRefs(
    Expression<bool> Function($$CitiesTableFilterComposer f) f,
  ) {
    final $$CitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cities,
      getReferencedColumn: (t) => t.provinceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CitiesTableFilterComposer(
            $db: $db,
            $table: $db.cities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> brokersRefs(
    Expression<bool> Function($$BrokersTableFilterComposer f) f,
  ) {
    final $$BrokersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.brokers,
      getReferencedColumn: (t) => t.provinceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BrokersTableFilterComposer(
            $db: $db,
            $table: $db.brokers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProvincesTableOrderingComposer
    extends Composer<_$AppDatabase, $ProvincesTable> {
  $$ProvincesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ProvincesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProvincesTable> {
  $$ProvincesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> citiesRefs<T extends Object>(
    Expression<T> Function($$CitiesTableAnnotationComposer a) f,
  ) {
    final $$CitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cities,
      getReferencedColumn: (t) => t.provinceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.cities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> brokersRefs<T extends Object>(
    Expression<T> Function($$BrokersTableAnnotationComposer a) f,
  ) {
    final $$BrokersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.brokers,
      getReferencedColumn: (t) => t.provinceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BrokersTableAnnotationComposer(
            $db: $db,
            $table: $db.brokers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProvincesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProvincesTable,
          Province,
          $$ProvincesTableFilterComposer,
          $$ProvincesTableOrderingComposer,
          $$ProvincesTableAnnotationComposer,
          $$ProvincesTableCreateCompanionBuilder,
          $$ProvincesTableUpdateCompanionBuilder,
          (Province, $$ProvincesTableReferences),
          Province,
          PrefetchHooks Function({bool citiesRefs, bool brokersRefs})
        > {
  $$ProvincesTableTableManager(_$AppDatabase db, $ProvincesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProvincesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProvincesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProvincesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProvincesCompanion(
                id: id,
                code: code,
                name: name,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProvincesCompanion.insert(
                id: id,
                code: code,
                name: name,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProvincesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({citiesRefs = false, brokersRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (citiesRefs) db.cities,
                if (brokersRefs) db.brokers,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (citiesRefs)
                    await $_getPrefetchedData<Province, $ProvincesTable, City>(
                      currentTable: table,
                      referencedTable: $$ProvincesTableReferences
                          ._citiesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$ProvincesTableReferences(db, table, p0).citiesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.provinceId == item.id),
                      typedResults: items,
                    ),
                  if (brokersRefs)
                    await $_getPrefetchedData<
                      Province,
                      $ProvincesTable,
                      Broker
                    >(
                      currentTable: table,
                      referencedTable: $$ProvincesTableReferences
                          ._brokersRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$ProvincesTableReferences(db, table, p0).brokersRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.provinceId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ProvincesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProvincesTable,
      Province,
      $$ProvincesTableFilterComposer,
      $$ProvincesTableOrderingComposer,
      $$ProvincesTableAnnotationComposer,
      $$ProvincesTableCreateCompanionBuilder,
      $$ProvincesTableUpdateCompanionBuilder,
      (Province, $$ProvincesTableReferences),
      Province,
      PrefetchHooks Function({bool citiesRefs, bool brokersRefs})
    >;
typedef $$CitiesTableCreateCompanionBuilder =
    CitiesCompanion Function({
      required String id,
      required String code,
      required String name,
      required String provinceId,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$CitiesTableUpdateCompanionBuilder =
    CitiesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String> provinceId,
      Value<bool> isActive,
      Value<int> rowid,
    });

final class $$CitiesTableReferences
    extends BaseReferences<_$AppDatabase, $CitiesTable, City> {
  $$CitiesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProvincesTable _provinceIdTable(_$AppDatabase db) => db.provinces
      .createAlias($_aliasNameGenerator(db.cities.provinceId, db.provinces.id));

  $$ProvincesTableProcessedTableManager get provinceId {
    final $_column = $_itemColumn<String>('province_id')!;

    final manager = $$ProvincesTableTableManager(
      $_db,
      $_db.provinces,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_provinceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$BrokersTable, List<Broker>> _brokersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.brokers,
    aliasName: $_aliasNameGenerator(db.cities.id, db.brokers.cityId),
  );

  $$BrokersTableProcessedTableManager get brokersRefs {
    final manager = $$BrokersTableTableManager(
      $_db,
      $_db.brokers,
    ).filter((f) => f.cityId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_brokersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CitiesTableFilterComposer
    extends Composer<_$AppDatabase, $CitiesTable> {
  $$CitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  $$ProvincesTableFilterComposer get provinceId {
    final $$ProvincesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.provinceId,
      referencedTable: $db.provinces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProvincesTableFilterComposer(
            $db: $db,
            $table: $db.provinces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> brokersRefs(
    Expression<bool> Function($$BrokersTableFilterComposer f) f,
  ) {
    final $$BrokersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.brokers,
      getReferencedColumn: (t) => t.cityId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BrokersTableFilterComposer(
            $db: $db,
            $table: $db.brokers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $CitiesTable> {
  $$CitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProvincesTableOrderingComposer get provinceId {
    final $$ProvincesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.provinceId,
      referencedTable: $db.provinces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProvincesTableOrderingComposer(
            $db: $db,
            $table: $db.provinces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CitiesTable> {
  $$CitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  $$ProvincesTableAnnotationComposer get provinceId {
    final $$ProvincesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.provinceId,
      referencedTable: $db.provinces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProvincesTableAnnotationComposer(
            $db: $db,
            $table: $db.provinces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> brokersRefs<T extends Object>(
    Expression<T> Function($$BrokersTableAnnotationComposer a) f,
  ) {
    final $$BrokersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.brokers,
      getReferencedColumn: (t) => t.cityId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BrokersTableAnnotationComposer(
            $db: $db,
            $table: $db.brokers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CitiesTable,
          City,
          $$CitiesTableFilterComposer,
          $$CitiesTableOrderingComposer,
          $$CitiesTableAnnotationComposer,
          $$CitiesTableCreateCompanionBuilder,
          $$CitiesTableUpdateCompanionBuilder,
          (City, $$CitiesTableReferences),
          City,
          PrefetchHooks Function({bool provinceId, bool brokersRefs})
        > {
  $$CitiesTableTableManager(_$AppDatabase db, $CitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> provinceId = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CitiesCompanion(
                id: id,
                code: code,
                name: name,
                provinceId: provinceId,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                required String provinceId,
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CitiesCompanion.insert(
                id: id,
                code: code,
                name: name,
                provinceId: provinceId,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$CitiesTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({provinceId = false, brokersRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (brokersRefs) db.brokers],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (provinceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.provinceId,
                                referencedTable: $$CitiesTableReferences
                                    ._provinceIdTable(db),
                                referencedColumn: $$CitiesTableReferences
                                    ._provinceIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (brokersRefs)
                    await $_getPrefetchedData<City, $CitiesTable, Broker>(
                      currentTable: table,
                      referencedTable: $$CitiesTableReferences
                          ._brokersRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CitiesTableReferences(db, table, p0).brokersRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.cityId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CitiesTable,
      City,
      $$CitiesTableFilterComposer,
      $$CitiesTableOrderingComposer,
      $$CitiesTableAnnotationComposer,
      $$CitiesTableCreateCompanionBuilder,
      $$CitiesTableUpdateCompanionBuilder,
      (City, $$CitiesTableReferences),
      City,
      PrefetchHooks Function({bool provinceId, bool brokersRefs})
    >;
typedef $$CompanyTypesTableCreateCompanionBuilder =
    CompanyTypesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$CompanyTypesTableUpdateCompanionBuilder =
    CompanyTypesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

class $$CompanyTypesTableFilterComposer
    extends Composer<_$AppDatabase, $CompanyTypesTable> {
  $$CompanyTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CompanyTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $CompanyTypesTable> {
  $$CompanyTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CompanyTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CompanyTypesTable> {
  $$CompanyTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$CompanyTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CompanyTypesTable,
          CompanyType,
          $$CompanyTypesTableFilterComposer,
          $$CompanyTypesTableOrderingComposer,
          $$CompanyTypesTableAnnotationComposer,
          $$CompanyTypesTableCreateCompanionBuilder,
          $$CompanyTypesTableUpdateCompanionBuilder,
          (
            CompanyType,
            BaseReferences<_$AppDatabase, $CompanyTypesTable, CompanyType>,
          ),
          CompanyType,
          PrefetchHooks Function()
        > {
  $$CompanyTypesTableTableManager(_$AppDatabase db, $CompanyTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CompanyTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CompanyTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CompanyTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CompanyTypesCompanion(
                id: id,
                code: code,
                name: name,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CompanyTypesCompanion.insert(
                id: id,
                code: code,
                name: name,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CompanyTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CompanyTypesTable,
      CompanyType,
      $$CompanyTypesTableFilterComposer,
      $$CompanyTypesTableOrderingComposer,
      $$CompanyTypesTableAnnotationComposer,
      $$CompanyTypesTableCreateCompanionBuilder,
      $$CompanyTypesTableUpdateCompanionBuilder,
      (
        CompanyType,
        BaseReferences<_$AppDatabase, $CompanyTypesTable, CompanyType>,
      ),
      CompanyType,
      PrefetchHooks Function()
    >;
typedef $$OwnershipTypesTableCreateCompanionBuilder =
    OwnershipTypesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$OwnershipTypesTableUpdateCompanionBuilder =
    OwnershipTypesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

class $$OwnershipTypesTableFilterComposer
    extends Composer<_$AppDatabase, $OwnershipTypesTable> {
  $$OwnershipTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );
}

class $$OwnershipTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $OwnershipTypesTable> {
  $$OwnershipTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OwnershipTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OwnershipTypesTable> {
  $$OwnershipTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$OwnershipTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OwnershipTypesTable,
          OwnershipType,
          $$OwnershipTypesTableFilterComposer,
          $$OwnershipTypesTableOrderingComposer,
          $$OwnershipTypesTableAnnotationComposer,
          $$OwnershipTypesTableCreateCompanionBuilder,
          $$OwnershipTypesTableUpdateCompanionBuilder,
          (
            OwnershipType,
            BaseReferences<_$AppDatabase, $OwnershipTypesTable, OwnershipType>,
          ),
          OwnershipType,
          PrefetchHooks Function()
        > {
  $$OwnershipTypesTableTableManager(
    _$AppDatabase db,
    $OwnershipTypesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OwnershipTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OwnershipTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OwnershipTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OwnershipTypesCompanion(
                id: id,
                code: code,
                name: name,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OwnershipTypesCompanion.insert(
                id: id,
                code: code,
                name: name,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$OwnershipTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OwnershipTypesTable,
      OwnershipType,
      $$OwnershipTypesTableFilterComposer,
      $$OwnershipTypesTableOrderingComposer,
      $$OwnershipTypesTableAnnotationComposer,
      $$OwnershipTypesTableCreateCompanionBuilder,
      $$OwnershipTypesTableUpdateCompanionBuilder,
      (
        OwnershipType,
        BaseReferences<_$AppDatabase, $OwnershipTypesTable, OwnershipType>,
      ),
      OwnershipType,
      PrefetchHooks Function()
    >;
typedef $$IndustriesTableCreateCompanionBuilder =
    IndustriesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$IndustriesTableUpdateCompanionBuilder =
    IndustriesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

class $$IndustriesTableFilterComposer
    extends Composer<_$AppDatabase, $IndustriesTable> {
  $$IndustriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );
}

class $$IndustriesTableOrderingComposer
    extends Composer<_$AppDatabase, $IndustriesTable> {
  $$IndustriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$IndustriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $IndustriesTable> {
  $$IndustriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$IndustriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $IndustriesTable,
          Industry,
          $$IndustriesTableFilterComposer,
          $$IndustriesTableOrderingComposer,
          $$IndustriesTableAnnotationComposer,
          $$IndustriesTableCreateCompanionBuilder,
          $$IndustriesTableUpdateCompanionBuilder,
          (Industry, BaseReferences<_$AppDatabase, $IndustriesTable, Industry>),
          Industry,
          PrefetchHooks Function()
        > {
  $$IndustriesTableTableManager(_$AppDatabase db, $IndustriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$IndustriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$IndustriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$IndustriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => IndustriesCompanion(
                id: id,
                code: code,
                name: name,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => IndustriesCompanion.insert(
                id: id,
                code: code,
                name: name,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$IndustriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $IndustriesTable,
      Industry,
      $$IndustriesTableFilterComposer,
      $$IndustriesTableOrderingComposer,
      $$IndustriesTableAnnotationComposer,
      $$IndustriesTableCreateCompanionBuilder,
      $$IndustriesTableUpdateCompanionBuilder,
      (Industry, BaseReferences<_$AppDatabase, $IndustriesTable, Industry>),
      Industry,
      PrefetchHooks Function()
    >;
typedef $$CobsTableCreateCompanionBuilder =
    CobsCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$CobsTableUpdateCompanionBuilder =
    CobsCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

final class $$CobsTableReferences
    extends BaseReferences<_$AppDatabase, $CobsTable, Cob> {
  $$CobsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$LobsTable, List<Lob>> _lobsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.lobs,
    aliasName: $_aliasNameGenerator(db.cobs.id, db.lobs.cobId),
  );

  $$LobsTableProcessedTableManager get lobsRefs {
    final manager = $$LobsTableTableManager(
      $_db,
      $_db.lobs,
    ).filter((f) => f.cobId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_lobsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CobsTableFilterComposer extends Composer<_$AppDatabase, $CobsTable> {
  $$CobsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> lobsRefs(
    Expression<bool> Function($$LobsTableFilterComposer f) f,
  ) {
    final $$LobsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.lobs,
      getReferencedColumn: (t) => t.cobId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LobsTableFilterComposer(
            $db: $db,
            $table: $db.lobs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CobsTableOrderingComposer extends Composer<_$AppDatabase, $CobsTable> {
  $$CobsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CobsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CobsTable> {
  $$CobsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> lobsRefs<T extends Object>(
    Expression<T> Function($$LobsTableAnnotationComposer a) f,
  ) {
    final $$LobsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.lobs,
      getReferencedColumn: (t) => t.cobId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LobsTableAnnotationComposer(
            $db: $db,
            $table: $db.lobs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CobsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CobsTable,
          Cob,
          $$CobsTableFilterComposer,
          $$CobsTableOrderingComposer,
          $$CobsTableAnnotationComposer,
          $$CobsTableCreateCompanionBuilder,
          $$CobsTableUpdateCompanionBuilder,
          (Cob, $$CobsTableReferences),
          Cob,
          PrefetchHooks Function({bool lobsRefs})
        > {
  $$CobsTableTableManager(_$AppDatabase db, $CobsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CobsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CobsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CobsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CobsCompanion(
                id: id,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CobsCompanion.insert(
                id: id,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$CobsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({lobsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (lobsRefs) db.lobs],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (lobsRefs)
                    await $_getPrefetchedData<Cob, $CobsTable, Lob>(
                      currentTable: table,
                      referencedTable: $$CobsTableReferences._lobsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CobsTableReferences(db, table, p0).lobsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.cobId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CobsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CobsTable,
      Cob,
      $$CobsTableFilterComposer,
      $$CobsTableOrderingComposer,
      $$CobsTableAnnotationComposer,
      $$CobsTableCreateCompanionBuilder,
      $$CobsTableUpdateCompanionBuilder,
      (Cob, $$CobsTableReferences),
      Cob,
      PrefetchHooks Function({bool lobsRefs})
    >;
typedef $$LobsTableCreateCompanionBuilder =
    LobsCompanion Function({
      required String id,
      required String cobId,
      required String code,
      required String name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$LobsTableUpdateCompanionBuilder =
    LobsCompanion Function({
      Value<String> id,
      Value<String> cobId,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

final class $$LobsTableReferences
    extends BaseReferences<_$AppDatabase, $LobsTable, Lob> {
  $$LobsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CobsTable _cobIdTable(_$AppDatabase db) =>
      db.cobs.createAlias($_aliasNameGenerator(db.lobs.cobId, db.cobs.id));

  $$CobsTableProcessedTableManager get cobId {
    final $_column = $_itemColumn<String>('cob_id')!;

    final manager = $$CobsTableTableManager(
      $_db,
      $_db.cobs,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_cobIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$LobsTableFilterComposer extends Composer<_$AppDatabase, $LobsTable> {
  $$LobsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  $$CobsTableFilterComposer get cobId {
    final $$CobsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.cobId,
      referencedTable: $db.cobs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CobsTableFilterComposer(
            $db: $db,
            $table: $db.cobs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LobsTableOrderingComposer extends Composer<_$AppDatabase, $LobsTable> {
  $$LobsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  $$CobsTableOrderingComposer get cobId {
    final $$CobsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.cobId,
      referencedTable: $db.cobs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CobsTableOrderingComposer(
            $db: $db,
            $table: $db.cobs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LobsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LobsTable> {
  $$LobsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  $$CobsTableAnnotationComposer get cobId {
    final $$CobsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.cobId,
      referencedTable: $db.cobs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CobsTableAnnotationComposer(
            $db: $db,
            $table: $db.cobs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LobsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LobsTable,
          Lob,
          $$LobsTableFilterComposer,
          $$LobsTableOrderingComposer,
          $$LobsTableAnnotationComposer,
          $$LobsTableCreateCompanionBuilder,
          $$LobsTableUpdateCompanionBuilder,
          (Lob, $$LobsTableReferences),
          Lob,
          PrefetchHooks Function({bool cobId})
        > {
  $$LobsTableTableManager(_$AppDatabase db, $LobsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LobsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LobsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LobsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> cobId = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LobsCompanion(
                id: id,
                cobId: cobId,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String cobId,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LobsCompanion.insert(
                id: id,
                cobId: cobId,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$LobsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({cobId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (cobId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.cobId,
                                referencedTable: $$LobsTableReferences
                                    ._cobIdTable(db),
                                referencedColumn: $$LobsTableReferences
                                    ._cobIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$LobsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LobsTable,
      Lob,
      $$LobsTableFilterComposer,
      $$LobsTableOrderingComposer,
      $$LobsTableAnnotationComposer,
      $$LobsTableCreateCompanionBuilder,
      $$LobsTableUpdateCompanionBuilder,
      (Lob, $$LobsTableReferences),
      Lob,
      PrefetchHooks Function({bool cobId})
    >;
typedef $$PipelineStagesTableCreateCompanionBuilder =
    PipelineStagesCompanion Function({
      required String id,
      required String code,
      required String name,
      required int probability,
      required int sequence,
      Value<String?> color,
      Value<bool> isFinal,
      Value<bool> isWon,
      Value<bool> isActive,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$PipelineStagesTableUpdateCompanionBuilder =
    PipelineStagesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<int> probability,
      Value<int> sequence,
      Value<String?> color,
      Value<bool> isFinal,
      Value<bool> isWon,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$PipelineStagesTableReferences
    extends BaseReferences<_$AppDatabase, $PipelineStagesTable, PipelineStage> {
  $$PipelineStagesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$PipelineStatusesTable, List<PipelineStatuse>>
  _pipelineStatusesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.pipelineStatuses,
    aliasName: $_aliasNameGenerator(
      db.pipelineStages.id,
      db.pipelineStatuses.stageId,
    ),
  );

  $$PipelineStatusesTableProcessedTableManager get pipelineStatusesRefs {
    final manager = $$PipelineStatusesTableTableManager(
      $_db,
      $_db.pipelineStatuses,
    ).filter((f) => f.stageId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _pipelineStatusesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$PipelineStagesTableFilterComposer
    extends Composer<_$AppDatabase, $PipelineStagesTable> {
  $$PipelineStagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get probability => $composableBuilder(
    column: $table.probability,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFinal => $composableBuilder(
    column: $table.isFinal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isWon => $composableBuilder(
    column: $table.isWon,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> pipelineStatusesRefs(
    Expression<bool> Function($$PipelineStatusesTableFilterComposer f) f,
  ) {
    final $$PipelineStatusesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.pipelineStatuses,
      getReferencedColumn: (t) => t.stageId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelineStatusesTableFilterComposer(
            $db: $db,
            $table: $db.pipelineStatuses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PipelineStagesTableOrderingComposer
    extends Composer<_$AppDatabase, $PipelineStagesTable> {
  $$PipelineStagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get probability => $composableBuilder(
    column: $table.probability,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFinal => $composableBuilder(
    column: $table.isFinal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isWon => $composableBuilder(
    column: $table.isWon,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PipelineStagesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PipelineStagesTable> {
  $$PipelineStagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get probability => $composableBuilder(
    column: $table.probability,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sequence =>
      $composableBuilder(column: $table.sequence, builder: (column) => column);

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<bool> get isFinal =>
      $composableBuilder(column: $table.isFinal, builder: (column) => column);

  GeneratedColumn<bool> get isWon =>
      $composableBuilder(column: $table.isWon, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> pipelineStatusesRefs<T extends Object>(
    Expression<T> Function($$PipelineStatusesTableAnnotationComposer a) f,
  ) {
    final $$PipelineStatusesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.pipelineStatuses,
      getReferencedColumn: (t) => t.stageId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelineStatusesTableAnnotationComposer(
            $db: $db,
            $table: $db.pipelineStatuses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PipelineStagesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PipelineStagesTable,
          PipelineStage,
          $$PipelineStagesTableFilterComposer,
          $$PipelineStagesTableOrderingComposer,
          $$PipelineStagesTableAnnotationComposer,
          $$PipelineStagesTableCreateCompanionBuilder,
          $$PipelineStagesTableUpdateCompanionBuilder,
          (PipelineStage, $$PipelineStagesTableReferences),
          PipelineStage,
          PrefetchHooks Function({bool pipelineStatusesRefs})
        > {
  $$PipelineStagesTableTableManager(
    _$AppDatabase db,
    $PipelineStagesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PipelineStagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PipelineStagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PipelineStagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> probability = const Value.absent(),
                Value<int> sequence = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> isFinal = const Value.absent(),
                Value<bool> isWon = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelineStagesCompanion(
                id: id,
                code: code,
                name: name,
                probability: probability,
                sequence: sequence,
                color: color,
                isFinal: isFinal,
                isWon: isWon,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                required int probability,
                required int sequence,
                Value<String?> color = const Value.absent(),
                Value<bool> isFinal = const Value.absent(),
                Value<bool> isWon = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => PipelineStagesCompanion.insert(
                id: id,
                code: code,
                name: name,
                probability: probability,
                sequence: sequence,
                color: color,
                isFinal: isFinal,
                isWon: isWon,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PipelineStagesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({pipelineStatusesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (pipelineStatusesRefs) db.pipelineStatuses,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (pipelineStatusesRefs)
                    await $_getPrefetchedData<
                      PipelineStage,
                      $PipelineStagesTable,
                      PipelineStatuse
                    >(
                      currentTable: table,
                      referencedTable: $$PipelineStagesTableReferences
                          ._pipelineStatusesRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$PipelineStagesTableReferences(
                            db,
                            table,
                            p0,
                          ).pipelineStatusesRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.stageId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$PipelineStagesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PipelineStagesTable,
      PipelineStage,
      $$PipelineStagesTableFilterComposer,
      $$PipelineStagesTableOrderingComposer,
      $$PipelineStagesTableAnnotationComposer,
      $$PipelineStagesTableCreateCompanionBuilder,
      $$PipelineStagesTableUpdateCompanionBuilder,
      (PipelineStage, $$PipelineStagesTableReferences),
      PipelineStage,
      PrefetchHooks Function({bool pipelineStatusesRefs})
    >;
typedef $$PipelineStatusesTableCreateCompanionBuilder =
    PipelineStatusesCompanion Function({
      required String id,
      required String stageId,
      required String code,
      required String name,
      Value<String?> description,
      required int sequence,
      Value<bool> isDefault,
      Value<bool> isActive,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$PipelineStatusesTableUpdateCompanionBuilder =
    PipelineStatusesCompanion Function({
      Value<String> id,
      Value<String> stageId,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<int> sequence,
      Value<bool> isDefault,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$PipelineStatusesTableReferences
    extends
        BaseReferences<_$AppDatabase, $PipelineStatusesTable, PipelineStatuse> {
  $$PipelineStatusesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $PipelineStagesTable _stageIdTable(_$AppDatabase db) =>
      db.pipelineStages.createAlias(
        $_aliasNameGenerator(db.pipelineStatuses.stageId, db.pipelineStages.id),
      );

  $$PipelineStagesTableProcessedTableManager get stageId {
    final $_column = $_itemColumn<String>('stage_id')!;

    final manager = $$PipelineStagesTableTableManager(
      $_db,
      $_db.pipelineStages,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_stageIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PipelineStatusesTableFilterComposer
    extends Composer<_$AppDatabase, $PipelineStatusesTable> {
  $$PipelineStatusesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$PipelineStagesTableFilterComposer get stageId {
    final $$PipelineStagesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.stageId,
      referencedTable: $db.pipelineStages,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelineStagesTableFilterComposer(
            $db: $db,
            $table: $db.pipelineStages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelineStatusesTableOrderingComposer
    extends Composer<_$AppDatabase, $PipelineStatusesTable> {
  $$PipelineStatusesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$PipelineStagesTableOrderingComposer get stageId {
    final $$PipelineStagesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.stageId,
      referencedTable: $db.pipelineStages,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelineStagesTableOrderingComposer(
            $db: $db,
            $table: $db.pipelineStages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelineStatusesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PipelineStatusesTable> {
  $$PipelineStatusesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sequence =>
      $composableBuilder(column: $table.sequence, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$PipelineStagesTableAnnotationComposer get stageId {
    final $$PipelineStagesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.stageId,
      referencedTable: $db.pipelineStages,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelineStagesTableAnnotationComposer(
            $db: $db,
            $table: $db.pipelineStages,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelineStatusesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PipelineStatusesTable,
          PipelineStatuse,
          $$PipelineStatusesTableFilterComposer,
          $$PipelineStatusesTableOrderingComposer,
          $$PipelineStatusesTableAnnotationComposer,
          $$PipelineStatusesTableCreateCompanionBuilder,
          $$PipelineStatusesTableUpdateCompanionBuilder,
          (PipelineStatuse, $$PipelineStatusesTableReferences),
          PipelineStatuse,
          PrefetchHooks Function({bool stageId})
        > {
  $$PipelineStatusesTableTableManager(
    _$AppDatabase db,
    $PipelineStatusesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PipelineStatusesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PipelineStatusesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PipelineStatusesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> stageId = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> sequence = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelineStatusesCompanion(
                id: id,
                stageId: stageId,
                code: code,
                name: name,
                description: description,
                sequence: sequence,
                isDefault: isDefault,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String stageId,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                required int sequence,
                Value<bool> isDefault = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => PipelineStatusesCompanion.insert(
                id: id,
                stageId: stageId,
                code: code,
                name: name,
                description: description,
                sequence: sequence,
                isDefault: isDefault,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PipelineStatusesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({stageId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (stageId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.stageId,
                                referencedTable:
                                    $$PipelineStatusesTableReferences
                                        ._stageIdTable(db),
                                referencedColumn:
                                    $$PipelineStatusesTableReferences
                                        ._stageIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$PipelineStatusesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PipelineStatusesTable,
      PipelineStatuse,
      $$PipelineStatusesTableFilterComposer,
      $$PipelineStatusesTableOrderingComposer,
      $$PipelineStatusesTableAnnotationComposer,
      $$PipelineStatusesTableCreateCompanionBuilder,
      $$PipelineStatusesTableUpdateCompanionBuilder,
      (PipelineStatuse, $$PipelineStatusesTableReferences),
      PipelineStatuse,
      PrefetchHooks Function({bool stageId})
    >;
typedef $$ActivityTypesTableCreateCompanionBuilder =
    ActivityTypesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> icon,
      Value<String?> color,
      Value<bool> requireLocation,
      Value<bool> requirePhoto,
      Value<bool> requireNotes,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$ActivityTypesTableUpdateCompanionBuilder =
    ActivityTypesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> icon,
      Value<String?> color,
      Value<bool> requireLocation,
      Value<bool> requirePhoto,
      Value<bool> requireNotes,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

class $$ActivityTypesTableFilterComposer
    extends Composer<_$AppDatabase, $ActivityTypesTable> {
  $$ActivityTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get icon => $composableBuilder(
    column: $table.icon,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get requireLocation => $composableBuilder(
    column: $table.requireLocation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get requirePhoto => $composableBuilder(
    column: $table.requirePhoto,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get requireNotes => $composableBuilder(
    column: $table.requireNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ActivityTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivityTypesTable> {
  $$ActivityTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get icon => $composableBuilder(
    column: $table.icon,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get requireLocation => $composableBuilder(
    column: $table.requireLocation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get requirePhoto => $composableBuilder(
    column: $table.requirePhoto,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get requireNotes => $composableBuilder(
    column: $table.requireNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActivityTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivityTypesTable> {
  $$ActivityTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get icon =>
      $composableBuilder(column: $table.icon, builder: (column) => column);

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<bool> get requireLocation => $composableBuilder(
    column: $table.requireLocation,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get requirePhoto => $composableBuilder(
    column: $table.requirePhoto,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get requireNotes => $composableBuilder(
    column: $table.requireNotes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$ActivityTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivityTypesTable,
          ActivityType,
          $$ActivityTypesTableFilterComposer,
          $$ActivityTypesTableOrderingComposer,
          $$ActivityTypesTableAnnotationComposer,
          $$ActivityTypesTableCreateCompanionBuilder,
          $$ActivityTypesTableUpdateCompanionBuilder,
          (
            ActivityType,
            BaseReferences<_$AppDatabase, $ActivityTypesTable, ActivityType>,
          ),
          ActivityType,
          PrefetchHooks Function()
        > {
  $$ActivityTypesTableTableManager(_$AppDatabase db, $ActivityTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivityTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivityTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivityTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> icon = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> requireLocation = const Value.absent(),
                Value<bool> requirePhoto = const Value.absent(),
                Value<bool> requireNotes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityTypesCompanion(
                id: id,
                code: code,
                name: name,
                icon: icon,
                color: color,
                requireLocation: requireLocation,
                requirePhoto: requirePhoto,
                requireNotes: requireNotes,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> icon = const Value.absent(),
                Value<String?> color = const Value.absent(),
                Value<bool> requireLocation = const Value.absent(),
                Value<bool> requirePhoto = const Value.absent(),
                Value<bool> requireNotes = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityTypesCompanion.insert(
                id: id,
                code: code,
                name: name,
                icon: icon,
                color: color,
                requireLocation: requireLocation,
                requirePhoto: requirePhoto,
                requireNotes: requireNotes,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ActivityTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivityTypesTable,
      ActivityType,
      $$ActivityTypesTableFilterComposer,
      $$ActivityTypesTableOrderingComposer,
      $$ActivityTypesTableAnnotationComposer,
      $$ActivityTypesTableCreateCompanionBuilder,
      $$ActivityTypesTableUpdateCompanionBuilder,
      (
        ActivityType,
        BaseReferences<_$AppDatabase, $ActivityTypesTable, ActivityType>,
      ),
      ActivityType,
      PrefetchHooks Function()
    >;
typedef $$LeadSourcesTableCreateCompanionBuilder =
    LeadSourcesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<bool> requiresReferrer,
      Value<bool> requiresBroker,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$LeadSourcesTableUpdateCompanionBuilder =
    LeadSourcesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<bool> requiresReferrer,
      Value<bool> requiresBroker,
      Value<bool> isActive,
      Value<int> rowid,
    });

class $$LeadSourcesTableFilterComposer
    extends Composer<_$AppDatabase, $LeadSourcesTable> {
  $$LeadSourcesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get requiresReferrer => $composableBuilder(
    column: $table.requiresReferrer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get requiresBroker => $composableBuilder(
    column: $table.requiresBroker,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );
}

class $$LeadSourcesTableOrderingComposer
    extends Composer<_$AppDatabase, $LeadSourcesTable> {
  $$LeadSourcesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get requiresReferrer => $composableBuilder(
    column: $table.requiresReferrer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get requiresBroker => $composableBuilder(
    column: $table.requiresBroker,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$LeadSourcesTableAnnotationComposer
    extends Composer<_$AppDatabase, $LeadSourcesTable> {
  $$LeadSourcesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get requiresReferrer => $composableBuilder(
    column: $table.requiresReferrer,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get requiresBroker => $composableBuilder(
    column: $table.requiresBroker,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$LeadSourcesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LeadSourcesTable,
          LeadSource,
          $$LeadSourcesTableFilterComposer,
          $$LeadSourcesTableOrderingComposer,
          $$LeadSourcesTableAnnotationComposer,
          $$LeadSourcesTableCreateCompanionBuilder,
          $$LeadSourcesTableUpdateCompanionBuilder,
          (
            LeadSource,
            BaseReferences<_$AppDatabase, $LeadSourcesTable, LeadSource>,
          ),
          LeadSource,
          PrefetchHooks Function()
        > {
  $$LeadSourcesTableTableManager(_$AppDatabase db, $LeadSourcesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LeadSourcesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LeadSourcesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LeadSourcesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<bool> requiresReferrer = const Value.absent(),
                Value<bool> requiresBroker = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LeadSourcesCompanion(
                id: id,
                code: code,
                name: name,
                requiresReferrer: requiresReferrer,
                requiresBroker: requiresBroker,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<bool> requiresReferrer = const Value.absent(),
                Value<bool> requiresBroker = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LeadSourcesCompanion.insert(
                id: id,
                code: code,
                name: name,
                requiresReferrer: requiresReferrer,
                requiresBroker: requiresBroker,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$LeadSourcesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LeadSourcesTable,
      LeadSource,
      $$LeadSourcesTableFilterComposer,
      $$LeadSourcesTableOrderingComposer,
      $$LeadSourcesTableAnnotationComposer,
      $$LeadSourcesTableCreateCompanionBuilder,
      $$LeadSourcesTableUpdateCompanionBuilder,
      (
        LeadSource,
        BaseReferences<_$AppDatabase, $LeadSourcesTable, LeadSource>,
      ),
      LeadSource,
      PrefetchHooks Function()
    >;
typedef $$DeclineReasonsTableCreateCompanionBuilder =
    DeclineReasonsCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$DeclineReasonsTableUpdateCompanionBuilder =
    DeclineReasonsCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

class $$DeclineReasonsTableFilterComposer
    extends Composer<_$AppDatabase, $DeclineReasonsTable> {
  $$DeclineReasonsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );
}

class $$DeclineReasonsTableOrderingComposer
    extends Composer<_$AppDatabase, $DeclineReasonsTable> {
  $$DeclineReasonsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$DeclineReasonsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DeclineReasonsTable> {
  $$DeclineReasonsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$DeclineReasonsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DeclineReasonsTable,
          DeclineReason,
          $$DeclineReasonsTableFilterComposer,
          $$DeclineReasonsTableOrderingComposer,
          $$DeclineReasonsTableAnnotationComposer,
          $$DeclineReasonsTableCreateCompanionBuilder,
          $$DeclineReasonsTableUpdateCompanionBuilder,
          (
            DeclineReason,
            BaseReferences<_$AppDatabase, $DeclineReasonsTable, DeclineReason>,
          ),
          DeclineReason,
          PrefetchHooks Function()
        > {
  $$DeclineReasonsTableTableManager(
    _$AppDatabase db,
    $DeclineReasonsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DeclineReasonsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DeclineReasonsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DeclineReasonsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => DeclineReasonsCompanion(
                id: id,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => DeclineReasonsCompanion.insert(
                id: id,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$DeclineReasonsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DeclineReasonsTable,
      DeclineReason,
      $$DeclineReasonsTableFilterComposer,
      $$DeclineReasonsTableOrderingComposer,
      $$DeclineReasonsTableAnnotationComposer,
      $$DeclineReasonsTableCreateCompanionBuilder,
      $$DeclineReasonsTableUpdateCompanionBuilder,
      (
        DeclineReason,
        BaseReferences<_$AppDatabase, $DeclineReasonsTable, DeclineReason>,
      ),
      DeclineReason,
      PrefetchHooks Function()
    >;
typedef $$CustomersTableCreateCompanionBuilder =
    CustomersCompanion Function({
      required String id,
      required String code,
      required String name,
      required String address,
      required String provinceId,
      required String cityId,
      Value<String?> postalCode,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> website,
      required String companyTypeId,
      required String ownershipTypeId,
      required String industryId,
      Value<String?> npwp,
      required String assignedRmId,
      Value<String?> imageUrl,
      Value<String?> notes,
      Value<bool> isActive,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$CustomersTableUpdateCompanionBuilder =
    CustomersCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String> address,
      Value<String> provinceId,
      Value<String> cityId,
      Value<String?> postalCode,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> website,
      Value<String> companyTypeId,
      Value<String> ownershipTypeId,
      Value<String> industryId,
      Value<String?> npwp,
      Value<String> assignedRmId,
      Value<String?> imageUrl,
      Value<String?> notes,
      Value<bool> isActive,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$CustomersTableReferences
    extends BaseReferences<_$AppDatabase, $CustomersTable, Customer> {
  $$CustomersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _assignedRmIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.customers.assignedRmId, db.users.id),
      );

  $$UsersTableProcessedTableManager get assignedRmId {
    final $_column = $_itemColumn<String>('assigned_rm_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_assignedRmIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.customers.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$PipelinesTable, List<Pipeline>>
  _pipelinesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.pipelines,
    aliasName: $_aliasNameGenerator(db.customers.id, db.pipelines.customerId),
  );

  $$PipelinesTableProcessedTableManager get pipelinesRefs {
    final manager = $$PipelinesTableTableManager(
      $_db,
      $_db.pipelines,
    ).filter((f) => f.customerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_pipelinesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PipelineReferralsTable, List<PipelineReferral>>
  _pipelineReferralsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.pipelineReferrals,
        aliasName: $_aliasNameGenerator(
          db.customers.id,
          db.pipelineReferrals.customerId,
        ),
      );

  $$PipelineReferralsTableProcessedTableManager get pipelineReferralsRefs {
    final manager = $$PipelineReferralsTableTableManager(
      $_db,
      $_db.pipelineReferrals,
    ).filter((f) => f.customerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _pipelineReferralsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ActivitiesTable, List<Activity>>
  _activitiesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activities,
    aliasName: $_aliasNameGenerator(db.customers.id, db.activities.customerId),
  );

  $$ActivitiesTableProcessedTableManager get activitiesRefs {
    final manager = $$ActivitiesTableTableManager(
      $_db,
      $_db.activities,
    ).filter((f) => f.customerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activitiesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CustomersTableFilterComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get provinceId => $composableBuilder(
    column: $table.provinceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cityId => $composableBuilder(
    column: $table.cityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get postalCode => $composableBuilder(
    column: $table.postalCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get website => $composableBuilder(
    column: $table.website,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get companyTypeId => $composableBuilder(
    column: $table.companyTypeId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ownershipTypeId => $composableBuilder(
    column: $table.ownershipTypeId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get industryId => $composableBuilder(
    column: $table.industryId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get npwp => $composableBuilder(
    column: $table.npwp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get assignedRmId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> pipelinesRefs(
    Expression<bool> Function($$PipelinesTableFilterComposer f) f,
  ) {
    final $$PipelinesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.pipelines,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelinesTableFilterComposer(
            $db: $db,
            $table: $db.pipelines,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> pipelineReferralsRefs(
    Expression<bool> Function($$PipelineReferralsTableFilterComposer f) f,
  ) {
    final $$PipelineReferralsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.pipelineReferrals,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelineReferralsTableFilterComposer(
            $db: $db,
            $table: $db.pipelineReferrals,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> activitiesRefs(
    Expression<bool> Function($$ActivitiesTableFilterComposer f) f,
  ) {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableFilterComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomersTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get provinceId => $composableBuilder(
    column: $table.provinceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cityId => $composableBuilder(
    column: $table.cityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get postalCode => $composableBuilder(
    column: $table.postalCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get website => $composableBuilder(
    column: $table.website,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get companyTypeId => $composableBuilder(
    column: $table.companyTypeId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ownershipTypeId => $composableBuilder(
    column: $table.ownershipTypeId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get industryId => $composableBuilder(
    column: $table.industryId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get npwp => $composableBuilder(
    column: $table.npwp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get assignedRmId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CustomersTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomersTable> {
  $$CustomersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get provinceId => $composableBuilder(
    column: $table.provinceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cityId =>
      $composableBuilder(column: $table.cityId, builder: (column) => column);

  GeneratedColumn<String> get postalCode => $composableBuilder(
    column: $table.postalCode,
    builder: (column) => column,
  );

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get website =>
      $composableBuilder(column: $table.website, builder: (column) => column);

  GeneratedColumn<String> get companyTypeId => $composableBuilder(
    column: $table.companyTypeId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get ownershipTypeId => $composableBuilder(
    column: $table.ownershipTypeId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get industryId => $composableBuilder(
    column: $table.industryId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get npwp =>
      $composableBuilder(column: $table.npwp, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get assignedRmId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> pipelinesRefs<T extends Object>(
    Expression<T> Function($$PipelinesTableAnnotationComposer a) f,
  ) {
    final $$PipelinesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.pipelines,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelinesTableAnnotationComposer(
            $db: $db,
            $table: $db.pipelines,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> pipelineReferralsRefs<T extends Object>(
    Expression<T> Function($$PipelineReferralsTableAnnotationComposer a) f,
  ) {
    final $$PipelineReferralsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.pipelineReferrals,
          getReferencedColumn: (t) => t.customerId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$PipelineReferralsTableAnnotationComposer(
                $db: $db,
                $table: $db.pipelineReferrals,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> activitiesRefs<T extends Object>(
    Expression<T> Function($$ActivitiesTableAnnotationComposer a) f,
  ) {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.customerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CustomersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CustomersTable,
          Customer,
          $$CustomersTableFilterComposer,
          $$CustomersTableOrderingComposer,
          $$CustomersTableAnnotationComposer,
          $$CustomersTableCreateCompanionBuilder,
          $$CustomersTableUpdateCompanionBuilder,
          (Customer, $$CustomersTableReferences),
          Customer,
          PrefetchHooks Function({
            bool assignedRmId,
            bool createdBy,
            bool pipelinesRefs,
            bool pipelineReferralsRefs,
            bool activitiesRefs,
          })
        > {
  $$CustomersTableTableManager(_$AppDatabase db, $CustomersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> address = const Value.absent(),
                Value<String> provinceId = const Value.absent(),
                Value<String> cityId = const Value.absent(),
                Value<String?> postalCode = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> website = const Value.absent(),
                Value<String> companyTypeId = const Value.absent(),
                Value<String> ownershipTypeId = const Value.absent(),
                Value<String> industryId = const Value.absent(),
                Value<String?> npwp = const Value.absent(),
                Value<String> assignedRmId = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomersCompanion(
                id: id,
                code: code,
                name: name,
                address: address,
                provinceId: provinceId,
                cityId: cityId,
                postalCode: postalCode,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                email: email,
                website: website,
                companyTypeId: companyTypeId,
                ownershipTypeId: ownershipTypeId,
                industryId: industryId,
                npwp: npwp,
                assignedRmId: assignedRmId,
                imageUrl: imageUrl,
                notes: notes,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                required String address,
                required String provinceId,
                required String cityId,
                Value<String?> postalCode = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> website = const Value.absent(),
                required String companyTypeId,
                required String ownershipTypeId,
                required String industryId,
                Value<String?> npwp = const Value.absent(),
                required String assignedRmId,
                Value<String?> imageUrl = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomersCompanion.insert(
                id: id,
                code: code,
                name: name,
                address: address,
                provinceId: provinceId,
                cityId: cityId,
                postalCode: postalCode,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                email: email,
                website: website,
                companyTypeId: companyTypeId,
                ownershipTypeId: ownershipTypeId,
                industryId: industryId,
                npwp: npwp,
                assignedRmId: assignedRmId,
                imageUrl: imageUrl,
                notes: notes,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CustomersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                assignedRmId = false,
                createdBy = false,
                pipelinesRefs = false,
                pipelineReferralsRefs = false,
                activitiesRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (pipelinesRefs) db.pipelines,
                    if (pipelineReferralsRefs) db.pipelineReferrals,
                    if (activitiesRefs) db.activities,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (assignedRmId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.assignedRmId,
                                    referencedTable: $$CustomersTableReferences
                                        ._assignedRmIdTable(db),
                                    referencedColumn: $$CustomersTableReferences
                                        ._assignedRmIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (createdBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.createdBy,
                                    referencedTable: $$CustomersTableReferences
                                        ._createdByTable(db),
                                    referencedColumn: $$CustomersTableReferences
                                        ._createdByTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (pipelinesRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          Pipeline
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._pipelinesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).pipelinesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (pipelineReferralsRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          PipelineReferral
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._pipelineReferralsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).pipelineReferralsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (activitiesRefs)
                        await $_getPrefetchedData<
                          Customer,
                          $CustomersTable,
                          Activity
                        >(
                          currentTable: table,
                          referencedTable: $$CustomersTableReferences
                              ._activitiesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CustomersTableReferences(
                                db,
                                table,
                                p0,
                              ).activitiesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.customerId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$CustomersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CustomersTable,
      Customer,
      $$CustomersTableFilterComposer,
      $$CustomersTableOrderingComposer,
      $$CustomersTableAnnotationComposer,
      $$CustomersTableCreateCompanionBuilder,
      $$CustomersTableUpdateCompanionBuilder,
      (Customer, $$CustomersTableReferences),
      Customer,
      PrefetchHooks Function({
        bool assignedRmId,
        bool createdBy,
        bool pipelinesRefs,
        bool pipelineReferralsRefs,
        bool activitiesRefs,
      })
    >;
typedef $$KeyPersonsTableCreateCompanionBuilder =
    KeyPersonsCompanion Function({
      required String id,
      required String ownerType,
      Value<String?> customerId,
      Value<String?> brokerId,
      Value<String?> hvcId,
      required String name,
      Value<String?> position,
      Value<String?> department,
      Value<String?> phone,
      Value<String?> email,
      Value<bool> isPrimary,
      Value<bool> isActive,
      Value<String?> notes,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$KeyPersonsTableUpdateCompanionBuilder =
    KeyPersonsCompanion Function({
      Value<String> id,
      Value<String> ownerType,
      Value<String?> customerId,
      Value<String?> brokerId,
      Value<String?> hvcId,
      Value<String> name,
      Value<String?> position,
      Value<String?> department,
      Value<String?> phone,
      Value<String?> email,
      Value<bool> isPrimary,
      Value<bool> isActive,
      Value<String?> notes,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$KeyPersonsTableReferences
    extends BaseReferences<_$AppDatabase, $KeyPersonsTable, KeyPerson> {
  $$KeyPersonsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.keyPersons.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$KeyPersonsTableFilterComposer
    extends Composer<_$AppDatabase, $KeyPersonsTable> {
  $$KeyPersonsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ownerType => $composableBuilder(
    column: $table.ownerType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brokerId => $composableBuilder(
    column: $table.brokerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get hvcId => $composableBuilder(
    column: $table.hvcId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get position => $composableBuilder(
    column: $table.position,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get department => $composableBuilder(
    column: $table.department,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPrimary => $composableBuilder(
    column: $table.isPrimary,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$KeyPersonsTableOrderingComposer
    extends Composer<_$AppDatabase, $KeyPersonsTable> {
  $$KeyPersonsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ownerType => $composableBuilder(
    column: $table.ownerType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brokerId => $composableBuilder(
    column: $table.brokerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get hvcId => $composableBuilder(
    column: $table.hvcId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get position => $composableBuilder(
    column: $table.position,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get department => $composableBuilder(
    column: $table.department,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPrimary => $composableBuilder(
    column: $table.isPrimary,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$KeyPersonsTableAnnotationComposer
    extends Composer<_$AppDatabase, $KeyPersonsTable> {
  $$KeyPersonsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get ownerType =>
      $composableBuilder(column: $table.ownerType, builder: (column) => column);

  GeneratedColumn<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brokerId =>
      $composableBuilder(column: $table.brokerId, builder: (column) => column);

  GeneratedColumn<String> get hvcId =>
      $composableBuilder(column: $table.hvcId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get position =>
      $composableBuilder(column: $table.position, builder: (column) => column);

  GeneratedColumn<String> get department => $composableBuilder(
    column: $table.department,
    builder: (column) => column,
  );

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<bool> get isPrimary =>
      $composableBuilder(column: $table.isPrimary, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$KeyPersonsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $KeyPersonsTable,
          KeyPerson,
          $$KeyPersonsTableFilterComposer,
          $$KeyPersonsTableOrderingComposer,
          $$KeyPersonsTableAnnotationComposer,
          $$KeyPersonsTableCreateCompanionBuilder,
          $$KeyPersonsTableUpdateCompanionBuilder,
          (KeyPerson, $$KeyPersonsTableReferences),
          KeyPerson,
          PrefetchHooks Function({bool createdBy})
        > {
  $$KeyPersonsTableTableManager(_$AppDatabase db, $KeyPersonsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$KeyPersonsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$KeyPersonsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$KeyPersonsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> ownerType = const Value.absent(),
                Value<String?> customerId = const Value.absent(),
                Value<String?> brokerId = const Value.absent(),
                Value<String?> hvcId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> position = const Value.absent(),
                Value<String?> department = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<bool> isPrimary = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KeyPersonsCompanion(
                id: id,
                ownerType: ownerType,
                customerId: customerId,
                brokerId: brokerId,
                hvcId: hvcId,
                name: name,
                position: position,
                department: department,
                phone: phone,
                email: email,
                isPrimary: isPrimary,
                isActive: isActive,
                notes: notes,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String ownerType,
                Value<String?> customerId = const Value.absent(),
                Value<String?> brokerId = const Value.absent(),
                Value<String?> hvcId = const Value.absent(),
                required String name,
                Value<String?> position = const Value.absent(),
                Value<String?> department = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<bool> isPrimary = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KeyPersonsCompanion.insert(
                id: id,
                ownerType: ownerType,
                customerId: customerId,
                brokerId: brokerId,
                hvcId: hvcId,
                name: name,
                position: position,
                department: department,
                phone: phone,
                email: email,
                isPrimary: isPrimary,
                isActive: isActive,
                notes: notes,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$KeyPersonsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({createdBy = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (createdBy) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.createdBy,
                                referencedTable: $$KeyPersonsTableReferences
                                    ._createdByTable(db),
                                referencedColumn: $$KeyPersonsTableReferences
                                    ._createdByTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$KeyPersonsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $KeyPersonsTable,
      KeyPerson,
      $$KeyPersonsTableFilterComposer,
      $$KeyPersonsTableOrderingComposer,
      $$KeyPersonsTableAnnotationComposer,
      $$KeyPersonsTableCreateCompanionBuilder,
      $$KeyPersonsTableUpdateCompanionBuilder,
      (KeyPerson, $$KeyPersonsTableReferences),
      KeyPerson,
      PrefetchHooks Function({bool createdBy})
    >;
typedef $$PipelinesTableCreateCompanionBuilder =
    PipelinesCompanion Function({
      required String id,
      required String code,
      required String customerId,
      required String stageId,
      required String statusId,
      required String cobId,
      required String lobId,
      required String leadSourceId,
      Value<String?> brokerId,
      Value<String?> brokerPicId,
      Value<String?> customerContactId,
      Value<double?> tsi,
      required double potentialPremium,
      Value<double?> finalPremium,
      Value<double?> weightedValue,
      Value<DateTime?> expectedCloseDate,
      Value<String?> policyNumber,
      Value<String?> declineReason,
      Value<String?> notes,
      Value<bool> isTender,
      Value<String?> referredByUserId,
      Value<String?> referralId,
      required String assignedRmId,
      Value<String?> scoredToUserId,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> closedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$PipelinesTableUpdateCompanionBuilder =
    PipelinesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> customerId,
      Value<String> stageId,
      Value<String> statusId,
      Value<String> cobId,
      Value<String> lobId,
      Value<String> leadSourceId,
      Value<String?> brokerId,
      Value<String?> brokerPicId,
      Value<String?> customerContactId,
      Value<double?> tsi,
      Value<double> potentialPremium,
      Value<double?> finalPremium,
      Value<double?> weightedValue,
      Value<DateTime?> expectedCloseDate,
      Value<String?> policyNumber,
      Value<String?> declineReason,
      Value<String?> notes,
      Value<bool> isTender,
      Value<String?> referredByUserId,
      Value<String?> referralId,
      Value<String> assignedRmId,
      Value<String?> scoredToUserId,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> closedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$PipelinesTableReferences
    extends BaseReferences<_$AppDatabase, $PipelinesTable, Pipeline> {
  $$PipelinesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.pipelines.customerId, db.customers.id),
      );

  $$CustomersTableProcessedTableManager get customerId {
    final $_column = $_itemColumn<String>('customer_id')!;

    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _referredByUserIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.pipelines.referredByUserId, db.users.id),
      );

  $$UsersTableProcessedTableManager? get referredByUserId {
    final $_column = $_itemColumn<String>('referred_by_user_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_referredByUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _assignedRmIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.pipelines.assignedRmId, db.users.id),
      );

  $$UsersTableProcessedTableManager get assignedRmId {
    final $_column = $_itemColumn<String>('assigned_rm_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_assignedRmIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _scoredToUserIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.pipelines.scoredToUserId, db.users.id),
      );

  $$UsersTableProcessedTableManager? get scoredToUserId {
    final $_column = $_itemColumn<String>('scored_to_user_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_scoredToUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.pipelines.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ActivitiesTable, List<Activity>>
  _activitiesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activities,
    aliasName: $_aliasNameGenerator(db.pipelines.id, db.activities.pipelineId),
  );

  $$ActivitiesTableProcessedTableManager get activitiesRefs {
    final manager = $$ActivitiesTableTableManager(
      $_db,
      $_db.activities,
    ).filter((f) => f.pipelineId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activitiesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$PipelinesTableFilterComposer
    extends Composer<_$AppDatabase, $PipelinesTable> {
  $$PipelinesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get stageId => $composableBuilder(
    column: $table.stageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get statusId => $composableBuilder(
    column: $table.statusId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cobId => $composableBuilder(
    column: $table.cobId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lobId => $composableBuilder(
    column: $table.lobId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get leadSourceId => $composableBuilder(
    column: $table.leadSourceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brokerId => $composableBuilder(
    column: $table.brokerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brokerPicId => $composableBuilder(
    column: $table.brokerPicId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerContactId => $composableBuilder(
    column: $table.customerContactId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get tsi => $composableBuilder(
    column: $table.tsi,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get potentialPremium => $composableBuilder(
    column: $table.potentialPremium,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get finalPremium => $composableBuilder(
    column: $table.finalPremium,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get weightedValue => $composableBuilder(
    column: $table.weightedValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expectedCloseDate => $composableBuilder(
    column: $table.expectedCloseDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get policyNumber => $composableBuilder(
    column: $table.policyNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get declineReason => $composableBuilder(
    column: $table.declineReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isTender => $composableBuilder(
    column: $table.isTender,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referralId => $composableBuilder(
    column: $table.referralId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get closedAt => $composableBuilder(
    column: $table.closedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get referredByUserId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.referredByUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get assignedRmId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get scoredToUserId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.scoredToUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> activitiesRefs(
    Expression<bool> Function($$ActivitiesTableFilterComposer f) f,
  ) {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.pipelineId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableFilterComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PipelinesTableOrderingComposer
    extends Composer<_$AppDatabase, $PipelinesTable> {
  $$PipelinesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get stageId => $composableBuilder(
    column: $table.stageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get statusId => $composableBuilder(
    column: $table.statusId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cobId => $composableBuilder(
    column: $table.cobId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lobId => $composableBuilder(
    column: $table.lobId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get leadSourceId => $composableBuilder(
    column: $table.leadSourceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brokerId => $composableBuilder(
    column: $table.brokerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brokerPicId => $composableBuilder(
    column: $table.brokerPicId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerContactId => $composableBuilder(
    column: $table.customerContactId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get tsi => $composableBuilder(
    column: $table.tsi,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get potentialPremium => $composableBuilder(
    column: $table.potentialPremium,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get finalPremium => $composableBuilder(
    column: $table.finalPremium,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get weightedValue => $composableBuilder(
    column: $table.weightedValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expectedCloseDate => $composableBuilder(
    column: $table.expectedCloseDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get policyNumber => $composableBuilder(
    column: $table.policyNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get declineReason => $composableBuilder(
    column: $table.declineReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isTender => $composableBuilder(
    column: $table.isTender,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referralId => $composableBuilder(
    column: $table.referralId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get closedAt => $composableBuilder(
    column: $table.closedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get referredByUserId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.referredByUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get assignedRmId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get scoredToUserId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.scoredToUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelinesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PipelinesTable> {
  $$PipelinesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get stageId =>
      $composableBuilder(column: $table.stageId, builder: (column) => column);

  GeneratedColumn<String> get statusId =>
      $composableBuilder(column: $table.statusId, builder: (column) => column);

  GeneratedColumn<String> get cobId =>
      $composableBuilder(column: $table.cobId, builder: (column) => column);

  GeneratedColumn<String> get lobId =>
      $composableBuilder(column: $table.lobId, builder: (column) => column);

  GeneratedColumn<String> get leadSourceId => $composableBuilder(
    column: $table.leadSourceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get brokerId =>
      $composableBuilder(column: $table.brokerId, builder: (column) => column);

  GeneratedColumn<String> get brokerPicId => $composableBuilder(
    column: $table.brokerPicId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get customerContactId => $composableBuilder(
    column: $table.customerContactId,
    builder: (column) => column,
  );

  GeneratedColumn<double> get tsi =>
      $composableBuilder(column: $table.tsi, builder: (column) => column);

  GeneratedColumn<double> get potentialPremium => $composableBuilder(
    column: $table.potentialPremium,
    builder: (column) => column,
  );

  GeneratedColumn<double> get finalPremium => $composableBuilder(
    column: $table.finalPremium,
    builder: (column) => column,
  );

  GeneratedColumn<double> get weightedValue => $composableBuilder(
    column: $table.weightedValue,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expectedCloseDate => $composableBuilder(
    column: $table.expectedCloseDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get policyNumber => $composableBuilder(
    column: $table.policyNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get declineReason => $composableBuilder(
    column: $table.declineReason,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isTender =>
      $composableBuilder(column: $table.isTender, builder: (column) => column);

  GeneratedColumn<String> get referralId => $composableBuilder(
    column: $table.referralId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get closedAt =>
      $composableBuilder(column: $table.closedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get referredByUserId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.referredByUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get assignedRmId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get scoredToUserId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.scoredToUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> activitiesRefs<T extends Object>(
    Expression<T> Function($$ActivitiesTableAnnotationComposer a) f,
  ) {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.pipelineId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$PipelinesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PipelinesTable,
          Pipeline,
          $$PipelinesTableFilterComposer,
          $$PipelinesTableOrderingComposer,
          $$PipelinesTableAnnotationComposer,
          $$PipelinesTableCreateCompanionBuilder,
          $$PipelinesTableUpdateCompanionBuilder,
          (Pipeline, $$PipelinesTableReferences),
          Pipeline,
          PrefetchHooks Function({
            bool customerId,
            bool referredByUserId,
            bool assignedRmId,
            bool scoredToUserId,
            bool createdBy,
            bool activitiesRefs,
          })
        > {
  $$PipelinesTableTableManager(_$AppDatabase db, $PipelinesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PipelinesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PipelinesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PipelinesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> customerId = const Value.absent(),
                Value<String> stageId = const Value.absent(),
                Value<String> statusId = const Value.absent(),
                Value<String> cobId = const Value.absent(),
                Value<String> lobId = const Value.absent(),
                Value<String> leadSourceId = const Value.absent(),
                Value<String?> brokerId = const Value.absent(),
                Value<String?> brokerPicId = const Value.absent(),
                Value<String?> customerContactId = const Value.absent(),
                Value<double?> tsi = const Value.absent(),
                Value<double> potentialPremium = const Value.absent(),
                Value<double?> finalPremium = const Value.absent(),
                Value<double?> weightedValue = const Value.absent(),
                Value<DateTime?> expectedCloseDate = const Value.absent(),
                Value<String?> policyNumber = const Value.absent(),
                Value<String?> declineReason = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isTender = const Value.absent(),
                Value<String?> referredByUserId = const Value.absent(),
                Value<String?> referralId = const Value.absent(),
                Value<String> assignedRmId = const Value.absent(),
                Value<String?> scoredToUserId = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> closedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelinesCompanion(
                id: id,
                code: code,
                customerId: customerId,
                stageId: stageId,
                statusId: statusId,
                cobId: cobId,
                lobId: lobId,
                leadSourceId: leadSourceId,
                brokerId: brokerId,
                brokerPicId: brokerPicId,
                customerContactId: customerContactId,
                tsi: tsi,
                potentialPremium: potentialPremium,
                finalPremium: finalPremium,
                weightedValue: weightedValue,
                expectedCloseDate: expectedCloseDate,
                policyNumber: policyNumber,
                declineReason: declineReason,
                notes: notes,
                isTender: isTender,
                referredByUserId: referredByUserId,
                referralId: referralId,
                assignedRmId: assignedRmId,
                scoredToUserId: scoredToUserId,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                closedAt: closedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String customerId,
                required String stageId,
                required String statusId,
                required String cobId,
                required String lobId,
                required String leadSourceId,
                Value<String?> brokerId = const Value.absent(),
                Value<String?> brokerPicId = const Value.absent(),
                Value<String?> customerContactId = const Value.absent(),
                Value<double?> tsi = const Value.absent(),
                required double potentialPremium,
                Value<double?> finalPremium = const Value.absent(),
                Value<double?> weightedValue = const Value.absent(),
                Value<DateTime?> expectedCloseDate = const Value.absent(),
                Value<String?> policyNumber = const Value.absent(),
                Value<String?> declineReason = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isTender = const Value.absent(),
                Value<String?> referredByUserId = const Value.absent(),
                Value<String?> referralId = const Value.absent(),
                required String assignedRmId,
                Value<String?> scoredToUserId = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> closedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelinesCompanion.insert(
                id: id,
                code: code,
                customerId: customerId,
                stageId: stageId,
                statusId: statusId,
                cobId: cobId,
                lobId: lobId,
                leadSourceId: leadSourceId,
                brokerId: brokerId,
                brokerPicId: brokerPicId,
                customerContactId: customerContactId,
                tsi: tsi,
                potentialPremium: potentialPremium,
                finalPremium: finalPremium,
                weightedValue: weightedValue,
                expectedCloseDate: expectedCloseDate,
                policyNumber: policyNumber,
                declineReason: declineReason,
                notes: notes,
                isTender: isTender,
                referredByUserId: referredByUserId,
                referralId: referralId,
                assignedRmId: assignedRmId,
                scoredToUserId: scoredToUserId,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                closedAt: closedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PipelinesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                customerId = false,
                referredByUserId = false,
                assignedRmId = false,
                scoredToUserId = false,
                createdBy = false,
                activitiesRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [if (activitiesRefs) db.activities],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable: $$PipelinesTableReferences
                                        ._customerIdTable(db),
                                    referencedColumn: $$PipelinesTableReferences
                                        ._customerIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (referredByUserId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.referredByUserId,
                                    referencedTable: $$PipelinesTableReferences
                                        ._referredByUserIdTable(db),
                                    referencedColumn: $$PipelinesTableReferences
                                        ._referredByUserIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (assignedRmId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.assignedRmId,
                                    referencedTable: $$PipelinesTableReferences
                                        ._assignedRmIdTable(db),
                                    referencedColumn: $$PipelinesTableReferences
                                        ._assignedRmIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (scoredToUserId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.scoredToUserId,
                                    referencedTable: $$PipelinesTableReferences
                                        ._scoredToUserIdTable(db),
                                    referencedColumn: $$PipelinesTableReferences
                                        ._scoredToUserIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (createdBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.createdBy,
                                    referencedTable: $$PipelinesTableReferences
                                        ._createdByTable(db),
                                    referencedColumn: $$PipelinesTableReferences
                                        ._createdByTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (activitiesRefs)
                        await $_getPrefetchedData<
                          Pipeline,
                          $PipelinesTable,
                          Activity
                        >(
                          currentTable: table,
                          referencedTable: $$PipelinesTableReferences
                              ._activitiesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$PipelinesTableReferences(
                                db,
                                table,
                                p0,
                              ).activitiesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.pipelineId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$PipelinesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PipelinesTable,
      Pipeline,
      $$PipelinesTableFilterComposer,
      $$PipelinesTableOrderingComposer,
      $$PipelinesTableAnnotationComposer,
      $$PipelinesTableCreateCompanionBuilder,
      $$PipelinesTableUpdateCompanionBuilder,
      (Pipeline, $$PipelinesTableReferences),
      Pipeline,
      PrefetchHooks Function({
        bool customerId,
        bool referredByUserId,
        bool assignedRmId,
        bool scoredToUserId,
        bool createdBy,
        bool activitiesRefs,
      })
    >;
typedef $$PipelineReferralsTableCreateCompanionBuilder =
    PipelineReferralsCompanion Function({
      required String id,
      required String code,
      required String customerId,
      required String referrerRmId,
      required String receiverRmId,
      Value<String?> referrerBranchId,
      Value<String?> receiverBranchId,
      Value<String?> referrerRegionalOfficeId,
      Value<String?> receiverRegionalOfficeId,
      Value<String> approverType,
      required String reason,
      Value<String?> notes,
      Value<String> status,
      Value<DateTime?> receiverAcceptedAt,
      Value<DateTime?> receiverRejectedAt,
      Value<String?> receiverRejectReason,
      Value<String?> receiverNotes,
      Value<DateTime?> bmApprovedAt,
      Value<String?> bmApprovedBy,
      Value<DateTime?> bmRejectedAt,
      Value<String?> bmRejectReason,
      Value<String?> bmNotes,
      Value<bool> bonusCalculated,
      Value<double?> bonusAmount,
      Value<DateTime?> expiresAt,
      Value<DateTime?> cancelledAt,
      Value<String?> cancelReason,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$PipelineReferralsTableUpdateCompanionBuilder =
    PipelineReferralsCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> customerId,
      Value<String> referrerRmId,
      Value<String> receiverRmId,
      Value<String?> referrerBranchId,
      Value<String?> receiverBranchId,
      Value<String?> referrerRegionalOfficeId,
      Value<String?> receiverRegionalOfficeId,
      Value<String> approverType,
      Value<String> reason,
      Value<String?> notes,
      Value<String> status,
      Value<DateTime?> receiverAcceptedAt,
      Value<DateTime?> receiverRejectedAt,
      Value<String?> receiverRejectReason,
      Value<String?> receiverNotes,
      Value<DateTime?> bmApprovedAt,
      Value<String?> bmApprovedBy,
      Value<DateTime?> bmRejectedAt,
      Value<String?> bmRejectReason,
      Value<String?> bmNotes,
      Value<bool> bonusCalculated,
      Value<double?> bonusAmount,
      Value<DateTime?> expiresAt,
      Value<DateTime?> cancelledAt,
      Value<String?> cancelReason,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$PipelineReferralsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $PipelineReferralsTable,
          PipelineReferral
        > {
  $$PipelineReferralsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.pipelineReferrals.customerId, db.customers.id),
      );

  $$CustomersTableProcessedTableManager get customerId {
    final $_column = $_itemColumn<String>('customer_id')!;

    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _referrerRmIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.pipelineReferrals.referrerRmId, db.users.id),
      );

  $$UsersTableProcessedTableManager get referrerRmId {
    final $_column = $_itemColumn<String>('referrer_rm_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_referrerRmIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _receiverRmIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.pipelineReferrals.receiverRmId, db.users.id),
      );

  $$UsersTableProcessedTableManager get receiverRmId {
    final $_column = $_itemColumn<String>('receiver_rm_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_receiverRmIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _bmApprovedByTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.pipelineReferrals.bmApprovedBy, db.users.id),
      );

  $$UsersTableProcessedTableManager? get bmApprovedBy {
    final $_column = $_itemColumn<String>('bm_approved_by');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bmApprovedByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PipelineReferralsTableFilterComposer
    extends Composer<_$AppDatabase, $PipelineReferralsTable> {
  $$PipelineReferralsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referrerBranchId => $composableBuilder(
    column: $table.referrerBranchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiverBranchId => $composableBuilder(
    column: $table.receiverBranchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get referrerRegionalOfficeId => $composableBuilder(
    column: $table.referrerRegionalOfficeId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiverRegionalOfficeId => $composableBuilder(
    column: $table.receiverRegionalOfficeId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get approverType => $composableBuilder(
    column: $table.approverType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get receiverAcceptedAt => $composableBuilder(
    column: $table.receiverAcceptedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get receiverRejectedAt => $composableBuilder(
    column: $table.receiverRejectedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiverRejectReason => $composableBuilder(
    column: $table.receiverRejectReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiverNotes => $composableBuilder(
    column: $table.receiverNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get bmApprovedAt => $composableBuilder(
    column: $table.bmApprovedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get bmRejectedAt => $composableBuilder(
    column: $table.bmRejectedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bmRejectReason => $composableBuilder(
    column: $table.bmRejectReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bmNotes => $composableBuilder(
    column: $table.bmNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get bonusCalculated => $composableBuilder(
    column: $table.bonusCalculated,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get bonusAmount => $composableBuilder(
    column: $table.bonusAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get cancelledAt => $composableBuilder(
    column: $table.cancelledAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cancelReason => $composableBuilder(
    column: $table.cancelReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get referrerRmId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.referrerRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get receiverRmId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiverRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get bmApprovedBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bmApprovedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelineReferralsTableOrderingComposer
    extends Composer<_$AppDatabase, $PipelineReferralsTable> {
  $$PipelineReferralsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referrerBranchId => $composableBuilder(
    column: $table.referrerBranchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiverBranchId => $composableBuilder(
    column: $table.receiverBranchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get referrerRegionalOfficeId => $composableBuilder(
    column: $table.referrerRegionalOfficeId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiverRegionalOfficeId => $composableBuilder(
    column: $table.receiverRegionalOfficeId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get approverType => $composableBuilder(
    column: $table.approverType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get receiverAcceptedAt => $composableBuilder(
    column: $table.receiverAcceptedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get receiverRejectedAt => $composableBuilder(
    column: $table.receiverRejectedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiverRejectReason => $composableBuilder(
    column: $table.receiverRejectReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiverNotes => $composableBuilder(
    column: $table.receiverNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get bmApprovedAt => $composableBuilder(
    column: $table.bmApprovedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get bmRejectedAt => $composableBuilder(
    column: $table.bmRejectedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bmRejectReason => $composableBuilder(
    column: $table.bmRejectReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bmNotes => $composableBuilder(
    column: $table.bmNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get bonusCalculated => $composableBuilder(
    column: $table.bonusCalculated,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get bonusAmount => $composableBuilder(
    column: $table.bonusAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get cancelledAt => $composableBuilder(
    column: $table.cancelledAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cancelReason => $composableBuilder(
    column: $table.cancelReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get referrerRmId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.referrerRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get receiverRmId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiverRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get bmApprovedBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bmApprovedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelineReferralsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PipelineReferralsTable> {
  $$PipelineReferralsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get referrerBranchId => $composableBuilder(
    column: $table.referrerBranchId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get receiverBranchId => $composableBuilder(
    column: $table.receiverBranchId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get referrerRegionalOfficeId => $composableBuilder(
    column: $table.referrerRegionalOfficeId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get receiverRegionalOfficeId => $composableBuilder(
    column: $table.receiverRegionalOfficeId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get approverType => $composableBuilder(
    column: $table.approverType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get receiverAcceptedAt => $composableBuilder(
    column: $table.receiverAcceptedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get receiverRejectedAt => $composableBuilder(
    column: $table.receiverRejectedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get receiverRejectReason => $composableBuilder(
    column: $table.receiverRejectReason,
    builder: (column) => column,
  );

  GeneratedColumn<String> get receiverNotes => $composableBuilder(
    column: $table.receiverNotes,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get bmApprovedAt => $composableBuilder(
    column: $table.bmApprovedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get bmRejectedAt => $composableBuilder(
    column: $table.bmRejectedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bmRejectReason => $composableBuilder(
    column: $table.bmRejectReason,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bmNotes =>
      $composableBuilder(column: $table.bmNotes, builder: (column) => column);

  GeneratedColumn<bool> get bonusCalculated => $composableBuilder(
    column: $table.bonusCalculated,
    builder: (column) => column,
  );

  GeneratedColumn<double> get bonusAmount => $composableBuilder(
    column: $table.bonusAmount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get cancelledAt => $composableBuilder(
    column: $table.cancelledAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cancelReason => $composableBuilder(
    column: $table.cancelReason,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get referrerRmId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.referrerRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get receiverRmId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.receiverRmId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get bmApprovedBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.bmApprovedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PipelineReferralsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PipelineReferralsTable,
          PipelineReferral,
          $$PipelineReferralsTableFilterComposer,
          $$PipelineReferralsTableOrderingComposer,
          $$PipelineReferralsTableAnnotationComposer,
          $$PipelineReferralsTableCreateCompanionBuilder,
          $$PipelineReferralsTableUpdateCompanionBuilder,
          (PipelineReferral, $$PipelineReferralsTableReferences),
          PipelineReferral,
          PrefetchHooks Function({
            bool customerId,
            bool referrerRmId,
            bool receiverRmId,
            bool bmApprovedBy,
          })
        > {
  $$PipelineReferralsTableTableManager(
    _$AppDatabase db,
    $PipelineReferralsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PipelineReferralsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PipelineReferralsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PipelineReferralsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> customerId = const Value.absent(),
                Value<String> referrerRmId = const Value.absent(),
                Value<String> receiverRmId = const Value.absent(),
                Value<String?> referrerBranchId = const Value.absent(),
                Value<String?> receiverBranchId = const Value.absent(),
                Value<String?> referrerRegionalOfficeId = const Value.absent(),
                Value<String?> receiverRegionalOfficeId = const Value.absent(),
                Value<String> approverType = const Value.absent(),
                Value<String> reason = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> receiverAcceptedAt = const Value.absent(),
                Value<DateTime?> receiverRejectedAt = const Value.absent(),
                Value<String?> receiverRejectReason = const Value.absent(),
                Value<String?> receiverNotes = const Value.absent(),
                Value<DateTime?> bmApprovedAt = const Value.absent(),
                Value<String?> bmApprovedBy = const Value.absent(),
                Value<DateTime?> bmRejectedAt = const Value.absent(),
                Value<String?> bmRejectReason = const Value.absent(),
                Value<String?> bmNotes = const Value.absent(),
                Value<bool> bonusCalculated = const Value.absent(),
                Value<double?> bonusAmount = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime?> cancelledAt = const Value.absent(),
                Value<String?> cancelReason = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelineReferralsCompanion(
                id: id,
                code: code,
                customerId: customerId,
                referrerRmId: referrerRmId,
                receiverRmId: receiverRmId,
                referrerBranchId: referrerBranchId,
                receiverBranchId: receiverBranchId,
                referrerRegionalOfficeId: referrerRegionalOfficeId,
                receiverRegionalOfficeId: receiverRegionalOfficeId,
                approverType: approverType,
                reason: reason,
                notes: notes,
                status: status,
                receiverAcceptedAt: receiverAcceptedAt,
                receiverRejectedAt: receiverRejectedAt,
                receiverRejectReason: receiverRejectReason,
                receiverNotes: receiverNotes,
                bmApprovedAt: bmApprovedAt,
                bmApprovedBy: bmApprovedBy,
                bmRejectedAt: bmRejectedAt,
                bmRejectReason: bmRejectReason,
                bmNotes: bmNotes,
                bonusCalculated: bonusCalculated,
                bonusAmount: bonusAmount,
                expiresAt: expiresAt,
                cancelledAt: cancelledAt,
                cancelReason: cancelReason,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String customerId,
                required String referrerRmId,
                required String receiverRmId,
                Value<String?> referrerBranchId = const Value.absent(),
                Value<String?> receiverBranchId = const Value.absent(),
                Value<String?> referrerRegionalOfficeId = const Value.absent(),
                Value<String?> receiverRegionalOfficeId = const Value.absent(),
                Value<String> approverType = const Value.absent(),
                required String reason,
                Value<String?> notes = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> receiverAcceptedAt = const Value.absent(),
                Value<DateTime?> receiverRejectedAt = const Value.absent(),
                Value<String?> receiverRejectReason = const Value.absent(),
                Value<String?> receiverNotes = const Value.absent(),
                Value<DateTime?> bmApprovedAt = const Value.absent(),
                Value<String?> bmApprovedBy = const Value.absent(),
                Value<DateTime?> bmRejectedAt = const Value.absent(),
                Value<String?> bmRejectReason = const Value.absent(),
                Value<String?> bmNotes = const Value.absent(),
                Value<bool> bonusCalculated = const Value.absent(),
                Value<double?> bonusAmount = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime?> cancelledAt = const Value.absent(),
                Value<String?> cancelReason = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelineReferralsCompanion.insert(
                id: id,
                code: code,
                customerId: customerId,
                referrerRmId: referrerRmId,
                receiverRmId: receiverRmId,
                referrerBranchId: referrerBranchId,
                receiverBranchId: receiverBranchId,
                referrerRegionalOfficeId: referrerRegionalOfficeId,
                receiverRegionalOfficeId: receiverRegionalOfficeId,
                approverType: approverType,
                reason: reason,
                notes: notes,
                status: status,
                receiverAcceptedAt: receiverAcceptedAt,
                receiverRejectedAt: receiverRejectedAt,
                receiverRejectReason: receiverRejectReason,
                receiverNotes: receiverNotes,
                bmApprovedAt: bmApprovedAt,
                bmApprovedBy: bmApprovedBy,
                bmRejectedAt: bmRejectedAt,
                bmRejectReason: bmRejectReason,
                bmNotes: bmNotes,
                bonusCalculated: bonusCalculated,
                bonusAmount: bonusAmount,
                expiresAt: expiresAt,
                cancelledAt: cancelledAt,
                cancelReason: cancelReason,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PipelineReferralsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                customerId = false,
                referrerRmId = false,
                receiverRmId = false,
                bmApprovedBy = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable:
                                        $$PipelineReferralsTableReferences
                                            ._customerIdTable(db),
                                    referencedColumn:
                                        $$PipelineReferralsTableReferences
                                            ._customerIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (referrerRmId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.referrerRmId,
                                    referencedTable:
                                        $$PipelineReferralsTableReferences
                                            ._referrerRmIdTable(db),
                                    referencedColumn:
                                        $$PipelineReferralsTableReferences
                                            ._referrerRmIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (receiverRmId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.receiverRmId,
                                    referencedTable:
                                        $$PipelineReferralsTableReferences
                                            ._receiverRmIdTable(db),
                                    referencedColumn:
                                        $$PipelineReferralsTableReferences
                                            ._receiverRmIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (bmApprovedBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.bmApprovedBy,
                                    referencedTable:
                                        $$PipelineReferralsTableReferences
                                            ._bmApprovedByTable(db),
                                    referencedColumn:
                                        $$PipelineReferralsTableReferences
                                            ._bmApprovedByTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$PipelineReferralsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PipelineReferralsTable,
      PipelineReferral,
      $$PipelineReferralsTableFilterComposer,
      $$PipelineReferralsTableOrderingComposer,
      $$PipelineReferralsTableAnnotationComposer,
      $$PipelineReferralsTableCreateCompanionBuilder,
      $$PipelineReferralsTableUpdateCompanionBuilder,
      (PipelineReferral, $$PipelineReferralsTableReferences),
      PipelineReferral,
      PrefetchHooks Function({
        bool customerId,
        bool referrerRmId,
        bool receiverRmId,
        bool bmApprovedBy,
      })
    >;
typedef $$ActivitiesTableCreateCompanionBuilder =
    ActivitiesCompanion Function({
      required String id,
      required String userId,
      required String createdBy,
      required String objectType,
      Value<String?> customerId,
      Value<String?> hvcId,
      Value<String?> brokerId,
      Value<String?> pipelineId,
      Value<String?> keyPersonId,
      required String activityTypeId,
      Value<String?> summary,
      Value<String?> notes,
      required DateTime scheduledDatetime,
      Value<bool> isImmediate,
      Value<String> status,
      Value<DateTime?> executedAt,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<double?> locationAccuracy,
      Value<double?> distanceFromTarget,
      Value<bool> isLocationOverride,
      Value<String?> overrideReason,
      Value<String?> rescheduledFromId,
      Value<String?> rescheduledToId,
      Value<DateTime?> cancelledAt,
      Value<String?> cancelReason,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> lastSyncAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });
typedef $$ActivitiesTableUpdateCompanionBuilder =
    ActivitiesCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> createdBy,
      Value<String> objectType,
      Value<String?> customerId,
      Value<String?> hvcId,
      Value<String?> brokerId,
      Value<String?> pipelineId,
      Value<String?> keyPersonId,
      Value<String> activityTypeId,
      Value<String?> summary,
      Value<String?> notes,
      Value<DateTime> scheduledDatetime,
      Value<bool> isImmediate,
      Value<String> status,
      Value<DateTime?> executedAt,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<double?> locationAccuracy,
      Value<double?> distanceFromTarget,
      Value<bool> isLocationOverride,
      Value<String?> overrideReason,
      Value<String?> rescheduledFromId,
      Value<String?> rescheduledToId,
      Value<DateTime?> cancelledAt,
      Value<String?> cancelReason,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> lastSyncAt,
      Value<DateTime?> deletedAt,
      Value<int> rowid,
    });

final class $$ActivitiesTableReferences
    extends BaseReferences<_$AppDatabase, $ActivitiesTable, Activity> {
  $$ActivitiesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.activities.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.activities.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CustomersTable _customerIdTable(_$AppDatabase db) =>
      db.customers.createAlias(
        $_aliasNameGenerator(db.activities.customerId, db.customers.id),
      );

  $$CustomersTableProcessedTableManager? get customerId {
    final $_column = $_itemColumn<String>('customer_id');
    if ($_column == null) return null;
    final manager = $$CustomersTableTableManager(
      $_db,
      $_db.customers,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $PipelinesTable _pipelineIdTable(_$AppDatabase db) =>
      db.pipelines.createAlias(
        $_aliasNameGenerator(db.activities.pipelineId, db.pipelines.id),
      );

  $$PipelinesTableProcessedTableManager? get pipelineId {
    final $_column = $_itemColumn<String>('pipeline_id');
    if ($_column == null) return null;
    final manager = $$PipelinesTableTableManager(
      $_db,
      $_db.pipelines,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_pipelineIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ActivityPhotosTable, List<ActivityPhoto>>
  _activityPhotosRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activityPhotos,
    aliasName: $_aliasNameGenerator(
      db.activities.id,
      db.activityPhotos.activityId,
    ),
  );

  $$ActivityPhotosTableProcessedTableManager get activityPhotosRefs {
    final manager = $$ActivityPhotosTableTableManager(
      $_db,
      $_db.activityPhotos,
    ).filter((f) => f.activityId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activityPhotosRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ActivityAuditLogsTable, List<ActivityAuditLog>>
  _activityAuditLogsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.activityAuditLogs,
        aliasName: $_aliasNameGenerator(
          db.activities.id,
          db.activityAuditLogs.activityId,
        ),
      );

  $$ActivityAuditLogsTableProcessedTableManager get activityAuditLogsRefs {
    final manager = $$ActivityAuditLogsTableTableManager(
      $_db,
      $_db.activityAuditLogs,
    ).filter((f) => f.activityId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _activityAuditLogsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ActivitiesTableFilterComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get objectType => $composableBuilder(
    column: $table.objectType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get hvcId => $composableBuilder(
    column: $table.hvcId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get brokerId => $composableBuilder(
    column: $table.brokerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get keyPersonId => $composableBuilder(
    column: $table.keyPersonId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get activityTypeId => $composableBuilder(
    column: $table.activityTypeId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get summary => $composableBuilder(
    column: $table.summary,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get scheduledDatetime => $composableBuilder(
    column: $table.scheduledDatetime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isImmediate => $composableBuilder(
    column: $table.isImmediate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get executedAt => $composableBuilder(
    column: $table.executedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get locationAccuracy => $composableBuilder(
    column: $table.locationAccuracy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get distanceFromTarget => $composableBuilder(
    column: $table.distanceFromTarget,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isLocationOverride => $composableBuilder(
    column: $table.isLocationOverride,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get overrideReason => $composableBuilder(
    column: $table.overrideReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rescheduledFromId => $composableBuilder(
    column: $table.rescheduledFromId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rescheduledToId => $composableBuilder(
    column: $table.rescheduledToId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get cancelledAt => $composableBuilder(
    column: $table.cancelledAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cancelReason => $composableBuilder(
    column: $table.cancelReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableFilterComposer get customerId {
    final $$CustomersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableFilterComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$PipelinesTableFilterComposer get pipelineId {
    final $$PipelinesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.pipelineId,
      referencedTable: $db.pipelines,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelinesTableFilterComposer(
            $db: $db,
            $table: $db.pipelines,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> activityPhotosRefs(
    Expression<bool> Function($$ActivityPhotosTableFilterComposer f) f,
  ) {
    final $$ActivityPhotosTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityPhotos,
      getReferencedColumn: (t) => t.activityId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityPhotosTableFilterComposer(
            $db: $db,
            $table: $db.activityPhotos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> activityAuditLogsRefs(
    Expression<bool> Function($$ActivityAuditLogsTableFilterComposer f) f,
  ) {
    final $$ActivityAuditLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityAuditLogs,
      getReferencedColumn: (t) => t.activityId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityAuditLogsTableFilterComposer(
            $db: $db,
            $table: $db.activityAuditLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ActivitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get objectType => $composableBuilder(
    column: $table.objectType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get hvcId => $composableBuilder(
    column: $table.hvcId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get brokerId => $composableBuilder(
    column: $table.brokerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get keyPersonId => $composableBuilder(
    column: $table.keyPersonId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get activityTypeId => $composableBuilder(
    column: $table.activityTypeId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get summary => $composableBuilder(
    column: $table.summary,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get scheduledDatetime => $composableBuilder(
    column: $table.scheduledDatetime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isImmediate => $composableBuilder(
    column: $table.isImmediate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get executedAt => $composableBuilder(
    column: $table.executedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get locationAccuracy => $composableBuilder(
    column: $table.locationAccuracy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get distanceFromTarget => $composableBuilder(
    column: $table.distanceFromTarget,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isLocationOverride => $composableBuilder(
    column: $table.isLocationOverride,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get overrideReason => $composableBuilder(
    column: $table.overrideReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rescheduledFromId => $composableBuilder(
    column: $table.rescheduledFromId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rescheduledToId => $composableBuilder(
    column: $table.rescheduledToId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get cancelledAt => $composableBuilder(
    column: $table.cancelledAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cancelReason => $composableBuilder(
    column: $table.cancelReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableOrderingComposer get customerId {
    final $$CustomersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableOrderingComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$PipelinesTableOrderingComposer get pipelineId {
    final $$PipelinesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.pipelineId,
      referencedTable: $db.pipelines,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelinesTableOrderingComposer(
            $db: $db,
            $table: $db.pipelines,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivitiesTable> {
  $$ActivitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get objectType => $composableBuilder(
    column: $table.objectType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get hvcId =>
      $composableBuilder(column: $table.hvcId, builder: (column) => column);

  GeneratedColumn<String> get brokerId =>
      $composableBuilder(column: $table.brokerId, builder: (column) => column);

  GeneratedColumn<String> get keyPersonId => $composableBuilder(
    column: $table.keyPersonId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get activityTypeId => $composableBuilder(
    column: $table.activityTypeId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get summary =>
      $composableBuilder(column: $table.summary, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get scheduledDatetime => $composableBuilder(
    column: $table.scheduledDatetime,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isImmediate => $composableBuilder(
    column: $table.isImmediate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get executedAt => $composableBuilder(
    column: $table.executedAt,
    builder: (column) => column,
  );

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get locationAccuracy => $composableBuilder(
    column: $table.locationAccuracy,
    builder: (column) => column,
  );

  GeneratedColumn<double> get distanceFromTarget => $composableBuilder(
    column: $table.distanceFromTarget,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isLocationOverride => $composableBuilder(
    column: $table.isLocationOverride,
    builder: (column) => column,
  );

  GeneratedColumn<String> get overrideReason => $composableBuilder(
    column: $table.overrideReason,
    builder: (column) => column,
  );

  GeneratedColumn<String> get rescheduledFromId => $composableBuilder(
    column: $table.rescheduledFromId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get rescheduledToId => $composableBuilder(
    column: $table.rescheduledToId,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get cancelledAt => $composableBuilder(
    column: $table.cancelledAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get cancelReason => $composableBuilder(
    column: $table.cancelReason,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CustomersTableAnnotationComposer get customerId {
    final $$CustomersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.customerId,
      referencedTable: $db.customers,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomersTableAnnotationComposer(
            $db: $db,
            $table: $db.customers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$PipelinesTableAnnotationComposer get pipelineId {
    final $$PipelinesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.pipelineId,
      referencedTable: $db.pipelines,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PipelinesTableAnnotationComposer(
            $db: $db,
            $table: $db.pipelines,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> activityPhotosRefs<T extends Object>(
    Expression<T> Function($$ActivityPhotosTableAnnotationComposer a) f,
  ) {
    final $$ActivityPhotosTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityPhotos,
      getReferencedColumn: (t) => t.activityId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityPhotosTableAnnotationComposer(
            $db: $db,
            $table: $db.activityPhotos,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> activityAuditLogsRefs<T extends Object>(
    Expression<T> Function($$ActivityAuditLogsTableAnnotationComposer a) f,
  ) {
    final $$ActivityAuditLogsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.activityAuditLogs,
          getReferencedColumn: (t) => t.activityId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$ActivityAuditLogsTableAnnotationComposer(
                $db: $db,
                $table: $db.activityAuditLogs,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ActivitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivitiesTable,
          Activity,
          $$ActivitiesTableFilterComposer,
          $$ActivitiesTableOrderingComposer,
          $$ActivitiesTableAnnotationComposer,
          $$ActivitiesTableCreateCompanionBuilder,
          $$ActivitiesTableUpdateCompanionBuilder,
          (Activity, $$ActivitiesTableReferences),
          Activity,
          PrefetchHooks Function({
            bool userId,
            bool createdBy,
            bool customerId,
            bool pipelineId,
            bool activityPhotosRefs,
            bool activityAuditLogsRefs,
          })
        > {
  $$ActivitiesTableTableManager(_$AppDatabase db, $ActivitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<String> objectType = const Value.absent(),
                Value<String?> customerId = const Value.absent(),
                Value<String?> hvcId = const Value.absent(),
                Value<String?> brokerId = const Value.absent(),
                Value<String?> pipelineId = const Value.absent(),
                Value<String?> keyPersonId = const Value.absent(),
                Value<String> activityTypeId = const Value.absent(),
                Value<String?> summary = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> scheduledDatetime = const Value.absent(),
                Value<bool> isImmediate = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> executedAt = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<double?> locationAccuracy = const Value.absent(),
                Value<double?> distanceFromTarget = const Value.absent(),
                Value<bool> isLocationOverride = const Value.absent(),
                Value<String?> overrideReason = const Value.absent(),
                Value<String?> rescheduledFromId = const Value.absent(),
                Value<String?> rescheduledToId = const Value.absent(),
                Value<DateTime?> cancelledAt = const Value.absent(),
                Value<String?> cancelReason = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivitiesCompanion(
                id: id,
                userId: userId,
                createdBy: createdBy,
                objectType: objectType,
                customerId: customerId,
                hvcId: hvcId,
                brokerId: brokerId,
                pipelineId: pipelineId,
                keyPersonId: keyPersonId,
                activityTypeId: activityTypeId,
                summary: summary,
                notes: notes,
                scheduledDatetime: scheduledDatetime,
                isImmediate: isImmediate,
                status: status,
                executedAt: executedAt,
                latitude: latitude,
                longitude: longitude,
                locationAccuracy: locationAccuracy,
                distanceFromTarget: distanceFromTarget,
                isLocationOverride: isLocationOverride,
                overrideReason: overrideReason,
                rescheduledFromId: rescheduledFromId,
                rescheduledToId: rescheduledToId,
                cancelledAt: cancelledAt,
                cancelReason: cancelReason,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                lastSyncAt: lastSyncAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String createdBy,
                required String objectType,
                Value<String?> customerId = const Value.absent(),
                Value<String?> hvcId = const Value.absent(),
                Value<String?> brokerId = const Value.absent(),
                Value<String?> pipelineId = const Value.absent(),
                Value<String?> keyPersonId = const Value.absent(),
                required String activityTypeId,
                Value<String?> summary = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                required DateTime scheduledDatetime,
                Value<bool> isImmediate = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime?> executedAt = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<double?> locationAccuracy = const Value.absent(),
                Value<double?> distanceFromTarget = const Value.absent(),
                Value<bool> isLocationOverride = const Value.absent(),
                Value<String?> overrideReason = const Value.absent(),
                Value<String?> rescheduledFromId = const Value.absent(),
                Value<String?> rescheduledToId = const Value.absent(),
                Value<DateTime?> cancelledAt = const Value.absent(),
                Value<String?> cancelReason = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivitiesCompanion.insert(
                id: id,
                userId: userId,
                createdBy: createdBy,
                objectType: objectType,
                customerId: customerId,
                hvcId: hvcId,
                brokerId: brokerId,
                pipelineId: pipelineId,
                keyPersonId: keyPersonId,
                activityTypeId: activityTypeId,
                summary: summary,
                notes: notes,
                scheduledDatetime: scheduledDatetime,
                isImmediate: isImmediate,
                status: status,
                executedAt: executedAt,
                latitude: latitude,
                longitude: longitude,
                locationAccuracy: locationAccuracy,
                distanceFromTarget: distanceFromTarget,
                isLocationOverride: isLocationOverride,
                overrideReason: overrideReason,
                rescheduledFromId: rescheduledFromId,
                rescheduledToId: rescheduledToId,
                cancelledAt: cancelledAt,
                cancelReason: cancelReason,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                lastSyncAt: lastSyncAt,
                deletedAt: deletedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ActivitiesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                userId = false,
                createdBy = false,
                customerId = false,
                pipelineId = false,
                activityPhotosRefs = false,
                activityAuditLogsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (activityPhotosRefs) db.activityPhotos,
                    if (activityAuditLogsRefs) db.activityAuditLogs,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$ActivitiesTableReferences
                                        ._userIdTable(db),
                                    referencedColumn:
                                        $$ActivitiesTableReferences
                                            ._userIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (createdBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.createdBy,
                                    referencedTable: $$ActivitiesTableReferences
                                        ._createdByTable(db),
                                    referencedColumn:
                                        $$ActivitiesTableReferences
                                            ._createdByTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (customerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.customerId,
                                    referencedTable: $$ActivitiesTableReferences
                                        ._customerIdTable(db),
                                    referencedColumn:
                                        $$ActivitiesTableReferences
                                            ._customerIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (pipelineId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.pipelineId,
                                    referencedTable: $$ActivitiesTableReferences
                                        ._pipelineIdTable(db),
                                    referencedColumn:
                                        $$ActivitiesTableReferences
                                            ._pipelineIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (activityPhotosRefs)
                        await $_getPrefetchedData<
                          Activity,
                          $ActivitiesTable,
                          ActivityPhoto
                        >(
                          currentTable: table,
                          referencedTable: $$ActivitiesTableReferences
                              ._activityPhotosRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ActivitiesTableReferences(
                                db,
                                table,
                                p0,
                              ).activityPhotosRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.activityId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (activityAuditLogsRefs)
                        await $_getPrefetchedData<
                          Activity,
                          $ActivitiesTable,
                          ActivityAuditLog
                        >(
                          currentTable: table,
                          referencedTable: $$ActivitiesTableReferences
                              ._activityAuditLogsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ActivitiesTableReferences(
                                db,
                                table,
                                p0,
                              ).activityAuditLogsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.activityId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ActivitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivitiesTable,
      Activity,
      $$ActivitiesTableFilterComposer,
      $$ActivitiesTableOrderingComposer,
      $$ActivitiesTableAnnotationComposer,
      $$ActivitiesTableCreateCompanionBuilder,
      $$ActivitiesTableUpdateCompanionBuilder,
      (Activity, $$ActivitiesTableReferences),
      Activity,
      PrefetchHooks Function({
        bool userId,
        bool createdBy,
        bool customerId,
        bool pipelineId,
        bool activityPhotosRefs,
        bool activityAuditLogsRefs,
      })
    >;
typedef $$ActivityPhotosTableCreateCompanionBuilder =
    ActivityPhotosCompanion Function({
      required String id,
      required String activityId,
      required String photoUrl,
      Value<String?> localPath,
      Value<String?> caption,
      Value<DateTime?> takenAt,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<bool> isPendingUpload,
      required DateTime createdAt,
      Value<int> rowid,
    });
typedef $$ActivityPhotosTableUpdateCompanionBuilder =
    ActivityPhotosCompanion Function({
      Value<String> id,
      Value<String> activityId,
      Value<String> photoUrl,
      Value<String?> localPath,
      Value<String?> caption,
      Value<DateTime?> takenAt,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<bool> isPendingUpload,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ActivityPhotosTableReferences
    extends BaseReferences<_$AppDatabase, $ActivityPhotosTable, ActivityPhoto> {
  $$ActivityPhotosTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ActivitiesTable _activityIdTable(_$AppDatabase db) =>
      db.activities.createAlias(
        $_aliasNameGenerator(db.activityPhotos.activityId, db.activities.id),
      );

  $$ActivitiesTableProcessedTableManager get activityId {
    final $_column = $_itemColumn<String>('activity_id')!;

    final manager = $$ActivitiesTableTableManager(
      $_db,
      $_db.activities,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ActivityPhotosTableFilterComposer
    extends Composer<_$AppDatabase, $ActivityPhotosTable> {
  $$ActivityPhotosTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get photoUrl => $composableBuilder(
    column: $table.photoUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get localPath => $composableBuilder(
    column: $table.localPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get caption => $composableBuilder(
    column: $table.caption,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get takenAt => $composableBuilder(
    column: $table.takenAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingUpload => $composableBuilder(
    column: $table.isPendingUpload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ActivitiesTableFilterComposer get activityId {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityId,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableFilterComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityPhotosTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivityPhotosTable> {
  $$ActivityPhotosTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get photoUrl => $composableBuilder(
    column: $table.photoUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get localPath => $composableBuilder(
    column: $table.localPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get caption => $composableBuilder(
    column: $table.caption,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get takenAt => $composableBuilder(
    column: $table.takenAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingUpload => $composableBuilder(
    column: $table.isPendingUpload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ActivitiesTableOrderingComposer get activityId {
    final $$ActivitiesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityId,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableOrderingComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityPhotosTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivityPhotosTable> {
  $$ActivityPhotosTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get photoUrl =>
      $composableBuilder(column: $table.photoUrl, builder: (column) => column);

  GeneratedColumn<String> get localPath =>
      $composableBuilder(column: $table.localPath, builder: (column) => column);

  GeneratedColumn<String> get caption =>
      $composableBuilder(column: $table.caption, builder: (column) => column);

  GeneratedColumn<DateTime> get takenAt =>
      $composableBuilder(column: $table.takenAt, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<bool> get isPendingUpload => $composableBuilder(
    column: $table.isPendingUpload,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ActivitiesTableAnnotationComposer get activityId {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityId,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityPhotosTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivityPhotosTable,
          ActivityPhoto,
          $$ActivityPhotosTableFilterComposer,
          $$ActivityPhotosTableOrderingComposer,
          $$ActivityPhotosTableAnnotationComposer,
          $$ActivityPhotosTableCreateCompanionBuilder,
          $$ActivityPhotosTableUpdateCompanionBuilder,
          (ActivityPhoto, $$ActivityPhotosTableReferences),
          ActivityPhoto,
          PrefetchHooks Function({bool activityId})
        > {
  $$ActivityPhotosTableTableManager(
    _$AppDatabase db,
    $ActivityPhotosTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivityPhotosTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivityPhotosTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivityPhotosTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> activityId = const Value.absent(),
                Value<String> photoUrl = const Value.absent(),
                Value<String?> localPath = const Value.absent(),
                Value<String?> caption = const Value.absent(),
                Value<DateTime?> takenAt = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<bool> isPendingUpload = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityPhotosCompanion(
                id: id,
                activityId: activityId,
                photoUrl: photoUrl,
                localPath: localPath,
                caption: caption,
                takenAt: takenAt,
                latitude: latitude,
                longitude: longitude,
                isPendingUpload: isPendingUpload,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String activityId,
                required String photoUrl,
                Value<String?> localPath = const Value.absent(),
                Value<String?> caption = const Value.absent(),
                Value<DateTime?> takenAt = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<bool> isPendingUpload = const Value.absent(),
                required DateTime createdAt,
                Value<int> rowid = const Value.absent(),
              }) => ActivityPhotosCompanion.insert(
                id: id,
                activityId: activityId,
                photoUrl: photoUrl,
                localPath: localPath,
                caption: caption,
                takenAt: takenAt,
                latitude: latitude,
                longitude: longitude,
                isPendingUpload: isPendingUpload,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ActivityPhotosTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({activityId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (activityId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.activityId,
                                referencedTable: $$ActivityPhotosTableReferences
                                    ._activityIdTable(db),
                                referencedColumn:
                                    $$ActivityPhotosTableReferences
                                        ._activityIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ActivityPhotosTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivityPhotosTable,
      ActivityPhoto,
      $$ActivityPhotosTableFilterComposer,
      $$ActivityPhotosTableOrderingComposer,
      $$ActivityPhotosTableAnnotationComposer,
      $$ActivityPhotosTableCreateCompanionBuilder,
      $$ActivityPhotosTableUpdateCompanionBuilder,
      (ActivityPhoto, $$ActivityPhotosTableReferences),
      ActivityPhoto,
      PrefetchHooks Function({bool activityId})
    >;
typedef $$ActivityAuditLogsTableCreateCompanionBuilder =
    ActivityAuditLogsCompanion Function({
      required String id,
      required String activityId,
      required String action,
      Value<String?> oldStatus,
      Value<String?> newStatus,
      Value<String?> oldValues,
      Value<String?> newValues,
      Value<String?> changedFields,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> deviceInfo,
      required String performedBy,
      required DateTime performedAt,
      Value<String?> notes,
      Value<bool> isSynced,
      Value<int> rowid,
    });
typedef $$ActivityAuditLogsTableUpdateCompanionBuilder =
    ActivityAuditLogsCompanion Function({
      Value<String> id,
      Value<String> activityId,
      Value<String> action,
      Value<String?> oldStatus,
      Value<String?> newStatus,
      Value<String?> oldValues,
      Value<String?> newValues,
      Value<String?> changedFields,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> deviceInfo,
      Value<String> performedBy,
      Value<DateTime> performedAt,
      Value<String?> notes,
      Value<bool> isSynced,
      Value<int> rowid,
    });

final class $$ActivityAuditLogsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $ActivityAuditLogsTable,
          ActivityAuditLog
        > {
  $$ActivityAuditLogsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ActivitiesTable _activityIdTable(_$AppDatabase db) =>
      db.activities.createAlias(
        $_aliasNameGenerator(db.activityAuditLogs.activityId, db.activities.id),
      );

  $$ActivitiesTableProcessedTableManager get activityId {
    final $_column = $_itemColumn<String>('activity_id')!;

    final manager = $$ActivitiesTableTableManager(
      $_db,
      $_db.activities,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _performedByTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.activityAuditLogs.performedBy, db.users.id),
      );

  $$UsersTableProcessedTableManager get performedBy {
    final $_column = $_itemColumn<String>('performed_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_performedByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ActivityAuditLogsTableFilterComposer
    extends Composer<_$AppDatabase, $ActivityAuditLogsTable> {
  $$ActivityAuditLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get oldStatus => $composableBuilder(
    column: $table.oldStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get newStatus => $composableBuilder(
    column: $table.newStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get oldValues => $composableBuilder(
    column: $table.oldValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get newValues => $composableBuilder(
    column: $table.newValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get changedFields => $composableBuilder(
    column: $table.changedFields,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceInfo => $composableBuilder(
    column: $table.deviceInfo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get performedAt => $composableBuilder(
    column: $table.performedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  $$ActivitiesTableFilterComposer get activityId {
    final $$ActivitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityId,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableFilterComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get performedBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.performedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityAuditLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivityAuditLogsTable> {
  $$ActivityAuditLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get oldStatus => $composableBuilder(
    column: $table.oldStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get newStatus => $composableBuilder(
    column: $table.newStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get oldValues => $composableBuilder(
    column: $table.oldValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get newValues => $composableBuilder(
    column: $table.newValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get changedFields => $composableBuilder(
    column: $table.changedFields,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceInfo => $composableBuilder(
    column: $table.deviceInfo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get performedAt => $composableBuilder(
    column: $table.performedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  $$ActivitiesTableOrderingComposer get activityId {
    final $$ActivitiesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityId,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableOrderingComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get performedBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.performedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityAuditLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivityAuditLogsTable> {
  $$ActivityAuditLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get oldStatus =>
      $composableBuilder(column: $table.oldStatus, builder: (column) => column);

  GeneratedColumn<String> get newStatus =>
      $composableBuilder(column: $table.newStatus, builder: (column) => column);

  GeneratedColumn<String> get oldValues =>
      $composableBuilder(column: $table.oldValues, builder: (column) => column);

  GeneratedColumn<String> get newValues =>
      $composableBuilder(column: $table.newValues, builder: (column) => column);

  GeneratedColumn<String> get changedFields => $composableBuilder(
    column: $table.changedFields,
    builder: (column) => column,
  );

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get deviceInfo => $composableBuilder(
    column: $table.deviceInfo,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get performedAt => $composableBuilder(
    column: $table.performedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  $$ActivitiesTableAnnotationComposer get activityId {
    final $$ActivitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityId,
      referencedTable: $db.activities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.activities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get performedBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.performedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityAuditLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivityAuditLogsTable,
          ActivityAuditLog,
          $$ActivityAuditLogsTableFilterComposer,
          $$ActivityAuditLogsTableOrderingComposer,
          $$ActivityAuditLogsTableAnnotationComposer,
          $$ActivityAuditLogsTableCreateCompanionBuilder,
          $$ActivityAuditLogsTableUpdateCompanionBuilder,
          (ActivityAuditLog, $$ActivityAuditLogsTableReferences),
          ActivityAuditLog,
          PrefetchHooks Function({bool activityId, bool performedBy})
        > {
  $$ActivityAuditLogsTableTableManager(
    _$AppDatabase db,
    $ActivityAuditLogsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivityAuditLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivityAuditLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivityAuditLogsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> activityId = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String?> oldStatus = const Value.absent(),
                Value<String?> newStatus = const Value.absent(),
                Value<String?> oldValues = const Value.absent(),
                Value<String?> newValues = const Value.absent(),
                Value<String?> changedFields = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> deviceInfo = const Value.absent(),
                Value<String> performedBy = const Value.absent(),
                Value<DateTime> performedAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityAuditLogsCompanion(
                id: id,
                activityId: activityId,
                action: action,
                oldStatus: oldStatus,
                newStatus: newStatus,
                oldValues: oldValues,
                newValues: newValues,
                changedFields: changedFields,
                latitude: latitude,
                longitude: longitude,
                deviceInfo: deviceInfo,
                performedBy: performedBy,
                performedAt: performedAt,
                notes: notes,
                isSynced: isSynced,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String activityId,
                required String action,
                Value<String?> oldStatus = const Value.absent(),
                Value<String?> newStatus = const Value.absent(),
                Value<String?> oldValues = const Value.absent(),
                Value<String?> newValues = const Value.absent(),
                Value<String?> changedFields = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> deviceInfo = const Value.absent(),
                required String performedBy,
                required DateTime performedAt,
                Value<String?> notes = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityAuditLogsCompanion.insert(
                id: id,
                activityId: activityId,
                action: action,
                oldStatus: oldStatus,
                newStatus: newStatus,
                oldValues: oldValues,
                newValues: newValues,
                changedFields: changedFields,
                latitude: latitude,
                longitude: longitude,
                deviceInfo: deviceInfo,
                performedBy: performedBy,
                performedAt: performedAt,
                notes: notes,
                isSynced: isSynced,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ActivityAuditLogsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({activityId = false, performedBy = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (activityId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.activityId,
                                referencedTable:
                                    $$ActivityAuditLogsTableReferences
                                        ._activityIdTable(db),
                                referencedColumn:
                                    $$ActivityAuditLogsTableReferences
                                        ._activityIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (performedBy) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.performedBy,
                                referencedTable:
                                    $$ActivityAuditLogsTableReferences
                                        ._performedByTable(db),
                                referencedColumn:
                                    $$ActivityAuditLogsTableReferences
                                        ._performedByTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ActivityAuditLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivityAuditLogsTable,
      ActivityAuditLog,
      $$ActivityAuditLogsTableFilterComposer,
      $$ActivityAuditLogsTableOrderingComposer,
      $$ActivityAuditLogsTableAnnotationComposer,
      $$ActivityAuditLogsTableCreateCompanionBuilder,
      $$ActivityAuditLogsTableUpdateCompanionBuilder,
      (ActivityAuditLog, $$ActivityAuditLogsTableReferences),
      ActivityAuditLog,
      PrefetchHooks Function({bool activityId, bool performedBy})
    >;
typedef $$HvcTypesTableCreateCompanionBuilder =
    HvcTypesCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });
typedef $$HvcTypesTableUpdateCompanionBuilder =
    HvcTypesCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<int> sortOrder,
      Value<bool> isActive,
      Value<int> rowid,
    });

final class $$HvcTypesTableReferences
    extends BaseReferences<_$AppDatabase, $HvcTypesTable, HvcType> {
  $$HvcTypesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$HvcsTable, List<Hvc>> _hvcsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.hvcs,
    aliasName: $_aliasNameGenerator(db.hvcTypes.id, db.hvcs.typeId),
  );

  $$HvcsTableProcessedTableManager get hvcsRefs {
    final manager = $$HvcsTableTableManager(
      $_db,
      $_db.hvcs,
    ).filter((f) => f.typeId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_hvcsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$HvcTypesTableFilterComposer
    extends Composer<_$AppDatabase, $HvcTypesTable> {
  $$HvcTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> hvcsRefs(
    Expression<bool> Function($$HvcsTableFilterComposer f) f,
  ) {
    final $$HvcsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.hvcs,
      getReferencedColumn: (t) => t.typeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcsTableFilterComposer(
            $db: $db,
            $table: $db.hvcs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$HvcTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $HvcTypesTable> {
  $$HvcTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$HvcTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $HvcTypesTable> {
  $$HvcTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> hvcsRefs<T extends Object>(
    Expression<T> Function($$HvcsTableAnnotationComposer a) f,
  ) {
    final $$HvcsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.hvcs,
      getReferencedColumn: (t) => t.typeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcsTableAnnotationComposer(
            $db: $db,
            $table: $db.hvcs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$HvcTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $HvcTypesTable,
          HvcType,
          $$HvcTypesTableFilterComposer,
          $$HvcTypesTableOrderingComposer,
          $$HvcTypesTableAnnotationComposer,
          $$HvcTypesTableCreateCompanionBuilder,
          $$HvcTypesTableUpdateCompanionBuilder,
          (HvcType, $$HvcTypesTableReferences),
          HvcType,
          PrefetchHooks Function({bool hvcsRefs})
        > {
  $$HvcTypesTableTableManager(_$AppDatabase db, $HvcTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$HvcTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$HvcTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$HvcTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => HvcTypesCompanion(
                id: id,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => HvcTypesCompanion.insert(
                id: id,
                code: code,
                name: name,
                description: description,
                sortOrder: sortOrder,
                isActive: isActive,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$HvcTypesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({hvcsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (hvcsRefs) db.hvcs],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (hvcsRefs)
                    await $_getPrefetchedData<HvcType, $HvcTypesTable, Hvc>(
                      currentTable: table,
                      referencedTable: $$HvcTypesTableReferences._hvcsRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$HvcTypesTableReferences(db, table, p0).hvcsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.typeId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$HvcTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $HvcTypesTable,
      HvcType,
      $$HvcTypesTableFilterComposer,
      $$HvcTypesTableOrderingComposer,
      $$HvcTypesTableAnnotationComposer,
      $$HvcTypesTableCreateCompanionBuilder,
      $$HvcTypesTableUpdateCompanionBuilder,
      (HvcType, $$HvcTypesTableReferences),
      HvcType,
      PrefetchHooks Function({bool hvcsRefs})
    >;
typedef $$HvcsTableCreateCompanionBuilder =
    HvcsCompanion Function({
      required String id,
      required String code,
      required String name,
      required String typeId,
      Value<String?> description,
      Value<String?> address,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<int> radiusMeters,
      Value<double?> potentialValue,
      Value<String?> imageUrl,
      Value<bool> isActive,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$HvcsTableUpdateCompanionBuilder =
    HvcsCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String> typeId,
      Value<String?> description,
      Value<String?> address,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<int> radiusMeters,
      Value<double?> potentialValue,
      Value<String?> imageUrl,
      Value<bool> isActive,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$HvcsTableReferences
    extends BaseReferences<_$AppDatabase, $HvcsTable, Hvc> {
  $$HvcsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $HvcTypesTable _typeIdTable(_$AppDatabase db) => db.hvcTypes
      .createAlias($_aliasNameGenerator(db.hvcs.typeId, db.hvcTypes.id));

  $$HvcTypesTableProcessedTableManager get typeId {
    final $_column = $_itemColumn<String>('type_id')!;

    final manager = $$HvcTypesTableTableManager(
      $_db,
      $_db.hvcTypes,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_typeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$CustomerHvcLinksTable, List<CustomerHvcLink>>
  _customerHvcLinksRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.customerHvcLinks,
    aliasName: $_aliasNameGenerator(db.hvcs.id, db.customerHvcLinks.hvcId),
  );

  $$CustomerHvcLinksTableProcessedTableManager get customerHvcLinksRefs {
    final manager = $$CustomerHvcLinksTableTableManager(
      $_db,
      $_db.customerHvcLinks,
    ).filter((f) => f.hvcId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _customerHvcLinksRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$HvcsTableFilterComposer extends Composer<_$AppDatabase, $HvcsTable> {
  $$HvcsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get radiusMeters => $composableBuilder(
    column: $table.radiusMeters,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get potentialValue => $composableBuilder(
    column: $table.potentialValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get createdBy => $composableBuilder(
    column: $table.createdBy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$HvcTypesTableFilterComposer get typeId {
    final $$HvcTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.typeId,
      referencedTable: $db.hvcTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcTypesTableFilterComposer(
            $db: $db,
            $table: $db.hvcTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> customerHvcLinksRefs(
    Expression<bool> Function($$CustomerHvcLinksTableFilterComposer f) f,
  ) {
    final $$CustomerHvcLinksTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.customerHvcLinks,
      getReferencedColumn: (t) => t.hvcId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerHvcLinksTableFilterComposer(
            $db: $db,
            $table: $db.customerHvcLinks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$HvcsTableOrderingComposer extends Composer<_$AppDatabase, $HvcsTable> {
  $$HvcsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get radiusMeters => $composableBuilder(
    column: $table.radiusMeters,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get potentialValue => $composableBuilder(
    column: $table.potentialValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get createdBy => $composableBuilder(
    column: $table.createdBy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$HvcTypesTableOrderingComposer get typeId {
    final $$HvcTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.typeId,
      referencedTable: $db.hvcTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcTypesTableOrderingComposer(
            $db: $db,
            $table: $db.hvcTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$HvcsTableAnnotationComposer
    extends Composer<_$AppDatabase, $HvcsTable> {
  $$HvcsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<int> get radiusMeters => $composableBuilder(
    column: $table.radiusMeters,
    builder: (column) => column,
  );

  GeneratedColumn<double> get potentialValue => $composableBuilder(
    column: $table.potentialValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$HvcTypesTableAnnotationComposer get typeId {
    final $$HvcTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.typeId,
      referencedTable: $db.hvcTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.hvcTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> customerHvcLinksRefs<T extends Object>(
    Expression<T> Function($$CustomerHvcLinksTableAnnotationComposer a) f,
  ) {
    final $$CustomerHvcLinksTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.customerHvcLinks,
      getReferencedColumn: (t) => t.hvcId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CustomerHvcLinksTableAnnotationComposer(
            $db: $db,
            $table: $db.customerHvcLinks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$HvcsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $HvcsTable,
          Hvc,
          $$HvcsTableFilterComposer,
          $$HvcsTableOrderingComposer,
          $$HvcsTableAnnotationComposer,
          $$HvcsTableCreateCompanionBuilder,
          $$HvcsTableUpdateCompanionBuilder,
          (Hvc, $$HvcsTableReferences),
          Hvc,
          PrefetchHooks Function({bool typeId, bool customerHvcLinksRefs})
        > {
  $$HvcsTableTableManager(_$AppDatabase db, $HvcsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$HvcsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$HvcsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$HvcsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> typeId = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<int> radiusMeters = const Value.absent(),
                Value<double?> potentialValue = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => HvcsCompanion(
                id: id,
                code: code,
                name: name,
                typeId: typeId,
                description: description,
                address: address,
                latitude: latitude,
                longitude: longitude,
                radiusMeters: radiusMeters,
                potentialValue: potentialValue,
                imageUrl: imageUrl,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                required String typeId,
                Value<String?> description = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<int> radiusMeters = const Value.absent(),
                Value<double?> potentialValue = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => HvcsCompanion.insert(
                id: id,
                code: code,
                name: name,
                typeId: typeId,
                description: description,
                address: address,
                latitude: latitude,
                longitude: longitude,
                radiusMeters: radiusMeters,
                potentialValue: potentialValue,
                imageUrl: imageUrl,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$HvcsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({typeId = false, customerHvcLinksRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (customerHvcLinksRefs) db.customerHvcLinks,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (typeId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.typeId,
                                    referencedTable: $$HvcsTableReferences
                                        ._typeIdTable(db),
                                    referencedColumn: $$HvcsTableReferences
                                        ._typeIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (customerHvcLinksRefs)
                        await $_getPrefetchedData<
                          Hvc,
                          $HvcsTable,
                          CustomerHvcLink
                        >(
                          currentTable: table,
                          referencedTable: $$HvcsTableReferences
                              ._customerHvcLinksRefsTable(db),
                          managerFromTypedResult: (p0) => $$HvcsTableReferences(
                            db,
                            table,
                            p0,
                          ).customerHvcLinksRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.hvcId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$HvcsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $HvcsTable,
      Hvc,
      $$HvcsTableFilterComposer,
      $$HvcsTableOrderingComposer,
      $$HvcsTableAnnotationComposer,
      $$HvcsTableCreateCompanionBuilder,
      $$HvcsTableUpdateCompanionBuilder,
      (Hvc, $$HvcsTableReferences),
      Hvc,
      PrefetchHooks Function({bool typeId, bool customerHvcLinksRefs})
    >;
typedef $$CustomerHvcLinksTableCreateCompanionBuilder =
    CustomerHvcLinksCompanion Function({
      required String id,
      required String customerId,
      required String hvcId,
      required String relationshipType,
      Value<bool> isActive,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$CustomerHvcLinksTableUpdateCompanionBuilder =
    CustomerHvcLinksCompanion Function({
      Value<String> id,
      Value<String> customerId,
      Value<String> hvcId,
      Value<String> relationshipType,
      Value<bool> isActive,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$CustomerHvcLinksTableReferences
    extends
        BaseReferences<_$AppDatabase, $CustomerHvcLinksTable, CustomerHvcLink> {
  $$CustomerHvcLinksTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $HvcsTable _hvcIdTable(_$AppDatabase db) => db.hvcs.createAlias(
    $_aliasNameGenerator(db.customerHvcLinks.hvcId, db.hvcs.id),
  );

  $$HvcsTableProcessedTableManager get hvcId {
    final $_column = $_itemColumn<String>('hvc_id')!;

    final manager = $$HvcsTableTableManager(
      $_db,
      $_db.hvcs,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_hvcIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.customerHvcLinks.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CustomerHvcLinksTableFilterComposer
    extends Composer<_$AppDatabase, $CustomerHvcLinksTable> {
  $$CustomerHvcLinksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get relationshipType => $composableBuilder(
    column: $table.relationshipType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$HvcsTableFilterComposer get hvcId {
    final $$HvcsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.hvcId,
      referencedTable: $db.hvcs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcsTableFilterComposer(
            $db: $db,
            $table: $db.hvcs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CustomerHvcLinksTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomerHvcLinksTable> {
  $$CustomerHvcLinksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get relationshipType => $composableBuilder(
    column: $table.relationshipType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$HvcsTableOrderingComposer get hvcId {
    final $$HvcsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.hvcId,
      referencedTable: $db.hvcs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcsTableOrderingComposer(
            $db: $db,
            $table: $db.hvcs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CustomerHvcLinksTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomerHvcLinksTable> {
  $$CustomerHvcLinksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get customerId => $composableBuilder(
    column: $table.customerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get relationshipType => $composableBuilder(
    column: $table.relationshipType,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$HvcsTableAnnotationComposer get hvcId {
    final $$HvcsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.hvcId,
      referencedTable: $db.hvcs,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$HvcsTableAnnotationComposer(
            $db: $db,
            $table: $db.hvcs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CustomerHvcLinksTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CustomerHvcLinksTable,
          CustomerHvcLink,
          $$CustomerHvcLinksTableFilterComposer,
          $$CustomerHvcLinksTableOrderingComposer,
          $$CustomerHvcLinksTableAnnotationComposer,
          $$CustomerHvcLinksTableCreateCompanionBuilder,
          $$CustomerHvcLinksTableUpdateCompanionBuilder,
          (CustomerHvcLink, $$CustomerHvcLinksTableReferences),
          CustomerHvcLink,
          PrefetchHooks Function({bool hvcId, bool createdBy})
        > {
  $$CustomerHvcLinksTableTableManager(
    _$AppDatabase db,
    $CustomerHvcLinksTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomerHvcLinksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomerHvcLinksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomerHvcLinksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> customerId = const Value.absent(),
                Value<String> hvcId = const Value.absent(),
                Value<String> relationshipType = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomerHvcLinksCompanion(
                id: id,
                customerId: customerId,
                hvcId: hvcId,
                relationshipType: relationshipType,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String customerId,
                required String hvcId,
                required String relationshipType,
                Value<bool> isActive = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CustomerHvcLinksCompanion.insert(
                id: id,
                customerId: customerId,
                hvcId: hvcId,
                relationshipType: relationshipType,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CustomerHvcLinksTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({hvcId = false, createdBy = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (hvcId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.hvcId,
                                referencedTable:
                                    $$CustomerHvcLinksTableReferences
                                        ._hvcIdTable(db),
                                referencedColumn:
                                    $$CustomerHvcLinksTableReferences
                                        ._hvcIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (createdBy) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.createdBy,
                                referencedTable:
                                    $$CustomerHvcLinksTableReferences
                                        ._createdByTable(db),
                                referencedColumn:
                                    $$CustomerHvcLinksTableReferences
                                        ._createdByTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CustomerHvcLinksTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CustomerHvcLinksTable,
      CustomerHvcLink,
      $$CustomerHvcLinksTableFilterComposer,
      $$CustomerHvcLinksTableOrderingComposer,
      $$CustomerHvcLinksTableAnnotationComposer,
      $$CustomerHvcLinksTableCreateCompanionBuilder,
      $$CustomerHvcLinksTableUpdateCompanionBuilder,
      (CustomerHvcLink, $$CustomerHvcLinksTableReferences),
      CustomerHvcLink,
      PrefetchHooks Function({bool hvcId, bool createdBy})
    >;
typedef $$BrokersTableCreateCompanionBuilder =
    BrokersCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> licenseNumber,
      Value<String?> address,
      Value<String?> provinceId,
      Value<String?> cityId,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> website,
      Value<double?> commissionRate,
      Value<String?> imageUrl,
      Value<String?> notes,
      Value<bool> isActive,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$BrokersTableUpdateCompanionBuilder =
    BrokersCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> licenseNumber,
      Value<String?> address,
      Value<String?> provinceId,
      Value<String?> cityId,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> website,
      Value<double?> commissionRate,
      Value<String?> imageUrl,
      Value<String?> notes,
      Value<bool> isActive,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$BrokersTableReferences
    extends BaseReferences<_$AppDatabase, $BrokersTable, Broker> {
  $$BrokersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProvincesTable _provinceIdTable(_$AppDatabase db) =>
      db.provinces.createAlias(
        $_aliasNameGenerator(db.brokers.provinceId, db.provinces.id),
      );

  $$ProvincesTableProcessedTableManager? get provinceId {
    final $_column = $_itemColumn<String>('province_id');
    if ($_column == null) return null;
    final manager = $$ProvincesTableTableManager(
      $_db,
      $_db.provinces,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_provinceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CitiesTable _cityIdTable(_$AppDatabase db) => db.cities.createAlias(
    $_aliasNameGenerator(db.brokers.cityId, db.cities.id),
  );

  $$CitiesTableProcessedTableManager? get cityId {
    final $_column = $_itemColumn<String>('city_id');
    if ($_column == null) return null;
    final manager = $$CitiesTableTableManager(
      $_db,
      $_db.cities,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_cityIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BrokersTableFilterComposer
    extends Composer<_$AppDatabase, $BrokersTable> {
  $$BrokersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get licenseNumber => $composableBuilder(
    column: $table.licenseNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get website => $composableBuilder(
    column: $table.website,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get commissionRate => $composableBuilder(
    column: $table.commissionRate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get createdBy => $composableBuilder(
    column: $table.createdBy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ProvincesTableFilterComposer get provinceId {
    final $$ProvincesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.provinceId,
      referencedTable: $db.provinces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProvincesTableFilterComposer(
            $db: $db,
            $table: $db.provinces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CitiesTableFilterComposer get cityId {
    final $$CitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.cityId,
      referencedTable: $db.cities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CitiesTableFilterComposer(
            $db: $db,
            $table: $db.cities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BrokersTableOrderingComposer
    extends Composer<_$AppDatabase, $BrokersTable> {
  $$BrokersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get licenseNumber => $composableBuilder(
    column: $table.licenseNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get website => $composableBuilder(
    column: $table.website,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get commissionRate => $composableBuilder(
    column: $table.commissionRate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get createdBy => $composableBuilder(
    column: $table.createdBy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ProvincesTableOrderingComposer get provinceId {
    final $$ProvincesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.provinceId,
      referencedTable: $db.provinces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProvincesTableOrderingComposer(
            $db: $db,
            $table: $db.provinces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CitiesTableOrderingComposer get cityId {
    final $$CitiesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.cityId,
      referencedTable: $db.cities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CitiesTableOrderingComposer(
            $db: $db,
            $table: $db.cities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BrokersTableAnnotationComposer
    extends Composer<_$AppDatabase, $BrokersTable> {
  $$BrokersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get licenseNumber => $composableBuilder(
    column: $table.licenseNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get website =>
      $composableBuilder(column: $table.website, builder: (column) => column);

  GeneratedColumn<double> get commissionRate => $composableBuilder(
    column: $table.commissionRate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$ProvincesTableAnnotationComposer get provinceId {
    final $$ProvincesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.provinceId,
      referencedTable: $db.provinces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProvincesTableAnnotationComposer(
            $db: $db,
            $table: $db.provinces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CitiesTableAnnotationComposer get cityId {
    final $$CitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.cityId,
      referencedTable: $db.cities,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.cities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BrokersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BrokersTable,
          Broker,
          $$BrokersTableFilterComposer,
          $$BrokersTableOrderingComposer,
          $$BrokersTableAnnotationComposer,
          $$BrokersTableCreateCompanionBuilder,
          $$BrokersTableUpdateCompanionBuilder,
          (Broker, $$BrokersTableReferences),
          Broker,
          PrefetchHooks Function({bool provinceId, bool cityId})
        > {
  $$BrokersTableTableManager(_$AppDatabase db, $BrokersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BrokersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BrokersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BrokersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> licenseNumber = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> provinceId = const Value.absent(),
                Value<String?> cityId = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> website = const Value.absent(),
                Value<double?> commissionRate = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BrokersCompanion(
                id: id,
                code: code,
                name: name,
                licenseNumber: licenseNumber,
                address: address,
                provinceId: provinceId,
                cityId: cityId,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                email: email,
                website: website,
                commissionRate: commissionRate,
                imageUrl: imageUrl,
                notes: notes,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> licenseNumber = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> provinceId = const Value.absent(),
                Value<String?> cityId = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> website = const Value.absent(),
                Value<double?> commissionRate = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BrokersCompanion.insert(
                id: id,
                code: code,
                name: name,
                licenseNumber: licenseNumber,
                address: address,
                provinceId: provinceId,
                cityId: cityId,
                latitude: latitude,
                longitude: longitude,
                phone: phone,
                email: email,
                website: website,
                commissionRate: commissionRate,
                imageUrl: imageUrl,
                notes: notes,
                isActive: isActive,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BrokersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({provinceId = false, cityId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (provinceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.provinceId,
                                referencedTable: $$BrokersTableReferences
                                    ._provinceIdTable(db),
                                referencedColumn: $$BrokersTableReferences
                                    ._provinceIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (cityId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.cityId,
                                referencedTable: $$BrokersTableReferences
                                    ._cityIdTable(db),
                                referencedColumn: $$BrokersTableReferences
                                    ._cityIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BrokersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BrokersTable,
      Broker,
      $$BrokersTableFilterComposer,
      $$BrokersTableOrderingComposer,
      $$BrokersTableAnnotationComposer,
      $$BrokersTableCreateCompanionBuilder,
      $$BrokersTableUpdateCompanionBuilder,
      (Broker, $$BrokersTableReferences),
      Broker,
      PrefetchHooks Function({bool provinceId, bool cityId})
    >;
typedef $$MeasureDefinitionsTableCreateCompanionBuilder =
    MeasureDefinitionsCompanion Function({
      required String id,
      required String code,
      required String name,
      Value<String?> description,
      required String measureType,
      Value<String> dataType,
      required String unit,
      Value<String?> calculationMethod,
      Value<String?> calculationFormula,
      Value<String?> sourceTable,
      Value<String?> sourceCondition,
      Value<double> weight,
      Value<double?> defaultTarget,
      Value<String> periodType,
      Value<String?> templateType,
      Value<String?> templateConfig,
      Value<bool> isActive,
      Value<int> sortOrder,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$MeasureDefinitionsTableUpdateCompanionBuilder =
    MeasureDefinitionsCompanion Function({
      Value<String> id,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<String> measureType,
      Value<String> dataType,
      Value<String> unit,
      Value<String?> calculationMethod,
      Value<String?> calculationFormula,
      Value<String?> sourceTable,
      Value<String?> sourceCondition,
      Value<double> weight,
      Value<double?> defaultTarget,
      Value<String> periodType,
      Value<String?> templateType,
      Value<String?> templateConfig,
      Value<bool> isActive,
      Value<int> sortOrder,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$MeasureDefinitionsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $MeasureDefinitionsTable,
          MeasureDefinition
        > {
  $$MeasureDefinitionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$UserTargetsTable, List<UserTarget>>
  _userTargetsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.userTargets,
    aliasName: $_aliasNameGenerator(
      db.measureDefinitions.id,
      db.userTargets.measureId,
    ),
  );

  $$UserTargetsTableProcessedTableManager get userTargetsRefs {
    final manager = $$UserTargetsTableTableManager(
      $_db,
      $_db.userTargets,
    ).filter((f) => f.measureId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userTargetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$UserScoresTable, List<UserScore>>
  _userScoresRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.userScores,
    aliasName: $_aliasNameGenerator(
      db.measureDefinitions.id,
      db.userScores.measureId,
    ),
  );

  $$UserScoresTableProcessedTableManager get userScoresRefs {
    final manager = $$UserScoresTableTableManager(
      $_db,
      $_db.userScores,
    ).filter((f) => f.measureId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userScoresRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$MeasureDefinitionsTableFilterComposer
    extends Composer<_$AppDatabase, $MeasureDefinitionsTable> {
  $$MeasureDefinitionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get measureType => $composableBuilder(
    column: $table.measureType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get dataType => $composableBuilder(
    column: $table.dataType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get calculationMethod => $composableBuilder(
    column: $table.calculationMethod,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get calculationFormula => $composableBuilder(
    column: $table.calculationFormula,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sourceTable => $composableBuilder(
    column: $table.sourceTable,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sourceCondition => $composableBuilder(
    column: $table.sourceCondition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get weight => $composableBuilder(
    column: $table.weight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get defaultTarget => $composableBuilder(
    column: $table.defaultTarget,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get periodType => $composableBuilder(
    column: $table.periodType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get templateType => $composableBuilder(
    column: $table.templateType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get templateConfig => $composableBuilder(
    column: $table.templateConfig,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> userTargetsRefs(
    Expression<bool> Function($$UserTargetsTableFilterComposer f) f,
  ) {
    final $$UserTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userTargets,
      getReferencedColumn: (t) => t.measureId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserTargetsTableFilterComposer(
            $db: $db,
            $table: $db.userTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> userScoresRefs(
    Expression<bool> Function($$UserScoresTableFilterComposer f) f,
  ) {
    final $$UserScoresTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScores,
      getReferencedColumn: (t) => t.measureId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoresTableFilterComposer(
            $db: $db,
            $table: $db.userScores,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$MeasureDefinitionsTableOrderingComposer
    extends Composer<_$AppDatabase, $MeasureDefinitionsTable> {
  $$MeasureDefinitionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get measureType => $composableBuilder(
    column: $table.measureType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get dataType => $composableBuilder(
    column: $table.dataType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get calculationMethod => $composableBuilder(
    column: $table.calculationMethod,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get calculationFormula => $composableBuilder(
    column: $table.calculationFormula,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sourceTable => $composableBuilder(
    column: $table.sourceTable,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sourceCondition => $composableBuilder(
    column: $table.sourceCondition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get weight => $composableBuilder(
    column: $table.weight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get defaultTarget => $composableBuilder(
    column: $table.defaultTarget,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get periodType => $composableBuilder(
    column: $table.periodType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get templateType => $composableBuilder(
    column: $table.templateType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get templateConfig => $composableBuilder(
    column: $table.templateConfig,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MeasureDefinitionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $MeasureDefinitionsTable> {
  $$MeasureDefinitionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get measureType => $composableBuilder(
    column: $table.measureType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get dataType =>
      $composableBuilder(column: $table.dataType, builder: (column) => column);

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<String> get calculationMethod => $composableBuilder(
    column: $table.calculationMethod,
    builder: (column) => column,
  );

  GeneratedColumn<String> get calculationFormula => $composableBuilder(
    column: $table.calculationFormula,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sourceTable => $composableBuilder(
    column: $table.sourceTable,
    builder: (column) => column,
  );

  GeneratedColumn<String> get sourceCondition => $composableBuilder(
    column: $table.sourceCondition,
    builder: (column) => column,
  );

  GeneratedColumn<double> get weight =>
      $composableBuilder(column: $table.weight, builder: (column) => column);

  GeneratedColumn<double> get defaultTarget => $composableBuilder(
    column: $table.defaultTarget,
    builder: (column) => column,
  );

  GeneratedColumn<String> get periodType => $composableBuilder(
    column: $table.periodType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get templateType => $composableBuilder(
    column: $table.templateType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get templateConfig => $composableBuilder(
    column: $table.templateConfig,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> userTargetsRefs<T extends Object>(
    Expression<T> Function($$UserTargetsTableAnnotationComposer a) f,
  ) {
    final $$UserTargetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userTargets,
      getReferencedColumn: (t) => t.measureId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserTargetsTableAnnotationComposer(
            $db: $db,
            $table: $db.userTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> userScoresRefs<T extends Object>(
    Expression<T> Function($$UserScoresTableAnnotationComposer a) f,
  ) {
    final $$UserScoresTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScores,
      getReferencedColumn: (t) => t.measureId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoresTableAnnotationComposer(
            $db: $db,
            $table: $db.userScores,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$MeasureDefinitionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MeasureDefinitionsTable,
          MeasureDefinition,
          $$MeasureDefinitionsTableFilterComposer,
          $$MeasureDefinitionsTableOrderingComposer,
          $$MeasureDefinitionsTableAnnotationComposer,
          $$MeasureDefinitionsTableCreateCompanionBuilder,
          $$MeasureDefinitionsTableUpdateCompanionBuilder,
          (MeasureDefinition, $$MeasureDefinitionsTableReferences),
          MeasureDefinition,
          PrefetchHooks Function({bool userTargetsRefs, bool userScoresRefs})
        > {
  $$MeasureDefinitionsTableTableManager(
    _$AppDatabase db,
    $MeasureDefinitionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MeasureDefinitionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MeasureDefinitionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MeasureDefinitionsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> measureType = const Value.absent(),
                Value<String> dataType = const Value.absent(),
                Value<String> unit = const Value.absent(),
                Value<String?> calculationMethod = const Value.absent(),
                Value<String?> calculationFormula = const Value.absent(),
                Value<String?> sourceTable = const Value.absent(),
                Value<String?> sourceCondition = const Value.absent(),
                Value<double> weight = const Value.absent(),
                Value<double?> defaultTarget = const Value.absent(),
                Value<String> periodType = const Value.absent(),
                Value<String?> templateType = const Value.absent(),
                Value<String?> templateConfig = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MeasureDefinitionsCompanion(
                id: id,
                code: code,
                name: name,
                description: description,
                measureType: measureType,
                dataType: dataType,
                unit: unit,
                calculationMethod: calculationMethod,
                calculationFormula: calculationFormula,
                sourceTable: sourceTable,
                sourceCondition: sourceCondition,
                weight: weight,
                defaultTarget: defaultTarget,
                periodType: periodType,
                templateType: templateType,
                templateConfig: templateConfig,
                isActive: isActive,
                sortOrder: sortOrder,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                required String measureType,
                Value<String> dataType = const Value.absent(),
                required String unit,
                Value<String?> calculationMethod = const Value.absent(),
                Value<String?> calculationFormula = const Value.absent(),
                Value<String?> sourceTable = const Value.absent(),
                Value<String?> sourceCondition = const Value.absent(),
                Value<double> weight = const Value.absent(),
                Value<double?> defaultTarget = const Value.absent(),
                Value<String> periodType = const Value.absent(),
                Value<String?> templateType = const Value.absent(),
                Value<String?> templateConfig = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => MeasureDefinitionsCompanion.insert(
                id: id,
                code: code,
                name: name,
                description: description,
                measureType: measureType,
                dataType: dataType,
                unit: unit,
                calculationMethod: calculationMethod,
                calculationFormula: calculationFormula,
                sourceTable: sourceTable,
                sourceCondition: sourceCondition,
                weight: weight,
                defaultTarget: defaultTarget,
                periodType: periodType,
                templateType: templateType,
                templateConfig: templateConfig,
                isActive: isActive,
                sortOrder: sortOrder,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$MeasureDefinitionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({userTargetsRefs = false, userScoresRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (userTargetsRefs) db.userTargets,
                    if (userScoresRefs) db.userScores,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (userTargetsRefs)
                        await $_getPrefetchedData<
                          MeasureDefinition,
                          $MeasureDefinitionsTable,
                          UserTarget
                        >(
                          currentTable: table,
                          referencedTable: $$MeasureDefinitionsTableReferences
                              ._userTargetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$MeasureDefinitionsTableReferences(
                                db,
                                table,
                                p0,
                              ).userTargetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.measureId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (userScoresRefs)
                        await $_getPrefetchedData<
                          MeasureDefinition,
                          $MeasureDefinitionsTable,
                          UserScore
                        >(
                          currentTable: table,
                          referencedTable: $$MeasureDefinitionsTableReferences
                              ._userScoresRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$MeasureDefinitionsTableReferences(
                                db,
                                table,
                                p0,
                              ).userScoresRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.measureId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$MeasureDefinitionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MeasureDefinitionsTable,
      MeasureDefinition,
      $$MeasureDefinitionsTableFilterComposer,
      $$MeasureDefinitionsTableOrderingComposer,
      $$MeasureDefinitionsTableAnnotationComposer,
      $$MeasureDefinitionsTableCreateCompanionBuilder,
      $$MeasureDefinitionsTableUpdateCompanionBuilder,
      (MeasureDefinition, $$MeasureDefinitionsTableReferences),
      MeasureDefinition,
      PrefetchHooks Function({bool userTargetsRefs, bool userScoresRefs})
    >;
typedef $$ScoringPeriodsTableCreateCompanionBuilder =
    ScoringPeriodsCompanion Function({
      required String id,
      required String name,
      required String periodType,
      required DateTime startDate,
      required DateTime endDate,
      Value<bool> isActive,
      Value<bool> isCurrent,
      Value<bool> isLocked,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$ScoringPeriodsTableUpdateCompanionBuilder =
    ScoringPeriodsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> periodType,
      Value<DateTime> startDate,
      Value<DateTime> endDate,
      Value<bool> isActive,
      Value<bool> isCurrent,
      Value<bool> isLocked,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$ScoringPeriodsTableReferences
    extends BaseReferences<_$AppDatabase, $ScoringPeriodsTable, ScoringPeriod> {
  $$ScoringPeriodsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$UserTargetsTable, List<UserTarget>>
  _userTargetsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.userTargets,
    aliasName: $_aliasNameGenerator(
      db.scoringPeriods.id,
      db.userTargets.periodId,
    ),
  );

  $$UserTargetsTableProcessedTableManager get userTargetsRefs {
    final manager = $$UserTargetsTableTableManager(
      $_db,
      $_db.userTargets,
    ).filter((f) => f.periodId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userTargetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$UserScoresTable, List<UserScore>>
  _userScoresRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.userScores,
    aliasName: $_aliasNameGenerator(
      db.scoringPeriods.id,
      db.userScores.periodId,
    ),
  );

  $$UserScoresTableProcessedTableManager get userScoresRefs {
    final manager = $$UserScoresTableTableManager(
      $_db,
      $_db.userScores,
    ).filter((f) => f.periodId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userScoresRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $UserScoreAggregatesTable,
    List<UserScoreAggregate>
  >
  _userScoreAggregatesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.userScoreAggregates,
        aliasName: $_aliasNameGenerator(
          db.scoringPeriods.id,
          db.userScoreAggregates.periodId,
        ),
      );

  $$UserScoreAggregatesTableProcessedTableManager get userScoreAggregatesRefs {
    final manager = $$UserScoreAggregatesTableTableManager(
      $_db,
      $_db.userScoreAggregates,
    ).filter((f) => f.periodId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _userScoreAggregatesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ScoringPeriodsTableFilterComposer
    extends Composer<_$AppDatabase, $ScoringPeriodsTable> {
  $$ScoringPeriodsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get periodType => $composableBuilder(
    column: $table.periodType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isCurrent => $composableBuilder(
    column: $table.isCurrent,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isLocked => $composableBuilder(
    column: $table.isLocked,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> userTargetsRefs(
    Expression<bool> Function($$UserTargetsTableFilterComposer f) f,
  ) {
    final $$UserTargetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userTargets,
      getReferencedColumn: (t) => t.periodId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserTargetsTableFilterComposer(
            $db: $db,
            $table: $db.userTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> userScoresRefs(
    Expression<bool> Function($$UserScoresTableFilterComposer f) f,
  ) {
    final $$UserScoresTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScores,
      getReferencedColumn: (t) => t.periodId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoresTableFilterComposer(
            $db: $db,
            $table: $db.userScores,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> userScoreAggregatesRefs(
    Expression<bool> Function($$UserScoreAggregatesTableFilterComposer f) f,
  ) {
    final $$UserScoreAggregatesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScoreAggregates,
      getReferencedColumn: (t) => t.periodId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoreAggregatesTableFilterComposer(
            $db: $db,
            $table: $db.userScoreAggregates,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ScoringPeriodsTableOrderingComposer
    extends Composer<_$AppDatabase, $ScoringPeriodsTable> {
  $$ScoringPeriodsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get periodType => $composableBuilder(
    column: $table.periodType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isCurrent => $composableBuilder(
    column: $table.isCurrent,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isLocked => $composableBuilder(
    column: $table.isLocked,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ScoringPeriodsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ScoringPeriodsTable> {
  $$ScoringPeriodsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get periodType => $composableBuilder(
    column: $table.periodType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<DateTime> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<bool> get isCurrent =>
      $composableBuilder(column: $table.isCurrent, builder: (column) => column);

  GeneratedColumn<bool> get isLocked =>
      $composableBuilder(column: $table.isLocked, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> userTargetsRefs<T extends Object>(
    Expression<T> Function($$UserTargetsTableAnnotationComposer a) f,
  ) {
    final $$UserTargetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userTargets,
      getReferencedColumn: (t) => t.periodId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserTargetsTableAnnotationComposer(
            $db: $db,
            $table: $db.userTargets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> userScoresRefs<T extends Object>(
    Expression<T> Function($$UserScoresTableAnnotationComposer a) f,
  ) {
    final $$UserScoresTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userScores,
      getReferencedColumn: (t) => t.periodId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserScoresTableAnnotationComposer(
            $db: $db,
            $table: $db.userScores,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> userScoreAggregatesRefs<T extends Object>(
    Expression<T> Function($$UserScoreAggregatesTableAnnotationComposer a) f,
  ) {
    final $$UserScoreAggregatesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.userScoreAggregates,
          getReferencedColumn: (t) => t.periodId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$UserScoreAggregatesTableAnnotationComposer(
                $db: $db,
                $table: $db.userScoreAggregates,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ScoringPeriodsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ScoringPeriodsTable,
          ScoringPeriod,
          $$ScoringPeriodsTableFilterComposer,
          $$ScoringPeriodsTableOrderingComposer,
          $$ScoringPeriodsTableAnnotationComposer,
          $$ScoringPeriodsTableCreateCompanionBuilder,
          $$ScoringPeriodsTableUpdateCompanionBuilder,
          (ScoringPeriod, $$ScoringPeriodsTableReferences),
          ScoringPeriod,
          PrefetchHooks Function({
            bool userTargetsRefs,
            bool userScoresRefs,
            bool userScoreAggregatesRefs,
          })
        > {
  $$ScoringPeriodsTableTableManager(
    _$AppDatabase db,
    $ScoringPeriodsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ScoringPeriodsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ScoringPeriodsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ScoringPeriodsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> periodType = const Value.absent(),
                Value<DateTime> startDate = const Value.absent(),
                Value<DateTime> endDate = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<bool> isCurrent = const Value.absent(),
                Value<bool> isLocked = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ScoringPeriodsCompanion(
                id: id,
                name: name,
                periodType: periodType,
                startDate: startDate,
                endDate: endDate,
                isActive: isActive,
                isCurrent: isCurrent,
                isLocked: isLocked,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String periodType,
                required DateTime startDate,
                required DateTime endDate,
                Value<bool> isActive = const Value.absent(),
                Value<bool> isCurrent = const Value.absent(),
                Value<bool> isLocked = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ScoringPeriodsCompanion.insert(
                id: id,
                name: name,
                periodType: periodType,
                startDate: startDate,
                endDate: endDate,
                isActive: isActive,
                isCurrent: isCurrent,
                isLocked: isLocked,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ScoringPeriodsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                userTargetsRefs = false,
                userScoresRefs = false,
                userScoreAggregatesRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (userTargetsRefs) db.userTargets,
                    if (userScoresRefs) db.userScores,
                    if (userScoreAggregatesRefs) db.userScoreAggregates,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (userTargetsRefs)
                        await $_getPrefetchedData<
                          ScoringPeriod,
                          $ScoringPeriodsTable,
                          UserTarget
                        >(
                          currentTable: table,
                          referencedTable: $$ScoringPeriodsTableReferences
                              ._userTargetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ScoringPeriodsTableReferences(
                                db,
                                table,
                                p0,
                              ).userTargetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.periodId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (userScoresRefs)
                        await $_getPrefetchedData<
                          ScoringPeriod,
                          $ScoringPeriodsTable,
                          UserScore
                        >(
                          currentTable: table,
                          referencedTable: $$ScoringPeriodsTableReferences
                              ._userScoresRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ScoringPeriodsTableReferences(
                                db,
                                table,
                                p0,
                              ).userScoresRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.periodId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (userScoreAggregatesRefs)
                        await $_getPrefetchedData<
                          ScoringPeriod,
                          $ScoringPeriodsTable,
                          UserScoreAggregate
                        >(
                          currentTable: table,
                          referencedTable: $$ScoringPeriodsTableReferences
                              ._userScoreAggregatesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ScoringPeriodsTableReferences(
                                db,
                                table,
                                p0,
                              ).userScoreAggregatesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.periodId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ScoringPeriodsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ScoringPeriodsTable,
      ScoringPeriod,
      $$ScoringPeriodsTableFilterComposer,
      $$ScoringPeriodsTableOrderingComposer,
      $$ScoringPeriodsTableAnnotationComposer,
      $$ScoringPeriodsTableCreateCompanionBuilder,
      $$ScoringPeriodsTableUpdateCompanionBuilder,
      (ScoringPeriod, $$ScoringPeriodsTableReferences),
      ScoringPeriod,
      PrefetchHooks Function({
        bool userTargetsRefs,
        bool userScoresRefs,
        bool userScoreAggregatesRefs,
      })
    >;
typedef $$UserTargetsTableCreateCompanionBuilder =
    UserTargetsCompanion Function({
      required String id,
      required String userId,
      required String measureId,
      required String periodId,
      required double targetValue,
      required String assignedBy,
      required DateTime assignedAt,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$UserTargetsTableUpdateCompanionBuilder =
    UserTargetsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> measureId,
      Value<String> periodId,
      Value<double> targetValue,
      Value<String> assignedBy,
      Value<DateTime> assignedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$UserTargetsTableReferences
    extends BaseReferences<_$AppDatabase, $UserTargetsTable, UserTarget> {
  $$UserTargetsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.userTargets.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $MeasureDefinitionsTable _measureIdTable(_$AppDatabase db) =>
      db.measureDefinitions.createAlias(
        $_aliasNameGenerator(
          db.userTargets.measureId,
          db.measureDefinitions.id,
        ),
      );

  $$MeasureDefinitionsTableProcessedTableManager get measureId {
    final $_column = $_itemColumn<String>('measure_id')!;

    final manager = $$MeasureDefinitionsTableTableManager(
      $_db,
      $_db.measureDefinitions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_measureIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ScoringPeriodsTable _periodIdTable(_$AppDatabase db) =>
      db.scoringPeriods.createAlias(
        $_aliasNameGenerator(db.userTargets.periodId, db.scoringPeriods.id),
      );

  $$ScoringPeriodsTableProcessedTableManager get periodId {
    final $_column = $_itemColumn<String>('period_id')!;

    final manager = $$ScoringPeriodsTableTableManager(
      $_db,
      $_db.scoringPeriods,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_periodIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _assignedByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.userTargets.assignedBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get assignedBy {
    final $_column = $_itemColumn<String>('assigned_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_assignedByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$UserTargetsTableFilterComposer
    extends Composer<_$AppDatabase, $UserTargetsTable> {
  $$UserTargetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get targetValue => $composableBuilder(
    column: $table.targetValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get assignedAt => $composableBuilder(
    column: $table.assignedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MeasureDefinitionsTableFilterComposer get measureId {
    final $$MeasureDefinitionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.measureId,
      referencedTable: $db.measureDefinitions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MeasureDefinitionsTableFilterComposer(
            $db: $db,
            $table: $db.measureDefinitions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableFilterComposer get periodId {
    final $$ScoringPeriodsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableFilterComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get assignedBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserTargetsTableOrderingComposer
    extends Composer<_$AppDatabase, $UserTargetsTable> {
  $$UserTargetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get targetValue => $composableBuilder(
    column: $table.targetValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get assignedAt => $composableBuilder(
    column: $table.assignedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MeasureDefinitionsTableOrderingComposer get measureId {
    final $$MeasureDefinitionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.measureId,
      referencedTable: $db.measureDefinitions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MeasureDefinitionsTableOrderingComposer(
            $db: $db,
            $table: $db.measureDefinitions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableOrderingComposer get periodId {
    final $$ScoringPeriodsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableOrderingComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get assignedBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserTargetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserTargetsTable> {
  $$UserTargetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get targetValue => $composableBuilder(
    column: $table.targetValue,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get assignedAt => $composableBuilder(
    column: $table.assignedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MeasureDefinitionsTableAnnotationComposer get measureId {
    final $$MeasureDefinitionsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.measureId,
          referencedTable: $db.measureDefinitions,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$MeasureDefinitionsTableAnnotationComposer(
                $db: $db,
                $table: $db.measureDefinitions,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$ScoringPeriodsTableAnnotationComposer get periodId {
    final $$ScoringPeriodsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableAnnotationComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get assignedBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.assignedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserTargetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserTargetsTable,
          UserTarget,
          $$UserTargetsTableFilterComposer,
          $$UserTargetsTableOrderingComposer,
          $$UserTargetsTableAnnotationComposer,
          $$UserTargetsTableCreateCompanionBuilder,
          $$UserTargetsTableUpdateCompanionBuilder,
          (UserTarget, $$UserTargetsTableReferences),
          UserTarget,
          PrefetchHooks Function({
            bool userId,
            bool measureId,
            bool periodId,
            bool assignedBy,
          })
        > {
  $$UserTargetsTableTableManager(_$AppDatabase db, $UserTargetsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserTargetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserTargetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserTargetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> measureId = const Value.absent(),
                Value<String> periodId = const Value.absent(),
                Value<double> targetValue = const Value.absent(),
                Value<String> assignedBy = const Value.absent(),
                Value<DateTime> assignedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserTargetsCompanion(
                id: id,
                userId: userId,
                measureId: measureId,
                periodId: periodId,
                targetValue: targetValue,
                assignedBy: assignedBy,
                assignedAt: assignedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String measureId,
                required String periodId,
                required double targetValue,
                required String assignedBy,
                required DateTime assignedAt,
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => UserTargetsCompanion.insert(
                id: id,
                userId: userId,
                measureId: measureId,
                periodId: periodId,
                targetValue: targetValue,
                assignedBy: assignedBy,
                assignedAt: assignedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserTargetsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                userId = false,
                measureId = false,
                periodId = false,
                assignedBy = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable:
                                        $$UserTargetsTableReferences
                                            ._userIdTable(db),
                                    referencedColumn:
                                        $$UserTargetsTableReferences
                                            ._userIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (measureId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.measureId,
                                    referencedTable:
                                        $$UserTargetsTableReferences
                                            ._measureIdTable(db),
                                    referencedColumn:
                                        $$UserTargetsTableReferences
                                            ._measureIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (periodId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.periodId,
                                    referencedTable:
                                        $$UserTargetsTableReferences
                                            ._periodIdTable(db),
                                    referencedColumn:
                                        $$UserTargetsTableReferences
                                            ._periodIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (assignedBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.assignedBy,
                                    referencedTable:
                                        $$UserTargetsTableReferences
                                            ._assignedByTable(db),
                                    referencedColumn:
                                        $$UserTargetsTableReferences
                                            ._assignedByTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$UserTargetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserTargetsTable,
      UserTarget,
      $$UserTargetsTableFilterComposer,
      $$UserTargetsTableOrderingComposer,
      $$UserTargetsTableAnnotationComposer,
      $$UserTargetsTableCreateCompanionBuilder,
      $$UserTargetsTableUpdateCompanionBuilder,
      (UserTarget, $$UserTargetsTableReferences),
      UserTarget,
      PrefetchHooks Function({
        bool userId,
        bool measureId,
        bool periodId,
        bool assignedBy,
      })
    >;
typedef $$UserScoresTableCreateCompanionBuilder =
    UserScoresCompanion Function({
      required String id,
      required String userId,
      required String measureId,
      required String periodId,
      required double targetValue,
      Value<double> actualValue,
      Value<double> percentage,
      Value<double> score,
      Value<int?> rank,
      required DateTime calculatedAt,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$UserScoresTableUpdateCompanionBuilder =
    UserScoresCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> measureId,
      Value<String> periodId,
      Value<double> targetValue,
      Value<double> actualValue,
      Value<double> percentage,
      Value<double> score,
      Value<int?> rank,
      Value<DateTime> calculatedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$UserScoresTableReferences
    extends BaseReferences<_$AppDatabase, $UserScoresTable, UserScore> {
  $$UserScoresTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.userScores.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $MeasureDefinitionsTable _measureIdTable(_$AppDatabase db) =>
      db.measureDefinitions.createAlias(
        $_aliasNameGenerator(db.userScores.measureId, db.measureDefinitions.id),
      );

  $$MeasureDefinitionsTableProcessedTableManager get measureId {
    final $_column = $_itemColumn<String>('measure_id')!;

    final manager = $$MeasureDefinitionsTableTableManager(
      $_db,
      $_db.measureDefinitions,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_measureIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ScoringPeriodsTable _periodIdTable(_$AppDatabase db) =>
      db.scoringPeriods.createAlias(
        $_aliasNameGenerator(db.userScores.periodId, db.scoringPeriods.id),
      );

  $$ScoringPeriodsTableProcessedTableManager get periodId {
    final $_column = $_itemColumn<String>('period_id')!;

    final manager = $$ScoringPeriodsTableTableManager(
      $_db,
      $_db.scoringPeriods,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_periodIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$UserScoresTableFilterComposer
    extends Composer<_$AppDatabase, $UserScoresTable> {
  $$UserScoresTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get targetValue => $composableBuilder(
    column: $table.targetValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get actualValue => $composableBuilder(
    column: $table.actualValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get percentage => $composableBuilder(
    column: $table.percentage,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rank => $composableBuilder(
    column: $table.rank,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get calculatedAt => $composableBuilder(
    column: $table.calculatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MeasureDefinitionsTableFilterComposer get measureId {
    final $$MeasureDefinitionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.measureId,
      referencedTable: $db.measureDefinitions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MeasureDefinitionsTableFilterComposer(
            $db: $db,
            $table: $db.measureDefinitions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableFilterComposer get periodId {
    final $$ScoringPeriodsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableFilterComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserScoresTableOrderingComposer
    extends Composer<_$AppDatabase, $UserScoresTable> {
  $$UserScoresTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get targetValue => $composableBuilder(
    column: $table.targetValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get actualValue => $composableBuilder(
    column: $table.actualValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get percentage => $composableBuilder(
    column: $table.percentage,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get score => $composableBuilder(
    column: $table.score,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rank => $composableBuilder(
    column: $table.rank,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get calculatedAt => $composableBuilder(
    column: $table.calculatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MeasureDefinitionsTableOrderingComposer get measureId {
    final $$MeasureDefinitionsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.measureId,
      referencedTable: $db.measureDefinitions,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$MeasureDefinitionsTableOrderingComposer(
            $db: $db,
            $table: $db.measureDefinitions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableOrderingComposer get periodId {
    final $$ScoringPeriodsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableOrderingComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserScoresTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserScoresTable> {
  $$UserScoresTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get targetValue => $composableBuilder(
    column: $table.targetValue,
    builder: (column) => column,
  );

  GeneratedColumn<double> get actualValue => $composableBuilder(
    column: $table.actualValue,
    builder: (column) => column,
  );

  GeneratedColumn<double> get percentage => $composableBuilder(
    column: $table.percentage,
    builder: (column) => column,
  );

  GeneratedColumn<double> get score =>
      $composableBuilder(column: $table.score, builder: (column) => column);

  GeneratedColumn<int> get rank =>
      $composableBuilder(column: $table.rank, builder: (column) => column);

  GeneratedColumn<DateTime> get calculatedAt => $composableBuilder(
    column: $table.calculatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$MeasureDefinitionsTableAnnotationComposer get measureId {
    final $$MeasureDefinitionsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.measureId,
          referencedTable: $db.measureDefinitions,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$MeasureDefinitionsTableAnnotationComposer(
                $db: $db,
                $table: $db.measureDefinitions,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$ScoringPeriodsTableAnnotationComposer get periodId {
    final $$ScoringPeriodsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableAnnotationComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserScoresTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserScoresTable,
          UserScore,
          $$UserScoresTableFilterComposer,
          $$UserScoresTableOrderingComposer,
          $$UserScoresTableAnnotationComposer,
          $$UserScoresTableCreateCompanionBuilder,
          $$UserScoresTableUpdateCompanionBuilder,
          (UserScore, $$UserScoresTableReferences),
          UserScore,
          PrefetchHooks Function({bool userId, bool measureId, bool periodId})
        > {
  $$UserScoresTableTableManager(_$AppDatabase db, $UserScoresTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserScoresTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserScoresTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserScoresTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> measureId = const Value.absent(),
                Value<String> periodId = const Value.absent(),
                Value<double> targetValue = const Value.absent(),
                Value<double> actualValue = const Value.absent(),
                Value<double> percentage = const Value.absent(),
                Value<double> score = const Value.absent(),
                Value<int?> rank = const Value.absent(),
                Value<DateTime> calculatedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserScoresCompanion(
                id: id,
                userId: userId,
                measureId: measureId,
                periodId: periodId,
                targetValue: targetValue,
                actualValue: actualValue,
                percentage: percentage,
                score: score,
                rank: rank,
                calculatedAt: calculatedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String measureId,
                required String periodId,
                required double targetValue,
                Value<double> actualValue = const Value.absent(),
                Value<double> percentage = const Value.absent(),
                Value<double> score = const Value.absent(),
                Value<int?> rank = const Value.absent(),
                required DateTime calculatedAt,
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => UserScoresCompanion.insert(
                id: id,
                userId: userId,
                measureId: measureId,
                periodId: periodId,
                targetValue: targetValue,
                actualValue: actualValue,
                percentage: percentage,
                score: score,
                rank: rank,
                calculatedAt: calculatedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserScoresTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({userId = false, measureId = false, periodId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$UserScoresTableReferences
                                        ._userIdTable(db),
                                    referencedColumn:
                                        $$UserScoresTableReferences
                                            ._userIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (measureId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.measureId,
                                    referencedTable: $$UserScoresTableReferences
                                        ._measureIdTable(db),
                                    referencedColumn:
                                        $$UserScoresTableReferences
                                            ._measureIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (periodId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.periodId,
                                    referencedTable: $$UserScoresTableReferences
                                        ._periodIdTable(db),
                                    referencedColumn:
                                        $$UserScoresTableReferences
                                            ._periodIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$UserScoresTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserScoresTable,
      UserScore,
      $$UserScoresTableFilterComposer,
      $$UserScoresTableOrderingComposer,
      $$UserScoresTableAnnotationComposer,
      $$UserScoresTableCreateCompanionBuilder,
      $$UserScoresTableUpdateCompanionBuilder,
      (UserScore, $$UserScoresTableReferences),
      UserScore,
      PrefetchHooks Function({bool userId, bool measureId, bool periodId})
    >;
typedef $$UserScoreAggregatesTableCreateCompanionBuilder =
    UserScoreAggregatesCompanion Function({
      required String id,
      required String userId,
      required String periodId,
      Value<double> leadScore,
      Value<double> lagScore,
      Value<double> bonusPoints,
      Value<double> penaltyPoints,
      Value<double> totalScore,
      Value<int?> rank,
      Value<int?> rankChange,
      required DateTime calculatedAt,
      required DateTime createdAt,
      Value<int> rowid,
    });
typedef $$UserScoreAggregatesTableUpdateCompanionBuilder =
    UserScoreAggregatesCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> periodId,
      Value<double> leadScore,
      Value<double> lagScore,
      Value<double> bonusPoints,
      Value<double> penaltyPoints,
      Value<double> totalScore,
      Value<int?> rank,
      Value<int?> rankChange,
      Value<DateTime> calculatedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$UserScoreAggregatesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $UserScoreAggregatesTable,
          UserScoreAggregate
        > {
  $$UserScoreAggregatesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.userScoreAggregates.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ScoringPeriodsTable _periodIdTable(_$AppDatabase db) =>
      db.scoringPeriods.createAlias(
        $_aliasNameGenerator(
          db.userScoreAggregates.periodId,
          db.scoringPeriods.id,
        ),
      );

  $$ScoringPeriodsTableProcessedTableManager get periodId {
    final $_column = $_itemColumn<String>('period_id')!;

    final manager = $$ScoringPeriodsTableTableManager(
      $_db,
      $_db.scoringPeriods,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_periodIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$UserScoreAggregatesTableFilterComposer
    extends Composer<_$AppDatabase, $UserScoreAggregatesTable> {
  $$UserScoreAggregatesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get leadScore => $composableBuilder(
    column: $table.leadScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get lagScore => $composableBuilder(
    column: $table.lagScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get bonusPoints => $composableBuilder(
    column: $table.bonusPoints,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get penaltyPoints => $composableBuilder(
    column: $table.penaltyPoints,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rank => $composableBuilder(
    column: $table.rank,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rankChange => $composableBuilder(
    column: $table.rankChange,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get calculatedAt => $composableBuilder(
    column: $table.calculatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableFilterComposer get periodId {
    final $$ScoringPeriodsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableFilterComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserScoreAggregatesTableOrderingComposer
    extends Composer<_$AppDatabase, $UserScoreAggregatesTable> {
  $$UserScoreAggregatesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get leadScore => $composableBuilder(
    column: $table.leadScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get lagScore => $composableBuilder(
    column: $table.lagScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get bonusPoints => $composableBuilder(
    column: $table.bonusPoints,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get penaltyPoints => $composableBuilder(
    column: $table.penaltyPoints,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rank => $composableBuilder(
    column: $table.rank,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rankChange => $composableBuilder(
    column: $table.rankChange,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get calculatedAt => $composableBuilder(
    column: $table.calculatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableOrderingComposer get periodId {
    final $$ScoringPeriodsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableOrderingComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserScoreAggregatesTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserScoreAggregatesTable> {
  $$UserScoreAggregatesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get leadScore =>
      $composableBuilder(column: $table.leadScore, builder: (column) => column);

  GeneratedColumn<double> get lagScore =>
      $composableBuilder(column: $table.lagScore, builder: (column) => column);

  GeneratedColumn<double> get bonusPoints => $composableBuilder(
    column: $table.bonusPoints,
    builder: (column) => column,
  );

  GeneratedColumn<double> get penaltyPoints => $composableBuilder(
    column: $table.penaltyPoints,
    builder: (column) => column,
  );

  GeneratedColumn<double> get totalScore => $composableBuilder(
    column: $table.totalScore,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rank =>
      $composableBuilder(column: $table.rank, builder: (column) => column);

  GeneratedColumn<int> get rankChange => $composableBuilder(
    column: $table.rankChange,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get calculatedAt => $composableBuilder(
    column: $table.calculatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ScoringPeriodsTableAnnotationComposer get periodId {
    final $$ScoringPeriodsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.periodId,
      referencedTable: $db.scoringPeriods,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ScoringPeriodsTableAnnotationComposer(
            $db: $db,
            $table: $db.scoringPeriods,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserScoreAggregatesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserScoreAggregatesTable,
          UserScoreAggregate,
          $$UserScoreAggregatesTableFilterComposer,
          $$UserScoreAggregatesTableOrderingComposer,
          $$UserScoreAggregatesTableAnnotationComposer,
          $$UserScoreAggregatesTableCreateCompanionBuilder,
          $$UserScoreAggregatesTableUpdateCompanionBuilder,
          (UserScoreAggregate, $$UserScoreAggregatesTableReferences),
          UserScoreAggregate,
          PrefetchHooks Function({bool userId, bool periodId})
        > {
  $$UserScoreAggregatesTableTableManager(
    _$AppDatabase db,
    $UserScoreAggregatesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserScoreAggregatesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserScoreAggregatesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$UserScoreAggregatesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> periodId = const Value.absent(),
                Value<double> leadScore = const Value.absent(),
                Value<double> lagScore = const Value.absent(),
                Value<double> bonusPoints = const Value.absent(),
                Value<double> penaltyPoints = const Value.absent(),
                Value<double> totalScore = const Value.absent(),
                Value<int?> rank = const Value.absent(),
                Value<int?> rankChange = const Value.absent(),
                Value<DateTime> calculatedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserScoreAggregatesCompanion(
                id: id,
                userId: userId,
                periodId: periodId,
                leadScore: leadScore,
                lagScore: lagScore,
                bonusPoints: bonusPoints,
                penaltyPoints: penaltyPoints,
                totalScore: totalScore,
                rank: rank,
                rankChange: rankChange,
                calculatedAt: calculatedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String periodId,
                Value<double> leadScore = const Value.absent(),
                Value<double> lagScore = const Value.absent(),
                Value<double> bonusPoints = const Value.absent(),
                Value<double> penaltyPoints = const Value.absent(),
                Value<double> totalScore = const Value.absent(),
                Value<int?> rank = const Value.absent(),
                Value<int?> rankChange = const Value.absent(),
                required DateTime calculatedAt,
                required DateTime createdAt,
                Value<int> rowid = const Value.absent(),
              }) => UserScoreAggregatesCompanion.insert(
                id: id,
                userId: userId,
                periodId: periodId,
                leadScore: leadScore,
                lagScore: lagScore,
                bonusPoints: bonusPoints,
                penaltyPoints: penaltyPoints,
                totalScore: totalScore,
                rank: rank,
                rankChange: rankChange,
                calculatedAt: calculatedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserScoreAggregatesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false, periodId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$UserScoreAggregatesTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$UserScoreAggregatesTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (periodId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.periodId,
                                referencedTable:
                                    $$UserScoreAggregatesTableReferences
                                        ._periodIdTable(db),
                                referencedColumn:
                                    $$UserScoreAggregatesTableReferences
                                        ._periodIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$UserScoreAggregatesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserScoreAggregatesTable,
      UserScoreAggregate,
      $$UserScoreAggregatesTableFilterComposer,
      $$UserScoreAggregatesTableOrderingComposer,
      $$UserScoreAggregatesTableAnnotationComposer,
      $$UserScoreAggregatesTableCreateCompanionBuilder,
      $$UserScoreAggregatesTableUpdateCompanionBuilder,
      (UserScoreAggregate, $$UserScoreAggregatesTableReferences),
      UserScoreAggregate,
      PrefetchHooks Function({bool userId, bool periodId})
    >;
typedef $$CadenceScheduleConfigTableCreateCompanionBuilder =
    CadenceScheduleConfigCompanion Function({
      required String id,
      required String name,
      Value<String?> description,
      required String targetRole,
      required String facilitatorRole,
      required String frequency,
      Value<int?> dayOfWeek,
      Value<int?> dayOfMonth,
      Value<String?> defaultTime,
      Value<int> durationMinutes,
      Value<int> preMeetingHours,
      Value<bool> isActive,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$CadenceScheduleConfigTableUpdateCompanionBuilder =
    CadenceScheduleConfigCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> description,
      Value<String> targetRole,
      Value<String> facilitatorRole,
      Value<String> frequency,
      Value<int?> dayOfWeek,
      Value<int?> dayOfMonth,
      Value<String?> defaultTime,
      Value<int> durationMinutes,
      Value<int> preMeetingHours,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$CadenceScheduleConfigTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $CadenceScheduleConfigTable,
          CadenceScheduleConfigData
        > {
  $$CadenceScheduleConfigTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$CadenceMeetingsTable, List<CadenceMeeting>>
  _cadenceMeetingsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.cadenceMeetings,
    aliasName: $_aliasNameGenerator(
      db.cadenceScheduleConfig.id,
      db.cadenceMeetings.configId,
    ),
  );

  $$CadenceMeetingsTableProcessedTableManager get cadenceMeetingsRefs {
    final manager = $$CadenceMeetingsTableTableManager(
      $_db,
      $_db.cadenceMeetings,
    ).filter((f) => f.configId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _cadenceMeetingsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CadenceScheduleConfigTableFilterComposer
    extends Composer<_$AppDatabase, $CadenceScheduleConfigTable> {
  $$CadenceScheduleConfigTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetRole => $composableBuilder(
    column: $table.targetRole,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get facilitatorRole => $composableBuilder(
    column: $table.facilitatorRole,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get frequency => $composableBuilder(
    column: $table.frequency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dayOfWeek => $composableBuilder(
    column: $table.dayOfWeek,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dayOfMonth => $composableBuilder(
    column: $table.dayOfMonth,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get defaultTime => $composableBuilder(
    column: $table.defaultTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get preMeetingHours => $composableBuilder(
    column: $table.preMeetingHours,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> cadenceMeetingsRefs(
    Expression<bool> Function($$CadenceMeetingsTableFilterComposer f) f,
  ) {
    final $$CadenceMeetingsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cadenceMeetings,
      getReferencedColumn: (t) => t.configId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceMeetingsTableFilterComposer(
            $db: $db,
            $table: $db.cadenceMeetings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CadenceScheduleConfigTableOrderingComposer
    extends Composer<_$AppDatabase, $CadenceScheduleConfigTable> {
  $$CadenceScheduleConfigTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetRole => $composableBuilder(
    column: $table.targetRole,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get facilitatorRole => $composableBuilder(
    column: $table.facilitatorRole,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get frequency => $composableBuilder(
    column: $table.frequency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dayOfWeek => $composableBuilder(
    column: $table.dayOfWeek,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dayOfMonth => $composableBuilder(
    column: $table.dayOfMonth,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get defaultTime => $composableBuilder(
    column: $table.defaultTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get preMeetingHours => $composableBuilder(
    column: $table.preMeetingHours,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CadenceScheduleConfigTableAnnotationComposer
    extends Composer<_$AppDatabase, $CadenceScheduleConfigTable> {
  $$CadenceScheduleConfigTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get targetRole => $composableBuilder(
    column: $table.targetRole,
    builder: (column) => column,
  );

  GeneratedColumn<String> get facilitatorRole => $composableBuilder(
    column: $table.facilitatorRole,
    builder: (column) => column,
  );

  GeneratedColumn<String> get frequency =>
      $composableBuilder(column: $table.frequency, builder: (column) => column);

  GeneratedColumn<int> get dayOfWeek =>
      $composableBuilder(column: $table.dayOfWeek, builder: (column) => column);

  GeneratedColumn<int> get dayOfMonth => $composableBuilder(
    column: $table.dayOfMonth,
    builder: (column) => column,
  );

  GeneratedColumn<String> get defaultTime => $composableBuilder(
    column: $table.defaultTime,
    builder: (column) => column,
  );

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get preMeetingHours => $composableBuilder(
    column: $table.preMeetingHours,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> cadenceMeetingsRefs<T extends Object>(
    Expression<T> Function($$CadenceMeetingsTableAnnotationComposer a) f,
  ) {
    final $$CadenceMeetingsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cadenceMeetings,
      getReferencedColumn: (t) => t.configId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceMeetingsTableAnnotationComposer(
            $db: $db,
            $table: $db.cadenceMeetings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CadenceScheduleConfigTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CadenceScheduleConfigTable,
          CadenceScheduleConfigData,
          $$CadenceScheduleConfigTableFilterComposer,
          $$CadenceScheduleConfigTableOrderingComposer,
          $$CadenceScheduleConfigTableAnnotationComposer,
          $$CadenceScheduleConfigTableCreateCompanionBuilder,
          $$CadenceScheduleConfigTableUpdateCompanionBuilder,
          (CadenceScheduleConfigData, $$CadenceScheduleConfigTableReferences),
          CadenceScheduleConfigData,
          PrefetchHooks Function({bool cadenceMeetingsRefs})
        > {
  $$CadenceScheduleConfigTableTableManager(
    _$AppDatabase db,
    $CadenceScheduleConfigTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CadenceScheduleConfigTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$CadenceScheduleConfigTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$CadenceScheduleConfigTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> targetRole = const Value.absent(),
                Value<String> facilitatorRole = const Value.absent(),
                Value<String> frequency = const Value.absent(),
                Value<int?> dayOfWeek = const Value.absent(),
                Value<int?> dayOfMonth = const Value.absent(),
                Value<String?> defaultTime = const Value.absent(),
                Value<int> durationMinutes = const Value.absent(),
                Value<int> preMeetingHours = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CadenceScheduleConfigCompanion(
                id: id,
                name: name,
                description: description,
                targetRole: targetRole,
                facilitatorRole: facilitatorRole,
                frequency: frequency,
                dayOfWeek: dayOfWeek,
                dayOfMonth: dayOfMonth,
                defaultTime: defaultTime,
                durationMinutes: durationMinutes,
                preMeetingHours: preMeetingHours,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> description = const Value.absent(),
                required String targetRole,
                required String facilitatorRole,
                required String frequency,
                Value<int?> dayOfWeek = const Value.absent(),
                Value<int?> dayOfMonth = const Value.absent(),
                Value<String?> defaultTime = const Value.absent(),
                Value<int> durationMinutes = const Value.absent(),
                Value<int> preMeetingHours = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => CadenceScheduleConfigCompanion.insert(
                id: id,
                name: name,
                description: description,
                targetRole: targetRole,
                facilitatorRole: facilitatorRole,
                frequency: frequency,
                dayOfWeek: dayOfWeek,
                dayOfMonth: dayOfMonth,
                defaultTime: defaultTime,
                durationMinutes: durationMinutes,
                preMeetingHours: preMeetingHours,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CadenceScheduleConfigTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({cadenceMeetingsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (cadenceMeetingsRefs) db.cadenceMeetings,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (cadenceMeetingsRefs)
                    await $_getPrefetchedData<
                      CadenceScheduleConfigData,
                      $CadenceScheduleConfigTable,
                      CadenceMeeting
                    >(
                      currentTable: table,
                      referencedTable: $$CadenceScheduleConfigTableReferences
                          ._cadenceMeetingsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CadenceScheduleConfigTableReferences(
                            db,
                            table,
                            p0,
                          ).cadenceMeetingsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.configId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CadenceScheduleConfigTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CadenceScheduleConfigTable,
      CadenceScheduleConfigData,
      $$CadenceScheduleConfigTableFilterComposer,
      $$CadenceScheduleConfigTableOrderingComposer,
      $$CadenceScheduleConfigTableAnnotationComposer,
      $$CadenceScheduleConfigTableCreateCompanionBuilder,
      $$CadenceScheduleConfigTableUpdateCompanionBuilder,
      (CadenceScheduleConfigData, $$CadenceScheduleConfigTableReferences),
      CadenceScheduleConfigData,
      PrefetchHooks Function({bool cadenceMeetingsRefs})
    >;
typedef $$CadenceMeetingsTableCreateCompanionBuilder =
    CadenceMeetingsCompanion Function({
      required String id,
      required String configId,
      required String title,
      required DateTime scheduledAt,
      required int durationMinutes,
      required String facilitatorId,
      Value<String> status,
      Value<String?> location,
      Value<String?> meetingLink,
      Value<String?> agenda,
      Value<String?> notes,
      Value<DateTime?> startedAt,
      Value<DateTime?> completedAt,
      required String createdBy,
      Value<bool> isPendingSync,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });
typedef $$CadenceMeetingsTableUpdateCompanionBuilder =
    CadenceMeetingsCompanion Function({
      Value<String> id,
      Value<String> configId,
      Value<String> title,
      Value<DateTime> scheduledAt,
      Value<int> durationMinutes,
      Value<String> facilitatorId,
      Value<String> status,
      Value<String?> location,
      Value<String?> meetingLink,
      Value<String?> agenda,
      Value<String?> notes,
      Value<DateTime?> startedAt,
      Value<DateTime?> completedAt,
      Value<String> createdBy,
      Value<bool> isPendingSync,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> lastSyncAt,
      Value<int> rowid,
    });

final class $$CadenceMeetingsTableReferences
    extends
        BaseReferences<_$AppDatabase, $CadenceMeetingsTable, CadenceMeeting> {
  $$CadenceMeetingsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $CadenceScheduleConfigTable _configIdTable(_$AppDatabase db) =>
      db.cadenceScheduleConfig.createAlias(
        $_aliasNameGenerator(
          db.cadenceMeetings.configId,
          db.cadenceScheduleConfig.id,
        ),
      );

  $$CadenceScheduleConfigTableProcessedTableManager get configId {
    final $_column = $_itemColumn<String>('config_id')!;

    final manager = $$CadenceScheduleConfigTableTableManager(
      $_db,
      $_db.cadenceScheduleConfig,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_configIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _facilitatorIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.cadenceMeetings.facilitatorId, db.users.id),
      );

  $$UsersTableProcessedTableManager get facilitatorId {
    final $_column = $_itemColumn<String>('facilitator_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_facilitatorIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.cadenceMeetings.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $CadenceParticipantsTable,
    List<CadenceParticipant>
  >
  _cadenceParticipantsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.cadenceParticipants,
        aliasName: $_aliasNameGenerator(
          db.cadenceMeetings.id,
          db.cadenceParticipants.meetingId,
        ),
      );

  $$CadenceParticipantsTableProcessedTableManager get cadenceParticipantsRefs {
    final manager = $$CadenceParticipantsTableTableManager(
      $_db,
      $_db.cadenceParticipants,
    ).filter((f) => f.meetingId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _cadenceParticipantsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CadenceMeetingsTableFilterComposer
    extends Composer<_$AppDatabase, $CadenceMeetingsTable> {
  $$CadenceMeetingsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get scheduledAt => $composableBuilder(
    column: $table.scheduledAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get meetingLink => $composableBuilder(
    column: $table.meetingLink,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get agenda => $composableBuilder(
    column: $table.agenda,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CadenceScheduleConfigTableFilterComposer get configId {
    final $$CadenceScheduleConfigTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.configId,
          referencedTable: $db.cadenceScheduleConfig,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$CadenceScheduleConfigTableFilterComposer(
                $db: $db,
                $table: $db.cadenceScheduleConfig,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$UsersTableFilterComposer get facilitatorId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.facilitatorId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> cadenceParticipantsRefs(
    Expression<bool> Function($$CadenceParticipantsTableFilterComposer f) f,
  ) {
    final $$CadenceParticipantsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cadenceParticipants,
      getReferencedColumn: (t) => t.meetingId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceParticipantsTableFilterComposer(
            $db: $db,
            $table: $db.cadenceParticipants,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CadenceMeetingsTableOrderingComposer
    extends Composer<_$AppDatabase, $CadenceMeetingsTable> {
  $$CadenceMeetingsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get scheduledAt => $composableBuilder(
    column: $table.scheduledAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get location => $composableBuilder(
    column: $table.location,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get meetingLink => $composableBuilder(
    column: $table.meetingLink,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get agenda => $composableBuilder(
    column: $table.agenda,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CadenceScheduleConfigTableOrderingComposer get configId {
    final $$CadenceScheduleConfigTableOrderingComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.configId,
          referencedTable: $db.cadenceScheduleConfig,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$CadenceScheduleConfigTableOrderingComposer(
                $db: $db,
                $table: $db.cadenceScheduleConfig,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$UsersTableOrderingComposer get facilitatorId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.facilitatorId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CadenceMeetingsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CadenceMeetingsTable> {
  $$CadenceMeetingsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<DateTime> get scheduledAt => $composableBuilder(
    column: $table.scheduledAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get durationMinutes => $composableBuilder(
    column: $table.durationMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get location =>
      $composableBuilder(column: $table.location, builder: (column) => column);

  GeneratedColumn<String> get meetingLink => $composableBuilder(
    column: $table.meetingLink,
    builder: (column) => column,
  );

  GeneratedColumn<String> get agenda =>
      $composableBuilder(column: $table.agenda, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  $$CadenceScheduleConfigTableAnnotationComposer get configId {
    final $$CadenceScheduleConfigTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.configId,
          referencedTable: $db.cadenceScheduleConfig,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$CadenceScheduleConfigTableAnnotationComposer(
                $db: $db,
                $table: $db.cadenceScheduleConfig,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$UsersTableAnnotationComposer get facilitatorId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.facilitatorId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> cadenceParticipantsRefs<T extends Object>(
    Expression<T> Function($$CadenceParticipantsTableAnnotationComposer a) f,
  ) {
    final $$CadenceParticipantsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.cadenceParticipants,
          getReferencedColumn: (t) => t.meetingId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$CadenceParticipantsTableAnnotationComposer(
                $db: $db,
                $table: $db.cadenceParticipants,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$CadenceMeetingsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CadenceMeetingsTable,
          CadenceMeeting,
          $$CadenceMeetingsTableFilterComposer,
          $$CadenceMeetingsTableOrderingComposer,
          $$CadenceMeetingsTableAnnotationComposer,
          $$CadenceMeetingsTableCreateCompanionBuilder,
          $$CadenceMeetingsTableUpdateCompanionBuilder,
          (CadenceMeeting, $$CadenceMeetingsTableReferences),
          CadenceMeeting,
          PrefetchHooks Function({
            bool configId,
            bool facilitatorId,
            bool createdBy,
            bool cadenceParticipantsRefs,
          })
        > {
  $$CadenceMeetingsTableTableManager(
    _$AppDatabase db,
    $CadenceMeetingsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CadenceMeetingsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CadenceMeetingsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CadenceMeetingsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> configId = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<DateTime> scheduledAt = const Value.absent(),
                Value<int> durationMinutes = const Value.absent(),
                Value<String> facilitatorId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> meetingLink = const Value.absent(),
                Value<String?> agenda = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime?> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CadenceMeetingsCompanion(
                id: id,
                configId: configId,
                title: title,
                scheduledAt: scheduledAt,
                durationMinutes: durationMinutes,
                facilitatorId: facilitatorId,
                status: status,
                location: location,
                meetingLink: meetingLink,
                agenda: agenda,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String configId,
                required String title,
                required DateTime scheduledAt,
                required int durationMinutes,
                required String facilitatorId,
                Value<String> status = const Value.absent(),
                Value<String?> location = const Value.absent(),
                Value<String?> meetingLink = const Value.absent(),
                Value<String?> agenda = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime?> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                required String createdBy,
                Value<bool> isPendingSync = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CadenceMeetingsCompanion.insert(
                id: id,
                configId: configId,
                title: title,
                scheduledAt: scheduledAt,
                durationMinutes: durationMinutes,
                facilitatorId: facilitatorId,
                status: status,
                location: location,
                meetingLink: meetingLink,
                agenda: agenda,
                notes: notes,
                startedAt: startedAt,
                completedAt: completedAt,
                createdBy: createdBy,
                isPendingSync: isPendingSync,
                createdAt: createdAt,
                updatedAt: updatedAt,
                lastSyncAt: lastSyncAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CadenceMeetingsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                configId = false,
                facilitatorId = false,
                createdBy = false,
                cadenceParticipantsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (cadenceParticipantsRefs) db.cadenceParticipants,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (configId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.configId,
                                    referencedTable:
                                        $$CadenceMeetingsTableReferences
                                            ._configIdTable(db),
                                    referencedColumn:
                                        $$CadenceMeetingsTableReferences
                                            ._configIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (facilitatorId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.facilitatorId,
                                    referencedTable:
                                        $$CadenceMeetingsTableReferences
                                            ._facilitatorIdTable(db),
                                    referencedColumn:
                                        $$CadenceMeetingsTableReferences
                                            ._facilitatorIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (createdBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.createdBy,
                                    referencedTable:
                                        $$CadenceMeetingsTableReferences
                                            ._createdByTable(db),
                                    referencedColumn:
                                        $$CadenceMeetingsTableReferences
                                            ._createdByTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (cadenceParticipantsRefs)
                        await $_getPrefetchedData<
                          CadenceMeeting,
                          $CadenceMeetingsTable,
                          CadenceParticipant
                        >(
                          currentTable: table,
                          referencedTable: $$CadenceMeetingsTableReferences
                              ._cadenceParticipantsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CadenceMeetingsTableReferences(
                                db,
                                table,
                                p0,
                              ).cadenceParticipantsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.meetingId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$CadenceMeetingsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CadenceMeetingsTable,
      CadenceMeeting,
      $$CadenceMeetingsTableFilterComposer,
      $$CadenceMeetingsTableOrderingComposer,
      $$CadenceMeetingsTableAnnotationComposer,
      $$CadenceMeetingsTableCreateCompanionBuilder,
      $$CadenceMeetingsTableUpdateCompanionBuilder,
      (CadenceMeeting, $$CadenceMeetingsTableReferences),
      CadenceMeeting,
      PrefetchHooks Function({
        bool configId,
        bool facilitatorId,
        bool createdBy,
        bool cadenceParticipantsRefs,
      })
    >;
typedef $$CadenceParticipantsTableCreateCompanionBuilder =
    CadenceParticipantsCompanion Function({
      required String id,
      required String meetingId,
      required String userId,
      Value<String> attendanceStatus,
      Value<DateTime?> arrivedAt,
      Value<String?> excusedReason,
      Value<int?> attendanceScoreImpact,
      Value<String?> markedBy,
      Value<DateTime?> markedAt,
      Value<bool> preMeetingSubmitted,
      Value<String?> q1PreviousCommitment,
      Value<String?> q1CompletionStatus,
      Value<String?> q2WhatAchieved,
      Value<String?> q3Obstacles,
      Value<String?> q4NextCommitment,
      Value<DateTime?> formSubmittedAt,
      Value<String?> formSubmissionStatus,
      Value<int?> formScoreImpact,
      Value<String?> hostNotes,
      Value<String?> feedbackText,
      Value<DateTime?> feedbackGivenAt,
      Value<DateTime?> feedbackUpdatedAt,
      Value<bool> isPendingSync,
      Value<DateTime?> lastSyncAt,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$CadenceParticipantsTableUpdateCompanionBuilder =
    CadenceParticipantsCompanion Function({
      Value<String> id,
      Value<String> meetingId,
      Value<String> userId,
      Value<String> attendanceStatus,
      Value<DateTime?> arrivedAt,
      Value<String?> excusedReason,
      Value<int?> attendanceScoreImpact,
      Value<String?> markedBy,
      Value<DateTime?> markedAt,
      Value<bool> preMeetingSubmitted,
      Value<String?> q1PreviousCommitment,
      Value<String?> q1CompletionStatus,
      Value<String?> q2WhatAchieved,
      Value<String?> q3Obstacles,
      Value<String?> q4NextCommitment,
      Value<DateTime?> formSubmittedAt,
      Value<String?> formSubmissionStatus,
      Value<int?> formScoreImpact,
      Value<String?> hostNotes,
      Value<String?> feedbackText,
      Value<DateTime?> feedbackGivenAt,
      Value<DateTime?> feedbackUpdatedAt,
      Value<bool> isPendingSync,
      Value<DateTime?> lastSyncAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$CadenceParticipantsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $CadenceParticipantsTable,
          CadenceParticipant
        > {
  $$CadenceParticipantsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $CadenceMeetingsTable _meetingIdTable(_$AppDatabase db) =>
      db.cadenceMeetings.createAlias(
        $_aliasNameGenerator(
          db.cadenceParticipants.meetingId,
          db.cadenceMeetings.id,
        ),
      );

  $$CadenceMeetingsTableProcessedTableManager get meetingId {
    final $_column = $_itemColumn<String>('meeting_id')!;

    final manager = $$CadenceMeetingsTableTableManager(
      $_db,
      $_db.cadenceMeetings,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_meetingIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.cadenceParticipants.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CadenceParticipantsTableFilterComposer
    extends Composer<_$AppDatabase, $CadenceParticipantsTable> {
  $$CadenceParticipantsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get attendanceStatus => $composableBuilder(
    column: $table.attendanceStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get arrivedAt => $composableBuilder(
    column: $table.arrivedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get excusedReason => $composableBuilder(
    column: $table.excusedReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get attendanceScoreImpact => $composableBuilder(
    column: $table.attendanceScoreImpact,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get markedBy => $composableBuilder(
    column: $table.markedBy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get markedAt => $composableBuilder(
    column: $table.markedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get preMeetingSubmitted => $composableBuilder(
    column: $table.preMeetingSubmitted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get q1PreviousCommitment => $composableBuilder(
    column: $table.q1PreviousCommitment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get q1CompletionStatus => $composableBuilder(
    column: $table.q1CompletionStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get q2WhatAchieved => $composableBuilder(
    column: $table.q2WhatAchieved,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get q3Obstacles => $composableBuilder(
    column: $table.q3Obstacles,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get q4NextCommitment => $composableBuilder(
    column: $table.q4NextCommitment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get formSubmittedAt => $composableBuilder(
    column: $table.formSubmittedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get formSubmissionStatus => $composableBuilder(
    column: $table.formSubmissionStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get formScoreImpact => $composableBuilder(
    column: $table.formScoreImpact,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get hostNotes => $composableBuilder(
    column: $table.hostNotes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get feedbackText => $composableBuilder(
    column: $table.feedbackText,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get feedbackGivenAt => $composableBuilder(
    column: $table.feedbackGivenAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get feedbackUpdatedAt => $composableBuilder(
    column: $table.feedbackUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CadenceMeetingsTableFilterComposer get meetingId {
    final $$CadenceMeetingsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.meetingId,
      referencedTable: $db.cadenceMeetings,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceMeetingsTableFilterComposer(
            $db: $db,
            $table: $db.cadenceMeetings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CadenceParticipantsTableOrderingComposer
    extends Composer<_$AppDatabase, $CadenceParticipantsTable> {
  $$CadenceParticipantsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get attendanceStatus => $composableBuilder(
    column: $table.attendanceStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get arrivedAt => $composableBuilder(
    column: $table.arrivedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get excusedReason => $composableBuilder(
    column: $table.excusedReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get attendanceScoreImpact => $composableBuilder(
    column: $table.attendanceScoreImpact,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get markedBy => $composableBuilder(
    column: $table.markedBy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get markedAt => $composableBuilder(
    column: $table.markedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get preMeetingSubmitted => $composableBuilder(
    column: $table.preMeetingSubmitted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get q1PreviousCommitment => $composableBuilder(
    column: $table.q1PreviousCommitment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get q1CompletionStatus => $composableBuilder(
    column: $table.q1CompletionStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get q2WhatAchieved => $composableBuilder(
    column: $table.q2WhatAchieved,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get q3Obstacles => $composableBuilder(
    column: $table.q3Obstacles,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get q4NextCommitment => $composableBuilder(
    column: $table.q4NextCommitment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get formSubmittedAt => $composableBuilder(
    column: $table.formSubmittedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get formSubmissionStatus => $composableBuilder(
    column: $table.formSubmissionStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get formScoreImpact => $composableBuilder(
    column: $table.formScoreImpact,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get hostNotes => $composableBuilder(
    column: $table.hostNotes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get feedbackText => $composableBuilder(
    column: $table.feedbackText,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get feedbackGivenAt => $composableBuilder(
    column: $table.feedbackGivenAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get feedbackUpdatedAt => $composableBuilder(
    column: $table.feedbackUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CadenceMeetingsTableOrderingComposer get meetingId {
    final $$CadenceMeetingsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.meetingId,
      referencedTable: $db.cadenceMeetings,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceMeetingsTableOrderingComposer(
            $db: $db,
            $table: $db.cadenceMeetings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CadenceParticipantsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CadenceParticipantsTable> {
  $$CadenceParticipantsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get attendanceStatus => $composableBuilder(
    column: $table.attendanceStatus,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get arrivedAt =>
      $composableBuilder(column: $table.arrivedAt, builder: (column) => column);

  GeneratedColumn<String> get excusedReason => $composableBuilder(
    column: $table.excusedReason,
    builder: (column) => column,
  );

  GeneratedColumn<int> get attendanceScoreImpact => $composableBuilder(
    column: $table.attendanceScoreImpact,
    builder: (column) => column,
  );

  GeneratedColumn<String> get markedBy =>
      $composableBuilder(column: $table.markedBy, builder: (column) => column);

  GeneratedColumn<DateTime> get markedAt =>
      $composableBuilder(column: $table.markedAt, builder: (column) => column);

  GeneratedColumn<bool> get preMeetingSubmitted => $composableBuilder(
    column: $table.preMeetingSubmitted,
    builder: (column) => column,
  );

  GeneratedColumn<String> get q1PreviousCommitment => $composableBuilder(
    column: $table.q1PreviousCommitment,
    builder: (column) => column,
  );

  GeneratedColumn<String> get q1CompletionStatus => $composableBuilder(
    column: $table.q1CompletionStatus,
    builder: (column) => column,
  );

  GeneratedColumn<String> get q2WhatAchieved => $composableBuilder(
    column: $table.q2WhatAchieved,
    builder: (column) => column,
  );

  GeneratedColumn<String> get q3Obstacles => $composableBuilder(
    column: $table.q3Obstacles,
    builder: (column) => column,
  );

  GeneratedColumn<String> get q4NextCommitment => $composableBuilder(
    column: $table.q4NextCommitment,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get formSubmittedAt => $composableBuilder(
    column: $table.formSubmittedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get formSubmissionStatus => $composableBuilder(
    column: $table.formSubmissionStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get formScoreImpact => $composableBuilder(
    column: $table.formScoreImpact,
    builder: (column) => column,
  );

  GeneratedColumn<String> get hostNotes =>
      $composableBuilder(column: $table.hostNotes, builder: (column) => column);

  GeneratedColumn<String> get feedbackText => $composableBuilder(
    column: $table.feedbackText,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get feedbackGivenAt => $composableBuilder(
    column: $table.feedbackGivenAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get feedbackUpdatedAt => $composableBuilder(
    column: $table.feedbackUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CadenceMeetingsTableAnnotationComposer get meetingId {
    final $$CadenceMeetingsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.meetingId,
      referencedTable: $db.cadenceMeetings,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CadenceMeetingsTableAnnotationComposer(
            $db: $db,
            $table: $db.cadenceMeetings,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CadenceParticipantsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CadenceParticipantsTable,
          CadenceParticipant,
          $$CadenceParticipantsTableFilterComposer,
          $$CadenceParticipantsTableOrderingComposer,
          $$CadenceParticipantsTableAnnotationComposer,
          $$CadenceParticipantsTableCreateCompanionBuilder,
          $$CadenceParticipantsTableUpdateCompanionBuilder,
          (CadenceParticipant, $$CadenceParticipantsTableReferences),
          CadenceParticipant,
          PrefetchHooks Function({bool meetingId, bool userId})
        > {
  $$CadenceParticipantsTableTableManager(
    _$AppDatabase db,
    $CadenceParticipantsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CadenceParticipantsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CadenceParticipantsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$CadenceParticipantsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> meetingId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> attendanceStatus = const Value.absent(),
                Value<DateTime?> arrivedAt = const Value.absent(),
                Value<String?> excusedReason = const Value.absent(),
                Value<int?> attendanceScoreImpact = const Value.absent(),
                Value<String?> markedBy = const Value.absent(),
                Value<DateTime?> markedAt = const Value.absent(),
                Value<bool> preMeetingSubmitted = const Value.absent(),
                Value<String?> q1PreviousCommitment = const Value.absent(),
                Value<String?> q1CompletionStatus = const Value.absent(),
                Value<String?> q2WhatAchieved = const Value.absent(),
                Value<String?> q3Obstacles = const Value.absent(),
                Value<String?> q4NextCommitment = const Value.absent(),
                Value<DateTime?> formSubmittedAt = const Value.absent(),
                Value<String?> formSubmissionStatus = const Value.absent(),
                Value<int?> formScoreImpact = const Value.absent(),
                Value<String?> hostNotes = const Value.absent(),
                Value<String?> feedbackText = const Value.absent(),
                Value<DateTime?> feedbackGivenAt = const Value.absent(),
                Value<DateTime?> feedbackUpdatedAt = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CadenceParticipantsCompanion(
                id: id,
                meetingId: meetingId,
                userId: userId,
                attendanceStatus: attendanceStatus,
                arrivedAt: arrivedAt,
                excusedReason: excusedReason,
                attendanceScoreImpact: attendanceScoreImpact,
                markedBy: markedBy,
                markedAt: markedAt,
                preMeetingSubmitted: preMeetingSubmitted,
                q1PreviousCommitment: q1PreviousCommitment,
                q1CompletionStatus: q1CompletionStatus,
                q2WhatAchieved: q2WhatAchieved,
                q3Obstacles: q3Obstacles,
                q4NextCommitment: q4NextCommitment,
                formSubmittedAt: formSubmittedAt,
                formSubmissionStatus: formSubmissionStatus,
                formScoreImpact: formScoreImpact,
                hostNotes: hostNotes,
                feedbackText: feedbackText,
                feedbackGivenAt: feedbackGivenAt,
                feedbackUpdatedAt: feedbackUpdatedAt,
                isPendingSync: isPendingSync,
                lastSyncAt: lastSyncAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String meetingId,
                required String userId,
                Value<String> attendanceStatus = const Value.absent(),
                Value<DateTime?> arrivedAt = const Value.absent(),
                Value<String?> excusedReason = const Value.absent(),
                Value<int?> attendanceScoreImpact = const Value.absent(),
                Value<String?> markedBy = const Value.absent(),
                Value<DateTime?> markedAt = const Value.absent(),
                Value<bool> preMeetingSubmitted = const Value.absent(),
                Value<String?> q1PreviousCommitment = const Value.absent(),
                Value<String?> q1CompletionStatus = const Value.absent(),
                Value<String?> q2WhatAchieved = const Value.absent(),
                Value<String?> q3Obstacles = const Value.absent(),
                Value<String?> q4NextCommitment = const Value.absent(),
                Value<DateTime?> formSubmittedAt = const Value.absent(),
                Value<String?> formSubmissionStatus = const Value.absent(),
                Value<int?> formScoreImpact = const Value.absent(),
                Value<String?> hostNotes = const Value.absent(),
                Value<String?> feedbackText = const Value.absent(),
                Value<DateTime?> feedbackGivenAt = const Value.absent(),
                Value<DateTime?> feedbackUpdatedAt = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => CadenceParticipantsCompanion.insert(
                id: id,
                meetingId: meetingId,
                userId: userId,
                attendanceStatus: attendanceStatus,
                arrivedAt: arrivedAt,
                excusedReason: excusedReason,
                attendanceScoreImpact: attendanceScoreImpact,
                markedBy: markedBy,
                markedAt: markedAt,
                preMeetingSubmitted: preMeetingSubmitted,
                q1PreviousCommitment: q1PreviousCommitment,
                q1CompletionStatus: q1CompletionStatus,
                q2WhatAchieved: q2WhatAchieved,
                q3Obstacles: q3Obstacles,
                q4NextCommitment: q4NextCommitment,
                formSubmittedAt: formSubmittedAt,
                formSubmissionStatus: formSubmissionStatus,
                formScoreImpact: formScoreImpact,
                hostNotes: hostNotes,
                feedbackText: feedbackText,
                feedbackGivenAt: feedbackGivenAt,
                feedbackUpdatedAt: feedbackUpdatedAt,
                isPendingSync: isPendingSync,
                lastSyncAt: lastSyncAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CadenceParticipantsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({meetingId = false, userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (meetingId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.meetingId,
                                referencedTable:
                                    $$CadenceParticipantsTableReferences
                                        ._meetingIdTable(db),
                                referencedColumn:
                                    $$CadenceParticipantsTableReferences
                                        ._meetingIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$CadenceParticipantsTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$CadenceParticipantsTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CadenceParticipantsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CadenceParticipantsTable,
      CadenceParticipant,
      $$CadenceParticipantsTableFilterComposer,
      $$CadenceParticipantsTableOrderingComposer,
      $$CadenceParticipantsTableAnnotationComposer,
      $$CadenceParticipantsTableCreateCompanionBuilder,
      $$CadenceParticipantsTableUpdateCompanionBuilder,
      (CadenceParticipant, $$CadenceParticipantsTableReferences),
      CadenceParticipant,
      PrefetchHooks Function({bool meetingId, bool userId})
    >;
typedef $$NotificationsTableCreateCompanionBuilder =
    NotificationsCompanion Function({
      required String id,
      required String userId,
      required String type,
      required String title,
      required String body,
      Value<String?> data,
      Value<String?> actionType,
      Value<String?> actionTarget,
      Value<bool> isRead,
      Value<DateTime?> readAt,
      Value<DateTime?> expiresAt,
      required DateTime createdAt,
      Value<int> rowid,
    });
typedef $$NotificationsTableUpdateCompanionBuilder =
    NotificationsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> type,
      Value<String> title,
      Value<String> body,
      Value<String?> data,
      Value<String?> actionType,
      Value<String?> actionTarget,
      Value<bool> isRead,
      Value<DateTime?> readAt,
      Value<DateTime?> expiresAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$NotificationsTableReferences
    extends BaseReferences<_$AppDatabase, $NotificationsTable, Notification> {
  $$NotificationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.notifications.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$NotificationsTableFilterComposer
    extends Composer<_$AppDatabase, $NotificationsTable> {
  $$NotificationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get data => $composableBuilder(
    column: $table.data,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get actionType => $composableBuilder(
    column: $table.actionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get actionTarget => $composableBuilder(
    column: $table.actionTarget,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isRead => $composableBuilder(
    column: $table.isRead,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get readAt => $composableBuilder(
    column: $table.readAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NotificationsTableOrderingComposer
    extends Composer<_$AppDatabase, $NotificationsTable> {
  $$NotificationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get data => $composableBuilder(
    column: $table.data,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get actionType => $composableBuilder(
    column: $table.actionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get actionTarget => $composableBuilder(
    column: $table.actionTarget,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isRead => $composableBuilder(
    column: $table.isRead,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get readAt => $composableBuilder(
    column: $table.readAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NotificationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $NotificationsTable> {
  $$NotificationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get body =>
      $composableBuilder(column: $table.body, builder: (column) => column);

  GeneratedColumn<String> get data =>
      $composableBuilder(column: $table.data, builder: (column) => column);

  GeneratedColumn<String> get actionType => $composableBuilder(
    column: $table.actionType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get actionTarget => $composableBuilder(
    column: $table.actionTarget,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isRead =>
      $composableBuilder(column: $table.isRead, builder: (column) => column);

  GeneratedColumn<DateTime> get readAt =>
      $composableBuilder(column: $table.readAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NotificationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $NotificationsTable,
          Notification,
          $$NotificationsTableFilterComposer,
          $$NotificationsTableOrderingComposer,
          $$NotificationsTableAnnotationComposer,
          $$NotificationsTableCreateCompanionBuilder,
          $$NotificationsTableUpdateCompanionBuilder,
          (Notification, $$NotificationsTableReferences),
          Notification,
          PrefetchHooks Function({bool userId})
        > {
  $$NotificationsTableTableManager(_$AppDatabase db, $NotificationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$NotificationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$NotificationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$NotificationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String> body = const Value.absent(),
                Value<String?> data = const Value.absent(),
                Value<String?> actionType = const Value.absent(),
                Value<String?> actionTarget = const Value.absent(),
                Value<bool> isRead = const Value.absent(),
                Value<DateTime?> readAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => NotificationsCompanion(
                id: id,
                userId: userId,
                type: type,
                title: title,
                body: body,
                data: data,
                actionType: actionType,
                actionTarget: actionTarget,
                isRead: isRead,
                readAt: readAt,
                expiresAt: expiresAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String type,
                required String title,
                required String body,
                Value<String?> data = const Value.absent(),
                Value<String?> actionType = const Value.absent(),
                Value<String?> actionTarget = const Value.absent(),
                Value<bool> isRead = const Value.absent(),
                Value<DateTime?> readAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                required DateTime createdAt,
                Value<int> rowid = const Value.absent(),
              }) => NotificationsCompanion.insert(
                id: id,
                userId: userId,
                type: type,
                title: title,
                body: body,
                data: data,
                actionType: actionType,
                actionTarget: actionTarget,
                isRead: isRead,
                readAt: readAt,
                expiresAt: expiresAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$NotificationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$NotificationsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$NotificationsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$NotificationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $NotificationsTable,
      Notification,
      $$NotificationsTableFilterComposer,
      $$NotificationsTableOrderingComposer,
      $$NotificationsTableAnnotationComposer,
      $$NotificationsTableCreateCompanionBuilder,
      $$NotificationsTableUpdateCompanionBuilder,
      (Notification, $$NotificationsTableReferences),
      Notification,
      PrefetchHooks Function({bool userId})
    >;
typedef $$NotificationSettingsTableCreateCompanionBuilder =
    NotificationSettingsCompanion Function({
      required String id,
      required String userId,
      Value<bool> pushEnabled,
      Value<bool> emailEnabled,
      Value<bool> activityReminders,
      Value<bool> pipelineUpdates,
      Value<bool> referralNotifications,
      Value<bool> cadenceReminders,
      Value<bool> systemNotifications,
      Value<int> reminderMinutesBefore,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$NotificationSettingsTableUpdateCompanionBuilder =
    NotificationSettingsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<bool> pushEnabled,
      Value<bool> emailEnabled,
      Value<bool> activityReminders,
      Value<bool> pipelineUpdates,
      Value<bool> referralNotifications,
      Value<bool> cadenceReminders,
      Value<bool> systemNotifications,
      Value<int> reminderMinutesBefore,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$NotificationSettingsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $NotificationSettingsTable,
          NotificationSetting
        > {
  $$NotificationSettingsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.notificationSettings.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$NotificationSettingsTableFilterComposer
    extends Composer<_$AppDatabase, $NotificationSettingsTable> {
  $$NotificationSettingsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get pushEnabled => $composableBuilder(
    column: $table.pushEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get emailEnabled => $composableBuilder(
    column: $table.emailEnabled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get activityReminders => $composableBuilder(
    column: $table.activityReminders,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get pipelineUpdates => $composableBuilder(
    column: $table.pipelineUpdates,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get referralNotifications => $composableBuilder(
    column: $table.referralNotifications,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get cadenceReminders => $composableBuilder(
    column: $table.cadenceReminders,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get systemNotifications => $composableBuilder(
    column: $table.systemNotifications,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get reminderMinutesBefore => $composableBuilder(
    column: $table.reminderMinutesBefore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NotificationSettingsTableOrderingComposer
    extends Composer<_$AppDatabase, $NotificationSettingsTable> {
  $$NotificationSettingsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get pushEnabled => $composableBuilder(
    column: $table.pushEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get emailEnabled => $composableBuilder(
    column: $table.emailEnabled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get activityReminders => $composableBuilder(
    column: $table.activityReminders,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get pipelineUpdates => $composableBuilder(
    column: $table.pipelineUpdates,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get referralNotifications => $composableBuilder(
    column: $table.referralNotifications,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get cadenceReminders => $composableBuilder(
    column: $table.cadenceReminders,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get systemNotifications => $composableBuilder(
    column: $table.systemNotifications,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get reminderMinutesBefore => $composableBuilder(
    column: $table.reminderMinutesBefore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NotificationSettingsTableAnnotationComposer
    extends Composer<_$AppDatabase, $NotificationSettingsTable> {
  $$NotificationSettingsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<bool> get pushEnabled => $composableBuilder(
    column: $table.pushEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get emailEnabled => $composableBuilder(
    column: $table.emailEnabled,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get activityReminders => $composableBuilder(
    column: $table.activityReminders,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get pipelineUpdates => $composableBuilder(
    column: $table.pipelineUpdates,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get referralNotifications => $composableBuilder(
    column: $table.referralNotifications,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get cadenceReminders => $composableBuilder(
    column: $table.cadenceReminders,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get systemNotifications => $composableBuilder(
    column: $table.systemNotifications,
    builder: (column) => column,
  );

  GeneratedColumn<int> get reminderMinutesBefore => $composableBuilder(
    column: $table.reminderMinutesBefore,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$NotificationSettingsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $NotificationSettingsTable,
          NotificationSetting,
          $$NotificationSettingsTableFilterComposer,
          $$NotificationSettingsTableOrderingComposer,
          $$NotificationSettingsTableAnnotationComposer,
          $$NotificationSettingsTableCreateCompanionBuilder,
          $$NotificationSettingsTableUpdateCompanionBuilder,
          (NotificationSetting, $$NotificationSettingsTableReferences),
          NotificationSetting,
          PrefetchHooks Function({bool userId})
        > {
  $$NotificationSettingsTableTableManager(
    _$AppDatabase db,
    $NotificationSettingsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$NotificationSettingsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$NotificationSettingsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$NotificationSettingsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<bool> pushEnabled = const Value.absent(),
                Value<bool> emailEnabled = const Value.absent(),
                Value<bool> activityReminders = const Value.absent(),
                Value<bool> pipelineUpdates = const Value.absent(),
                Value<bool> referralNotifications = const Value.absent(),
                Value<bool> cadenceReminders = const Value.absent(),
                Value<bool> systemNotifications = const Value.absent(),
                Value<int> reminderMinutesBefore = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => NotificationSettingsCompanion(
                id: id,
                userId: userId,
                pushEnabled: pushEnabled,
                emailEnabled: emailEnabled,
                activityReminders: activityReminders,
                pipelineUpdates: pipelineUpdates,
                referralNotifications: referralNotifications,
                cadenceReminders: cadenceReminders,
                systemNotifications: systemNotifications,
                reminderMinutesBefore: reminderMinutesBefore,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                Value<bool> pushEnabled = const Value.absent(),
                Value<bool> emailEnabled = const Value.absent(),
                Value<bool> activityReminders = const Value.absent(),
                Value<bool> pipelineUpdates = const Value.absent(),
                Value<bool> referralNotifications = const Value.absent(),
                Value<bool> cadenceReminders = const Value.absent(),
                Value<bool> systemNotifications = const Value.absent(),
                Value<int> reminderMinutesBefore = const Value.absent(),
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => NotificationSettingsCompanion.insert(
                id: id,
                userId: userId,
                pushEnabled: pushEnabled,
                emailEnabled: emailEnabled,
                activityReminders: activityReminders,
                pipelineUpdates: pipelineUpdates,
                referralNotifications: referralNotifications,
                cadenceReminders: cadenceReminders,
                systemNotifications: systemNotifications,
                reminderMinutesBefore: reminderMinutesBefore,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$NotificationSettingsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$NotificationSettingsTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$NotificationSettingsTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$NotificationSettingsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $NotificationSettingsTable,
      NotificationSetting,
      $$NotificationSettingsTableFilterComposer,
      $$NotificationSettingsTableOrderingComposer,
      $$NotificationSettingsTableAnnotationComposer,
      $$NotificationSettingsTableCreateCompanionBuilder,
      $$NotificationSettingsTableUpdateCompanionBuilder,
      (NotificationSetting, $$NotificationSettingsTableReferences),
      NotificationSetting,
      PrefetchHooks Function({bool userId})
    >;
typedef $$AnnouncementsTableCreateCompanionBuilder =
    AnnouncementsCompanion Function({
      required String id,
      required String title,
      required String body,
      Value<String> type,
      Value<String?> targetRoles,
      Value<String?> targetBranches,
      required DateTime publishAt,
      Value<DateTime?> expiresAt,
      Value<bool> isPinned,
      required String createdBy,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$AnnouncementsTableUpdateCompanionBuilder =
    AnnouncementsCompanion Function({
      Value<String> id,
      Value<String> title,
      Value<String> body,
      Value<String> type,
      Value<String?> targetRoles,
      Value<String?> targetBranches,
      Value<DateTime> publishAt,
      Value<DateTime?> expiresAt,
      Value<bool> isPinned,
      Value<String> createdBy,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$AnnouncementsTableReferences
    extends BaseReferences<_$AppDatabase, $AnnouncementsTable, Announcement> {
  $$AnnouncementsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _createdByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.announcements.createdBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get createdBy {
    final $_column = $_itemColumn<String>('created_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_createdByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$AnnouncementReadsTable, List<AnnouncementRead>>
  _announcementReadsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.announcementReads,
        aliasName: $_aliasNameGenerator(
          db.announcements.id,
          db.announcementReads.announcementId,
        ),
      );

  $$AnnouncementReadsTableProcessedTableManager get announcementReadsRefs {
    final manager = $$AnnouncementReadsTableTableManager(
      $_db,
      $_db.announcementReads,
    ).filter((f) => f.announcementId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _announcementReadsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$AnnouncementsTableFilterComposer
    extends Composer<_$AppDatabase, $AnnouncementsTable> {
  $$AnnouncementsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetRoles => $composableBuilder(
    column: $table.targetRoles,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetBranches => $composableBuilder(
    column: $table.targetBranches,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get publishAt => $composableBuilder(
    column: $table.publishAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPinned => $composableBuilder(
    column: $table.isPinned,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get createdBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> announcementReadsRefs(
    Expression<bool> Function($$AnnouncementReadsTableFilterComposer f) f,
  ) {
    final $$AnnouncementReadsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.announcementReads,
      getReferencedColumn: (t) => t.announcementId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementReadsTableFilterComposer(
            $db: $db,
            $table: $db.announcementReads,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AnnouncementsTableOrderingComposer
    extends Composer<_$AppDatabase, $AnnouncementsTable> {
  $$AnnouncementsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetRoles => $composableBuilder(
    column: $table.targetRoles,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetBranches => $composableBuilder(
    column: $table.targetBranches,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get publishAt => $composableBuilder(
    column: $table.publishAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPinned => $composableBuilder(
    column: $table.isPinned,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get createdBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AnnouncementsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AnnouncementsTable> {
  $$AnnouncementsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get body =>
      $composableBuilder(column: $table.body, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get targetRoles => $composableBuilder(
    column: $table.targetRoles,
    builder: (column) => column,
  );

  GeneratedColumn<String> get targetBranches => $composableBuilder(
    column: $table.targetBranches,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get publishAt =>
      $composableBuilder(column: $table.publishAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<bool> get isPinned =>
      $composableBuilder(column: $table.isPinned, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get createdBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.createdBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> announcementReadsRefs<T extends Object>(
    Expression<T> Function($$AnnouncementReadsTableAnnotationComposer a) f,
  ) {
    final $$AnnouncementReadsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.announcementReads,
          getReferencedColumn: (t) => t.announcementId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$AnnouncementReadsTableAnnotationComposer(
                $db: $db,
                $table: $db.announcementReads,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$AnnouncementsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AnnouncementsTable,
          Announcement,
          $$AnnouncementsTableFilterComposer,
          $$AnnouncementsTableOrderingComposer,
          $$AnnouncementsTableAnnotationComposer,
          $$AnnouncementsTableCreateCompanionBuilder,
          $$AnnouncementsTableUpdateCompanionBuilder,
          (Announcement, $$AnnouncementsTableReferences),
          Announcement,
          PrefetchHooks Function({bool createdBy, bool announcementReadsRefs})
        > {
  $$AnnouncementsTableTableManager(_$AppDatabase db, $AnnouncementsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AnnouncementsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AnnouncementsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AnnouncementsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String> body = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String?> targetRoles = const Value.absent(),
                Value<String?> targetBranches = const Value.absent(),
                Value<DateTime> publishAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<bool> isPinned = const Value.absent(),
                Value<String> createdBy = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AnnouncementsCompanion(
                id: id,
                title: title,
                body: body,
                type: type,
                targetRoles: targetRoles,
                targetBranches: targetBranches,
                publishAt: publishAt,
                expiresAt: expiresAt,
                isPinned: isPinned,
                createdBy: createdBy,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String title,
                required String body,
                Value<String> type = const Value.absent(),
                Value<String?> targetRoles = const Value.absent(),
                Value<String?> targetBranches = const Value.absent(),
                required DateTime publishAt,
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<bool> isPinned = const Value.absent(),
                required String createdBy,
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => AnnouncementsCompanion.insert(
                id: id,
                title: title,
                body: body,
                type: type,
                targetRoles: targetRoles,
                targetBranches: targetBranches,
                publishAt: publishAt,
                expiresAt: expiresAt,
                isPinned: isPinned,
                createdBy: createdBy,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AnnouncementsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({createdBy = false, announcementReadsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (announcementReadsRefs) db.announcementReads,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (createdBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.createdBy,
                                    referencedTable:
                                        $$AnnouncementsTableReferences
                                            ._createdByTable(db),
                                    referencedColumn:
                                        $$AnnouncementsTableReferences
                                            ._createdByTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (announcementReadsRefs)
                        await $_getPrefetchedData<
                          Announcement,
                          $AnnouncementsTable,
                          AnnouncementRead
                        >(
                          currentTable: table,
                          referencedTable: $$AnnouncementsTableReferences
                              ._announcementReadsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$AnnouncementsTableReferences(
                                db,
                                table,
                                p0,
                              ).announcementReadsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.announcementId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$AnnouncementsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AnnouncementsTable,
      Announcement,
      $$AnnouncementsTableFilterComposer,
      $$AnnouncementsTableOrderingComposer,
      $$AnnouncementsTableAnnotationComposer,
      $$AnnouncementsTableCreateCompanionBuilder,
      $$AnnouncementsTableUpdateCompanionBuilder,
      (Announcement, $$AnnouncementsTableReferences),
      Announcement,
      PrefetchHooks Function({bool createdBy, bool announcementReadsRefs})
    >;
typedef $$AnnouncementReadsTableCreateCompanionBuilder =
    AnnouncementReadsCompanion Function({
      required String id,
      required String announcementId,
      required String userId,
      required DateTime readAt,
      Value<int> rowid,
    });
typedef $$AnnouncementReadsTableUpdateCompanionBuilder =
    AnnouncementReadsCompanion Function({
      Value<String> id,
      Value<String> announcementId,
      Value<String> userId,
      Value<DateTime> readAt,
      Value<int> rowid,
    });

final class $$AnnouncementReadsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $AnnouncementReadsTable,
          AnnouncementRead
        > {
  $$AnnouncementReadsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $AnnouncementsTable _announcementIdTable(_$AppDatabase db) =>
      db.announcements.createAlias(
        $_aliasNameGenerator(
          db.announcementReads.announcementId,
          db.announcements.id,
        ),
      );

  $$AnnouncementsTableProcessedTableManager get announcementId {
    final $_column = $_itemColumn<String>('announcement_id')!;

    final manager = $$AnnouncementsTableTableManager(
      $_db,
      $_db.announcements,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_announcementIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.announcementReads.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AnnouncementReadsTableFilterComposer
    extends Composer<_$AppDatabase, $AnnouncementReadsTable> {
  $$AnnouncementReadsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get readAt => $composableBuilder(
    column: $table.readAt,
    builder: (column) => ColumnFilters(column),
  );

  $$AnnouncementsTableFilterComposer get announcementId {
    final $$AnnouncementsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.announcementId,
      referencedTable: $db.announcements,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementsTableFilterComposer(
            $db: $db,
            $table: $db.announcements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AnnouncementReadsTableOrderingComposer
    extends Composer<_$AppDatabase, $AnnouncementReadsTable> {
  $$AnnouncementReadsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get readAt => $composableBuilder(
    column: $table.readAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$AnnouncementsTableOrderingComposer get announcementId {
    final $$AnnouncementsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.announcementId,
      referencedTable: $db.announcements,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementsTableOrderingComposer(
            $db: $db,
            $table: $db.announcements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AnnouncementReadsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AnnouncementReadsTable> {
  $$AnnouncementReadsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get readAt =>
      $composableBuilder(column: $table.readAt, builder: (column) => column);

  $$AnnouncementsTableAnnotationComposer get announcementId {
    final $$AnnouncementsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.announcementId,
      referencedTable: $db.announcements,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AnnouncementsTableAnnotationComposer(
            $db: $db,
            $table: $db.announcements,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AnnouncementReadsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AnnouncementReadsTable,
          AnnouncementRead,
          $$AnnouncementReadsTableFilterComposer,
          $$AnnouncementReadsTableOrderingComposer,
          $$AnnouncementReadsTableAnnotationComposer,
          $$AnnouncementReadsTableCreateCompanionBuilder,
          $$AnnouncementReadsTableUpdateCompanionBuilder,
          (AnnouncementRead, $$AnnouncementReadsTableReferences),
          AnnouncementRead,
          PrefetchHooks Function({bool announcementId, bool userId})
        > {
  $$AnnouncementReadsTableTableManager(
    _$AppDatabase db,
    $AnnouncementReadsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AnnouncementReadsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AnnouncementReadsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AnnouncementReadsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> announcementId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<DateTime> readAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AnnouncementReadsCompanion(
                id: id,
                announcementId: announcementId,
                userId: userId,
                readAt: readAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String announcementId,
                required String userId,
                required DateTime readAt,
                Value<int> rowid = const Value.absent(),
              }) => AnnouncementReadsCompanion.insert(
                id: id,
                announcementId: announcementId,
                userId: userId,
                readAt: readAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AnnouncementReadsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({announcementId = false, userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (announcementId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.announcementId,
                                referencedTable:
                                    $$AnnouncementReadsTableReferences
                                        ._announcementIdTable(db),
                                referencedColumn:
                                    $$AnnouncementReadsTableReferences
                                        ._announcementIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$AnnouncementReadsTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$AnnouncementReadsTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AnnouncementReadsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AnnouncementReadsTable,
      AnnouncementRead,
      $$AnnouncementReadsTableFilterComposer,
      $$AnnouncementReadsTableOrderingComposer,
      $$AnnouncementReadsTableAnnotationComposer,
      $$AnnouncementReadsTableCreateCompanionBuilder,
      $$AnnouncementReadsTableUpdateCompanionBuilder,
      (AnnouncementRead, $$AnnouncementReadsTableReferences),
      AnnouncementRead,
      PrefetchHooks Function({bool announcementId, bool userId})
    >;
typedef $$SyncQueueItemsTableCreateCompanionBuilder =
    SyncQueueItemsCompanion Function({
      Value<int> id,
      required String entityType,
      required String entityId,
      required String operation,
      required String payload,
      Value<int> retryCount,
      Value<String?> lastError,
      Value<String> status,
      required DateTime createdAt,
      Value<DateTime?> lastAttemptAt,
    });
typedef $$SyncQueueItemsTableUpdateCompanionBuilder =
    SyncQueueItemsCompanion Function({
      Value<int> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> operation,
      Value<String> payload,
      Value<int> retryCount,
      Value<String?> lastError,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime?> lastAttemptAt,
    });

class $$SyncQueueItemsTableFilterComposer
    extends Composer<_$AppDatabase, $SyncQueueItemsTable> {
  $$SyncQueueItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastError => $composableBuilder(
    column: $table.lastError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncQueueItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncQueueItemsTable> {
  $$SyncQueueItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastError => $composableBuilder(
    column: $table.lastError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncQueueItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncQueueItemsTable> {
  $$SyncQueueItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get operation =>
      $composableBuilder(column: $table.operation, builder: (column) => column);

  GeneratedColumn<String> get payload =>
      $composableBuilder(column: $table.payload, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastError =>
      $composableBuilder(column: $table.lastError, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => column,
  );
}

class $$SyncQueueItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncQueueItemsTable,
          SyncQueueItem,
          $$SyncQueueItemsTableFilterComposer,
          $$SyncQueueItemsTableOrderingComposer,
          $$SyncQueueItemsTableAnnotationComposer,
          $$SyncQueueItemsTableCreateCompanionBuilder,
          $$SyncQueueItemsTableUpdateCompanionBuilder,
          (
            SyncQueueItem,
            BaseReferences<_$AppDatabase, $SyncQueueItemsTable, SyncQueueItem>,
          ),
          SyncQueueItem,
          PrefetchHooks Function()
        > {
  $$SyncQueueItemsTableTableManager(
    _$AppDatabase db,
    $SyncQueueItemsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncQueueItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncQueueItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncQueueItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> operation = const Value.absent(),
                Value<String> payload = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<String?> lastError = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastAttemptAt = const Value.absent(),
              }) => SyncQueueItemsCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                operation: operation,
                payload: payload,
                retryCount: retryCount,
                lastError: lastError,
                status: status,
                createdAt: createdAt,
                lastAttemptAt: lastAttemptAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String entityType,
                required String entityId,
                required String operation,
                required String payload,
                Value<int> retryCount = const Value.absent(),
                Value<String?> lastError = const Value.absent(),
                Value<String> status = const Value.absent(),
                required DateTime createdAt,
                Value<DateTime?> lastAttemptAt = const Value.absent(),
              }) => SyncQueueItemsCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                operation: operation,
                payload: payload,
                retryCount: retryCount,
                lastError: lastError,
                status: status,
                createdAt: createdAt,
                lastAttemptAt: lastAttemptAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncQueueItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncQueueItemsTable,
      SyncQueueItem,
      $$SyncQueueItemsTableFilterComposer,
      $$SyncQueueItemsTableOrderingComposer,
      $$SyncQueueItemsTableAnnotationComposer,
      $$SyncQueueItemsTableCreateCompanionBuilder,
      $$SyncQueueItemsTableUpdateCompanionBuilder,
      (
        SyncQueueItem,
        BaseReferences<_$AppDatabase, $SyncQueueItemsTable, SyncQueueItem>,
      ),
      SyncQueueItem,
      PrefetchHooks Function()
    >;
typedef $$AuditLogsTableCreateCompanionBuilder =
    AuditLogsCompanion Function({
      required String id,
      required String targetTable,
      required String recordId,
      required String action,
      Value<String?> oldValues,
      Value<String?> newValues,
      Value<String?> changedBy,
      required DateTime changedAt,
      Value<String?> ipAddress,
      Value<String?> userAgent,
      Value<int> rowid,
    });
typedef $$AuditLogsTableUpdateCompanionBuilder =
    AuditLogsCompanion Function({
      Value<String> id,
      Value<String> targetTable,
      Value<String> recordId,
      Value<String> action,
      Value<String?> oldValues,
      Value<String?> newValues,
      Value<String?> changedBy,
      Value<DateTime> changedAt,
      Value<String?> ipAddress,
      Value<String?> userAgent,
      Value<int> rowid,
    });

final class $$AuditLogsTableReferences
    extends BaseReferences<_$AppDatabase, $AuditLogsTable, AuditLog> {
  $$AuditLogsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _changedByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.auditLogs.changedBy, db.users.id),
  );

  $$UsersTableProcessedTableManager? get changedBy {
    final $_column = $_itemColumn<String>('changed_by');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_changedByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AuditLogsTableFilterComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetTable => $composableBuilder(
    column: $table.targetTable,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get oldValues => $composableBuilder(
    column: $table.oldValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get newValues => $composableBuilder(
    column: $table.newValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get changedAt => $composableBuilder(
    column: $table.changedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userAgent => $composableBuilder(
    column: $table.userAgent,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get changedBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.changedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AuditLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetTable => $composableBuilder(
    column: $table.targetTable,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get oldValues => $composableBuilder(
    column: $table.oldValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get newValues => $composableBuilder(
    column: $table.newValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get changedAt => $composableBuilder(
    column: $table.changedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userAgent => $composableBuilder(
    column: $table.userAgent,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get changedBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.changedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AuditLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get targetTable => $composableBuilder(
    column: $table.targetTable,
    builder: (column) => column,
  );

  GeneratedColumn<String> get recordId =>
      $composableBuilder(column: $table.recordId, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get oldValues =>
      $composableBuilder(column: $table.oldValues, builder: (column) => column);

  GeneratedColumn<String> get newValues =>
      $composableBuilder(column: $table.newValues, builder: (column) => column);

  GeneratedColumn<DateTime> get changedAt =>
      $composableBuilder(column: $table.changedAt, builder: (column) => column);

  GeneratedColumn<String> get ipAddress =>
      $composableBuilder(column: $table.ipAddress, builder: (column) => column);

  GeneratedColumn<String> get userAgent =>
      $composableBuilder(column: $table.userAgent, builder: (column) => column);

  $$UsersTableAnnotationComposer get changedBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.changedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AuditLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AuditLogsTable,
          AuditLog,
          $$AuditLogsTableFilterComposer,
          $$AuditLogsTableOrderingComposer,
          $$AuditLogsTableAnnotationComposer,
          $$AuditLogsTableCreateCompanionBuilder,
          $$AuditLogsTableUpdateCompanionBuilder,
          (AuditLog, $$AuditLogsTableReferences),
          AuditLog,
          PrefetchHooks Function({bool changedBy})
        > {
  $$AuditLogsTableTableManager(_$AppDatabase db, $AuditLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AuditLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AuditLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AuditLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> targetTable = const Value.absent(),
                Value<String> recordId = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String?> oldValues = const Value.absent(),
                Value<String?> newValues = const Value.absent(),
                Value<String?> changedBy = const Value.absent(),
                Value<DateTime> changedAt = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<String?> userAgent = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogsCompanion(
                id: id,
                targetTable: targetTable,
                recordId: recordId,
                action: action,
                oldValues: oldValues,
                newValues: newValues,
                changedBy: changedBy,
                changedAt: changedAt,
                ipAddress: ipAddress,
                userAgent: userAgent,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String targetTable,
                required String recordId,
                required String action,
                Value<String?> oldValues = const Value.absent(),
                Value<String?> newValues = const Value.absent(),
                Value<String?> changedBy = const Value.absent(),
                required DateTime changedAt,
                Value<String?> ipAddress = const Value.absent(),
                Value<String?> userAgent = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogsCompanion.insert(
                id: id,
                targetTable: targetTable,
                recordId: recordId,
                action: action,
                oldValues: oldValues,
                newValues: newValues,
                changedBy: changedBy,
                changedAt: changedAt,
                ipAddress: ipAddress,
                userAgent: userAgent,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AuditLogsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({changedBy = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (changedBy) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.changedBy,
                                referencedTable: $$AuditLogsTableReferences
                                    ._changedByTable(db),
                                referencedColumn: $$AuditLogsTableReferences
                                    ._changedByTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AuditLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AuditLogsTable,
      AuditLog,
      $$AuditLogsTableFilterComposer,
      $$AuditLogsTableOrderingComposer,
      $$AuditLogsTableAnnotationComposer,
      $$AuditLogsTableCreateCompanionBuilder,
      $$AuditLogsTableUpdateCompanionBuilder,
      (AuditLog, $$AuditLogsTableReferences),
      AuditLog,
      PrefetchHooks Function({bool changedBy})
    >;
typedef $$AppSettingsTableCreateCompanionBuilder =
    AppSettingsCompanion Function({
      required String key,
      required String value,
      required DateTime updatedAt,
      Value<int> rowid,
    });
typedef $$AppSettingsTableUpdateCompanionBuilder =
    AppSettingsCompanion Function({
      Value<String> key,
      Value<String> value,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

class $$AppSettingsTableFilterComposer
    extends Composer<_$AppDatabase, $AppSettingsTable> {
  $$AppSettingsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get key => $composableBuilder(
    column: $table.key,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AppSettingsTableOrderingComposer
    extends Composer<_$AppDatabase, $AppSettingsTable> {
  $$AppSettingsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get key => $composableBuilder(
    column: $table.key,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AppSettingsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AppSettingsTable> {
  $$AppSettingsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get key =>
      $composableBuilder(column: $table.key, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$AppSettingsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AppSettingsTable,
          AppSetting,
          $$AppSettingsTableFilterComposer,
          $$AppSettingsTableOrderingComposer,
          $$AppSettingsTableAnnotationComposer,
          $$AppSettingsTableCreateCompanionBuilder,
          $$AppSettingsTableUpdateCompanionBuilder,
          (
            AppSetting,
            BaseReferences<_$AppDatabase, $AppSettingsTable, AppSetting>,
          ),
          AppSetting,
          PrefetchHooks Function()
        > {
  $$AppSettingsTableTableManager(_$AppDatabase db, $AppSettingsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AppSettingsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AppSettingsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AppSettingsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> key = const Value.absent(),
                Value<String> value = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AppSettingsCompanion(
                key: key,
                value: value,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String key,
                required String value,
                required DateTime updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => AppSettingsCompanion.insert(
                key: key,
                value: value,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AppSettingsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AppSettingsTable,
      AppSetting,
      $$AppSettingsTableFilterComposer,
      $$AppSettingsTableOrderingComposer,
      $$AppSettingsTableAnnotationComposer,
      $$AppSettingsTableCreateCompanionBuilder,
      $$AppSettingsTableUpdateCompanionBuilder,
      (
        AppSetting,
        BaseReferences<_$AppDatabase, $AppSettingsTable, AppSetting>,
      ),
      AppSetting,
      PrefetchHooks Function()
    >;
typedef $$SyncConflictsTableCreateCompanionBuilder =
    SyncConflictsCompanion Function({
      Value<int> id,
      required String entityType,
      required String entityId,
      required String localPayload,
      required String serverPayload,
      required DateTime localUpdatedAt,
      required DateTime serverUpdatedAt,
      required String winner,
      Value<String> resolution,
      required DateTime detectedAt,
    });
typedef $$SyncConflictsTableUpdateCompanionBuilder =
    SyncConflictsCompanion Function({
      Value<int> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> localPayload,
      Value<String> serverPayload,
      Value<DateTime> localUpdatedAt,
      Value<DateTime> serverUpdatedAt,
      Value<String> winner,
      Value<String> resolution,
      Value<DateTime> detectedAt,
    });

class $$SyncConflictsTableFilterComposer
    extends Composer<_$AppDatabase, $SyncConflictsTable> {
  $$SyncConflictsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get localPayload => $composableBuilder(
    column: $table.localPayload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get serverPayload => $composableBuilder(
    column: $table.serverPayload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get localUpdatedAt => $composableBuilder(
    column: $table.localUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get serverUpdatedAt => $composableBuilder(
    column: $table.serverUpdatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get winner => $composableBuilder(
    column: $table.winner,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get resolution => $composableBuilder(
    column: $table.resolution,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get detectedAt => $composableBuilder(
    column: $table.detectedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncConflictsTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncConflictsTable> {
  $$SyncConflictsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get localPayload => $composableBuilder(
    column: $table.localPayload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get serverPayload => $composableBuilder(
    column: $table.serverPayload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get localUpdatedAt => $composableBuilder(
    column: $table.localUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get serverUpdatedAt => $composableBuilder(
    column: $table.serverUpdatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get winner => $composableBuilder(
    column: $table.winner,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get resolution => $composableBuilder(
    column: $table.resolution,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get detectedAt => $composableBuilder(
    column: $table.detectedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncConflictsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncConflictsTable> {
  $$SyncConflictsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get localPayload => $composableBuilder(
    column: $table.localPayload,
    builder: (column) => column,
  );

  GeneratedColumn<String> get serverPayload => $composableBuilder(
    column: $table.serverPayload,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get localUpdatedAt => $composableBuilder(
    column: $table.localUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get serverUpdatedAt => $composableBuilder(
    column: $table.serverUpdatedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get winner =>
      $composableBuilder(column: $table.winner, builder: (column) => column);

  GeneratedColumn<String> get resolution => $composableBuilder(
    column: $table.resolution,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get detectedAt => $composableBuilder(
    column: $table.detectedAt,
    builder: (column) => column,
  );
}

class $$SyncConflictsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncConflictsTable,
          SyncConflict,
          $$SyncConflictsTableFilterComposer,
          $$SyncConflictsTableOrderingComposer,
          $$SyncConflictsTableAnnotationComposer,
          $$SyncConflictsTableCreateCompanionBuilder,
          $$SyncConflictsTableUpdateCompanionBuilder,
          (
            SyncConflict,
            BaseReferences<_$AppDatabase, $SyncConflictsTable, SyncConflict>,
          ),
          SyncConflict,
          PrefetchHooks Function()
        > {
  $$SyncConflictsTableTableManager(_$AppDatabase db, $SyncConflictsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncConflictsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncConflictsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncConflictsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> localPayload = const Value.absent(),
                Value<String> serverPayload = const Value.absent(),
                Value<DateTime> localUpdatedAt = const Value.absent(),
                Value<DateTime> serverUpdatedAt = const Value.absent(),
                Value<String> winner = const Value.absent(),
                Value<String> resolution = const Value.absent(),
                Value<DateTime> detectedAt = const Value.absent(),
              }) => SyncConflictsCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                localPayload: localPayload,
                serverPayload: serverPayload,
                localUpdatedAt: localUpdatedAt,
                serverUpdatedAt: serverUpdatedAt,
                winner: winner,
                resolution: resolution,
                detectedAt: detectedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String entityType,
                required String entityId,
                required String localPayload,
                required String serverPayload,
                required DateTime localUpdatedAt,
                required DateTime serverUpdatedAt,
                required String winner,
                Value<String> resolution = const Value.absent(),
                required DateTime detectedAt,
              }) => SyncConflictsCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                localPayload: localPayload,
                serverPayload: serverPayload,
                localUpdatedAt: localUpdatedAt,
                serverUpdatedAt: serverUpdatedAt,
                winner: winner,
                resolution: resolution,
                detectedAt: detectedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncConflictsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncConflictsTable,
      SyncConflict,
      $$SyncConflictsTableFilterComposer,
      $$SyncConflictsTableOrderingComposer,
      $$SyncConflictsTableAnnotationComposer,
      $$SyncConflictsTableCreateCompanionBuilder,
      $$SyncConflictsTableUpdateCompanionBuilder,
      (
        SyncConflict,
        BaseReferences<_$AppDatabase, $SyncConflictsTable, SyncConflict>,
      ),
      SyncConflict,
      PrefetchHooks Function()
    >;
typedef $$PipelineStageHistoryItemsTableCreateCompanionBuilder =
    PipelineStageHistoryItemsCompanion Function({
      required String id,
      required String pipelineId,
      Value<String?> fromStageId,
      required String toStageId,
      Value<String?> fromStatusId,
      Value<String?> toStatusId,
      Value<String?> notes,
      Value<String?> changedBy,
      required DateTime changedAt,
      Value<double?> latitude,
      Value<double?> longitude,
      required DateTime cachedAt,
      Value<bool> isPendingSync,
      Value<bool> createdLocally,
      Value<DateTime?> lastSyncAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$PipelineStageHistoryItemsTableUpdateCompanionBuilder =
    PipelineStageHistoryItemsCompanion Function({
      Value<String> id,
      Value<String> pipelineId,
      Value<String?> fromStageId,
      Value<String> toStageId,
      Value<String?> fromStatusId,
      Value<String?> toStatusId,
      Value<String?> notes,
      Value<String?> changedBy,
      Value<DateTime> changedAt,
      Value<double?> latitude,
      Value<double?> longitude,
      Value<DateTime> cachedAt,
      Value<bool> isPendingSync,
      Value<bool> createdLocally,
      Value<DateTime?> lastSyncAt,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

class $$PipelineStageHistoryItemsTableFilterComposer
    extends Composer<_$AppDatabase, $PipelineStageHistoryItemsTable> {
  $$PipelineStageHistoryItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get pipelineId => $composableBuilder(
    column: $table.pipelineId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fromStageId => $composableBuilder(
    column: $table.fromStageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get toStageId => $composableBuilder(
    column: $table.toStageId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fromStatusId => $composableBuilder(
    column: $table.fromStatusId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get toStatusId => $composableBuilder(
    column: $table.toStatusId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get changedBy => $composableBuilder(
    column: $table.changedBy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get changedAt => $composableBuilder(
    column: $table.changedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get cachedAt => $composableBuilder(
    column: $table.cachedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get createdLocally => $composableBuilder(
    column: $table.createdLocally,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PipelineStageHistoryItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $PipelineStageHistoryItemsTable> {
  $$PipelineStageHistoryItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get pipelineId => $composableBuilder(
    column: $table.pipelineId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fromStageId => $composableBuilder(
    column: $table.fromStageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get toStageId => $composableBuilder(
    column: $table.toStageId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fromStatusId => $composableBuilder(
    column: $table.fromStatusId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get toStatusId => $composableBuilder(
    column: $table.toStatusId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get changedBy => $composableBuilder(
    column: $table.changedBy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get changedAt => $composableBuilder(
    column: $table.changedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get cachedAt => $composableBuilder(
    column: $table.cachedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get createdLocally => $composableBuilder(
    column: $table.createdLocally,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PipelineStageHistoryItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PipelineStageHistoryItemsTable> {
  $$PipelineStageHistoryItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get pipelineId => $composableBuilder(
    column: $table.pipelineId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fromStageId => $composableBuilder(
    column: $table.fromStageId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get toStageId =>
      $composableBuilder(column: $table.toStageId, builder: (column) => column);

  GeneratedColumn<String> get fromStatusId => $composableBuilder(
    column: $table.fromStatusId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get toStatusId => $composableBuilder(
    column: $table.toStatusId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get changedBy =>
      $composableBuilder(column: $table.changedBy, builder: (column) => column);

  GeneratedColumn<DateTime> get changedAt =>
      $composableBuilder(column: $table.changedAt, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<DateTime> get cachedAt =>
      $composableBuilder(column: $table.cachedAt, builder: (column) => column);

  GeneratedColumn<bool> get isPendingSync => $composableBuilder(
    column: $table.isPendingSync,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get createdLocally => $composableBuilder(
    column: $table.createdLocally,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSyncAt => $composableBuilder(
    column: $table.lastSyncAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$PipelineStageHistoryItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PipelineStageHistoryItemsTable,
          PipelineStageHistoryItem,
          $$PipelineStageHistoryItemsTableFilterComposer,
          $$PipelineStageHistoryItemsTableOrderingComposer,
          $$PipelineStageHistoryItemsTableAnnotationComposer,
          $$PipelineStageHistoryItemsTableCreateCompanionBuilder,
          $$PipelineStageHistoryItemsTableUpdateCompanionBuilder,
          (
            PipelineStageHistoryItem,
            BaseReferences<
              _$AppDatabase,
              $PipelineStageHistoryItemsTable,
              PipelineStageHistoryItem
            >,
          ),
          PipelineStageHistoryItem,
          PrefetchHooks Function()
        > {
  $$PipelineStageHistoryItemsTableTableManager(
    _$AppDatabase db,
    $PipelineStageHistoryItemsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PipelineStageHistoryItemsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$PipelineStageHistoryItemsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$PipelineStageHistoryItemsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> pipelineId = const Value.absent(),
                Value<String?> fromStageId = const Value.absent(),
                Value<String> toStageId = const Value.absent(),
                Value<String?> fromStatusId = const Value.absent(),
                Value<String?> toStatusId = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> changedBy = const Value.absent(),
                Value<DateTime> changedAt = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<DateTime> cachedAt = const Value.absent(),
                Value<bool> isPendingSync = const Value.absent(),
                Value<bool> createdLocally = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelineStageHistoryItemsCompanion(
                id: id,
                pipelineId: pipelineId,
                fromStageId: fromStageId,
                toStageId: toStageId,
                fromStatusId: fromStatusId,
                toStatusId: toStatusId,
                notes: notes,
                changedBy: changedBy,
                changedAt: changedAt,
                latitude: latitude,
                longitude: longitude,
                cachedAt: cachedAt,
                isPendingSync: isPendingSync,
                createdLocally: createdLocally,
                lastSyncAt: lastSyncAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String pipelineId,
                Value<String?> fromStageId = const Value.absent(),
                required String toStageId,
                Value<String?> fromStatusId = const Value.absent(),
                Value<String?> toStatusId = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> changedBy = const Value.absent(),
                required DateTime changedAt,
                Value<double?> latitude = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                required DateTime cachedAt,
                Value<bool> isPendingSync = const Value.absent(),
                Value<bool> createdLocally = const Value.absent(),
                Value<DateTime?> lastSyncAt = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PipelineStageHistoryItemsCompanion.insert(
                id: id,
                pipelineId: pipelineId,
                fromStageId: fromStageId,
                toStageId: toStageId,
                fromStatusId: fromStatusId,
                toStatusId: toStatusId,
                notes: notes,
                changedBy: changedBy,
                changedAt: changedAt,
                latitude: latitude,
                longitude: longitude,
                cachedAt: cachedAt,
                isPendingSync: isPendingSync,
                createdLocally: createdLocally,
                lastSyncAt: lastSyncAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PipelineStageHistoryItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PipelineStageHistoryItemsTable,
      PipelineStageHistoryItem,
      $$PipelineStageHistoryItemsTableFilterComposer,
      $$PipelineStageHistoryItemsTableOrderingComposer,
      $$PipelineStageHistoryItemsTableAnnotationComposer,
      $$PipelineStageHistoryItemsTableCreateCompanionBuilder,
      $$PipelineStageHistoryItemsTableUpdateCompanionBuilder,
      (
        PipelineStageHistoryItem,
        BaseReferences<
          _$AppDatabase,
          $PipelineStageHistoryItemsTable,
          PipelineStageHistoryItem
        >,
      ),
      PipelineStageHistoryItem,
      PrefetchHooks Function()
    >;
typedef $$AuditLogCacheTableCreateCompanionBuilder =
    AuditLogCacheCompanion Function({
      required String id,
      Value<String?> userId,
      Value<String?> userEmail,
      required String action,
      required String targetTable,
      required String targetId,
      Value<String?> oldValues,
      Value<String?> newValues,
      Value<String?> ipAddress,
      Value<String?> userAgent,
      required DateTime createdAt,
      required DateTime cachedAt,
      Value<int> rowid,
    });
typedef $$AuditLogCacheTableUpdateCompanionBuilder =
    AuditLogCacheCompanion Function({
      Value<String> id,
      Value<String?> userId,
      Value<String?> userEmail,
      Value<String> action,
      Value<String> targetTable,
      Value<String> targetId,
      Value<String?> oldValues,
      Value<String?> newValues,
      Value<String?> ipAddress,
      Value<String?> userAgent,
      Value<DateTime> createdAt,
      Value<DateTime> cachedAt,
      Value<int> rowid,
    });

class $$AuditLogCacheTableFilterComposer
    extends Composer<_$AppDatabase, $AuditLogCacheTable> {
  $$AuditLogCacheTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userEmail => $composableBuilder(
    column: $table.userEmail,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetTable => $composableBuilder(
    column: $table.targetTable,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetId => $composableBuilder(
    column: $table.targetId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get oldValues => $composableBuilder(
    column: $table.oldValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get newValues => $composableBuilder(
    column: $table.newValues,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userAgent => $composableBuilder(
    column: $table.userAgent,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get cachedAt => $composableBuilder(
    column: $table.cachedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AuditLogCacheTableOrderingComposer
    extends Composer<_$AppDatabase, $AuditLogCacheTable> {
  $$AuditLogCacheTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userEmail => $composableBuilder(
    column: $table.userEmail,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetTable => $composableBuilder(
    column: $table.targetTable,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetId => $composableBuilder(
    column: $table.targetId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get oldValues => $composableBuilder(
    column: $table.oldValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get newValues => $composableBuilder(
    column: $table.newValues,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ipAddress => $composableBuilder(
    column: $table.ipAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userAgent => $composableBuilder(
    column: $table.userAgent,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get cachedAt => $composableBuilder(
    column: $table.cachedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AuditLogCacheTableAnnotationComposer
    extends Composer<_$AppDatabase, $AuditLogCacheTable> {
  $$AuditLogCacheTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get userEmail =>
      $composableBuilder(column: $table.userEmail, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get targetTable => $composableBuilder(
    column: $table.targetTable,
    builder: (column) => column,
  );

  GeneratedColumn<String> get targetId =>
      $composableBuilder(column: $table.targetId, builder: (column) => column);

  GeneratedColumn<String> get oldValues =>
      $composableBuilder(column: $table.oldValues, builder: (column) => column);

  GeneratedColumn<String> get newValues =>
      $composableBuilder(column: $table.newValues, builder: (column) => column);

  GeneratedColumn<String> get ipAddress =>
      $composableBuilder(column: $table.ipAddress, builder: (column) => column);

  GeneratedColumn<String> get userAgent =>
      $composableBuilder(column: $table.userAgent, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get cachedAt =>
      $composableBuilder(column: $table.cachedAt, builder: (column) => column);
}

class $$AuditLogCacheTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AuditLogCacheTable,
          AuditLogCacheData,
          $$AuditLogCacheTableFilterComposer,
          $$AuditLogCacheTableOrderingComposer,
          $$AuditLogCacheTableAnnotationComposer,
          $$AuditLogCacheTableCreateCompanionBuilder,
          $$AuditLogCacheTableUpdateCompanionBuilder,
          (
            AuditLogCacheData,
            BaseReferences<
              _$AppDatabase,
              $AuditLogCacheTable,
              AuditLogCacheData
            >,
          ),
          AuditLogCacheData,
          PrefetchHooks Function()
        > {
  $$AuditLogCacheTableTableManager(_$AppDatabase db, $AuditLogCacheTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AuditLogCacheTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AuditLogCacheTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AuditLogCacheTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                Value<String?> userEmail = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String> targetTable = const Value.absent(),
                Value<String> targetId = const Value.absent(),
                Value<String?> oldValues = const Value.absent(),
                Value<String?> newValues = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<String?> userAgent = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> cachedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogCacheCompanion(
                id: id,
                userId: userId,
                userEmail: userEmail,
                action: action,
                targetTable: targetTable,
                targetId: targetId,
                oldValues: oldValues,
                newValues: newValues,
                ipAddress: ipAddress,
                userAgent: userAgent,
                createdAt: createdAt,
                cachedAt: cachedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> userId = const Value.absent(),
                Value<String?> userEmail = const Value.absent(),
                required String action,
                required String targetTable,
                required String targetId,
                Value<String?> oldValues = const Value.absent(),
                Value<String?> newValues = const Value.absent(),
                Value<String?> ipAddress = const Value.absent(),
                Value<String?> userAgent = const Value.absent(),
                required DateTime createdAt,
                required DateTime cachedAt,
                Value<int> rowid = const Value.absent(),
              }) => AuditLogCacheCompanion.insert(
                id: id,
                userId: userId,
                userEmail: userEmail,
                action: action,
                targetTable: targetTable,
                targetId: targetId,
                oldValues: oldValues,
                newValues: newValues,
                ipAddress: ipAddress,
                userAgent: userAgent,
                createdAt: createdAt,
                cachedAt: cachedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AuditLogCacheTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AuditLogCacheTable,
      AuditLogCacheData,
      $$AuditLogCacheTableFilterComposer,
      $$AuditLogCacheTableOrderingComposer,
      $$AuditLogCacheTableAnnotationComposer,
      $$AuditLogCacheTableCreateCompanionBuilder,
      $$AuditLogCacheTableUpdateCompanionBuilder,
      (
        AuditLogCacheData,
        BaseReferences<_$AppDatabase, $AuditLogCacheTable, AuditLogCacheData>,
      ),
      AuditLogCacheData,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$RegionalOfficesTableTableManager get regionalOffices =>
      $$RegionalOfficesTableTableManager(_db, _db.regionalOffices);
  $$BranchesTableTableManager get branches =>
      $$BranchesTableTableManager(_db, _db.branches);
  $$UsersTableTableManager get users =>
      $$UsersTableTableManager(_db, _db.users);
  $$UserHierarchyTableTableManager get userHierarchy =>
      $$UserHierarchyTableTableManager(_db, _db.userHierarchy);
  $$ProvincesTableTableManager get provinces =>
      $$ProvincesTableTableManager(_db, _db.provinces);
  $$CitiesTableTableManager get cities =>
      $$CitiesTableTableManager(_db, _db.cities);
  $$CompanyTypesTableTableManager get companyTypes =>
      $$CompanyTypesTableTableManager(_db, _db.companyTypes);
  $$OwnershipTypesTableTableManager get ownershipTypes =>
      $$OwnershipTypesTableTableManager(_db, _db.ownershipTypes);
  $$IndustriesTableTableManager get industries =>
      $$IndustriesTableTableManager(_db, _db.industries);
  $$CobsTableTableManager get cobs => $$CobsTableTableManager(_db, _db.cobs);
  $$LobsTableTableManager get lobs => $$LobsTableTableManager(_db, _db.lobs);
  $$PipelineStagesTableTableManager get pipelineStages =>
      $$PipelineStagesTableTableManager(_db, _db.pipelineStages);
  $$PipelineStatusesTableTableManager get pipelineStatuses =>
      $$PipelineStatusesTableTableManager(_db, _db.pipelineStatuses);
  $$ActivityTypesTableTableManager get activityTypes =>
      $$ActivityTypesTableTableManager(_db, _db.activityTypes);
  $$LeadSourcesTableTableManager get leadSources =>
      $$LeadSourcesTableTableManager(_db, _db.leadSources);
  $$DeclineReasonsTableTableManager get declineReasons =>
      $$DeclineReasonsTableTableManager(_db, _db.declineReasons);
  $$CustomersTableTableManager get customers =>
      $$CustomersTableTableManager(_db, _db.customers);
  $$KeyPersonsTableTableManager get keyPersons =>
      $$KeyPersonsTableTableManager(_db, _db.keyPersons);
  $$PipelinesTableTableManager get pipelines =>
      $$PipelinesTableTableManager(_db, _db.pipelines);
  $$PipelineReferralsTableTableManager get pipelineReferrals =>
      $$PipelineReferralsTableTableManager(_db, _db.pipelineReferrals);
  $$ActivitiesTableTableManager get activities =>
      $$ActivitiesTableTableManager(_db, _db.activities);
  $$ActivityPhotosTableTableManager get activityPhotos =>
      $$ActivityPhotosTableTableManager(_db, _db.activityPhotos);
  $$ActivityAuditLogsTableTableManager get activityAuditLogs =>
      $$ActivityAuditLogsTableTableManager(_db, _db.activityAuditLogs);
  $$HvcTypesTableTableManager get hvcTypes =>
      $$HvcTypesTableTableManager(_db, _db.hvcTypes);
  $$HvcsTableTableManager get hvcs => $$HvcsTableTableManager(_db, _db.hvcs);
  $$CustomerHvcLinksTableTableManager get customerHvcLinks =>
      $$CustomerHvcLinksTableTableManager(_db, _db.customerHvcLinks);
  $$BrokersTableTableManager get brokers =>
      $$BrokersTableTableManager(_db, _db.brokers);
  $$MeasureDefinitionsTableTableManager get measureDefinitions =>
      $$MeasureDefinitionsTableTableManager(_db, _db.measureDefinitions);
  $$ScoringPeriodsTableTableManager get scoringPeriods =>
      $$ScoringPeriodsTableTableManager(_db, _db.scoringPeriods);
  $$UserTargetsTableTableManager get userTargets =>
      $$UserTargetsTableTableManager(_db, _db.userTargets);
  $$UserScoresTableTableManager get userScores =>
      $$UserScoresTableTableManager(_db, _db.userScores);
  $$UserScoreAggregatesTableTableManager get userScoreAggregates =>
      $$UserScoreAggregatesTableTableManager(_db, _db.userScoreAggregates);
  $$CadenceScheduleConfigTableTableManager get cadenceScheduleConfig =>
      $$CadenceScheduleConfigTableTableManager(_db, _db.cadenceScheduleConfig);
  $$CadenceMeetingsTableTableManager get cadenceMeetings =>
      $$CadenceMeetingsTableTableManager(_db, _db.cadenceMeetings);
  $$CadenceParticipantsTableTableManager get cadenceParticipants =>
      $$CadenceParticipantsTableTableManager(_db, _db.cadenceParticipants);
  $$NotificationsTableTableManager get notifications =>
      $$NotificationsTableTableManager(_db, _db.notifications);
  $$NotificationSettingsTableTableManager get notificationSettings =>
      $$NotificationSettingsTableTableManager(_db, _db.notificationSettings);
  $$AnnouncementsTableTableManager get announcements =>
      $$AnnouncementsTableTableManager(_db, _db.announcements);
  $$AnnouncementReadsTableTableManager get announcementReads =>
      $$AnnouncementReadsTableTableManager(_db, _db.announcementReads);
  $$SyncQueueItemsTableTableManager get syncQueueItems =>
      $$SyncQueueItemsTableTableManager(_db, _db.syncQueueItems);
  $$AuditLogsTableTableManager get auditLogs =>
      $$AuditLogsTableTableManager(_db, _db.auditLogs);
  $$AppSettingsTableTableManager get appSettings =>
      $$AppSettingsTableTableManager(_db, _db.appSettings);
  $$SyncConflictsTableTableManager get syncConflicts =>
      $$SyncConflictsTableTableManager(_db, _db.syncConflicts);
  $$PipelineStageHistoryItemsTableTableManager get pipelineStageHistoryItems =>
      $$PipelineStageHistoryItemsTableTableManager(
        _db,
        _db.pipelineStageHistoryItems,
      );
  $$AuditLogCacheTableTableManager get auditLogCache =>
      $$AuditLogCacheTableTableManager(_db, _db.auditLogCache);
}
