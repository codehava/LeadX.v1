---
phase: 04-conflict-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/database/tables/sync_queue.dart
  - lib/data/database/app_database.dart
  - lib/data/services/sync_service.dart
  - lib/data/datasources/local/sync_queue_local_data_source.dart
autonomous: true

must_haves:
  truths:
    - "Sync create operations use Supabase upsert so retrying a create does not create duplicates"
    - "Sync update operations include updatedAt version guard so concurrent updates are detected"
    - "When version guard detects conflict, LWW resolution compares timestamps and higher wins"
    - "All detected conflicts are logged to sync_conflicts audit table with both payloads"
    - "LWW-resolved conflicts complete successfully (not marked as failed sync items)"
    - "Server-wins conflicts apply full field-level resolution for customer, pipeline, and activity entities; secondary entities (keyPerson, hvc, broker, cadence, pipelineReferral) log the conflict and mark as synced, relying on the next pull cycle to apply server data"
  artifacts:
    - path: "lib/data/database/tables/sync_queue.dart"
      provides: "SyncConflicts Drift table definition"
      contains: "class SyncConflicts extends Table"
    - path: "lib/data/database/app_database.dart"
      provides: "Schema v11 migration creating sync_conflicts table"
      contains: "schemaVersion => 11"
    - path: "lib/data/services/sync_service.dart"
      provides: "Conflict detection and LWW resolution in _processItem"
      contains: "_resolveConflict"
    - path: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      provides: "Conflict logging and querying methods"
      contains: "insertConflict"
  key_links:
    - from: "lib/data/services/sync_service.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "_syncQueueDataSource.insertConflict()"
      pattern: "insertConflict"
    - from: "lib/data/services/sync_service.dart"
      to: "Supabase upsert"
      via: "_supabaseClient.from(tableName).upsert(payload)"
      pattern: "\\.upsert\\(payload\\)"
    - from: "lib/data/services/sync_service.dart"
      to: "Supabase version guard"
      via: ".eq('updated_at', serverUpdatedAt)"
      pattern: "\\.eq\\('updated_at'"
---

<objective>
Create the sync_conflicts audit table and implement conflict detection + LWW resolution in SyncService._processItem.

Purpose: This is the core infrastructure for Phase 4. Without it, creates are non-idempotent (retry = duplicates) and updates silently overwrite concurrent changes.
Output: SyncConflicts Drift table at schema v11, SyncService with upsert for creates, version guard for updates, LWW conflict resolution, and conflict audit logging.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-conflict-resolution/04-RESEARCH.md

@lib/data/database/tables/sync_queue.dart
@lib/data/database/app_database.dart
@lib/data/services/sync_service.dart
@lib/data/datasources/local/sync_queue_local_data_source.dart
@lib/core/errors/sync_errors.dart
@lib/core/utils/date_time_utils.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SyncConflicts Drift table and schema v11 migration</name>
  <files>lib/data/database/tables/sync_queue.dart, lib/data/database/app_database.dart</files>
  <action>
1. In `lib/data/database/tables/sync_queue.dart`, add a new `SyncConflicts` table class after the existing `AppSettings` class:

```dart
/// Local-only audit table for sync conflict logging.
/// Records all detected conflicts with before/after payload snapshots.
/// NOT synced to server - this is for local debugging and UI display.
class SyncConflicts extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get entityType => text()();
  TextColumn get entityId => text()();
  TextColumn get localPayload => text()();   // JSON string
  TextColumn get serverPayload => text()();  // JSON string
  DateTimeColumn get localUpdatedAt => dateTime()();
  DateTimeColumn get serverUpdatedAt => dateTime()();
  TextColumn get winner => text()();  // 'local' or 'server'
  TextColumn get resolution => text().withDefault(const Constant('lww'))();
  DateTimeColumn get detectedAt => dateTime()();

  @override
  String get tableName => 'sync_conflicts';
}
```

2. In `lib/data/database/app_database.dart`:
   - Add `SyncConflicts` to the `@DriftDatabase(tables: [...])` list, in the SYSTEM section alongside `SyncQueueItems`, `AuditLogs`, `AppSettings`.
   - Bump `schemaVersion` from `10` to `11`.
   - Add migration block for `from < 11`:
     ```dart
     if (from < 11) {
       await m.createTable(syncConflicts);
     }
     ```

3. Run `dart run build_runner build --delete-conflicting-outputs` to generate the updated `app_database.g.dart` with the new table.

4. Verify the generated code compiles: `flutter analyze` should show no new errors related to the SyncConflicts table.
  </action>
  <verify>
- `dart run build_runner build --delete-conflicting-outputs` completes without errors
- `flutter analyze` shows no new errors
- `lib/data/database/app_database.g.dart` contains `SyncConflict` generated class and `syncConflicts` accessor
- `schemaVersion` is 11 in `app_database.dart`
  </verify>
  <done>SyncConflicts Drift table exists with all required columns. Schema v11 migration creates the table on upgrade. Generated code compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement conflict detection and LWW resolution in SyncService</name>
  <files>lib/data/services/sync_service.dart, lib/data/datasources/local/sync_queue_local_data_source.dart</files>
  <action>
**In `lib/data/datasources/local/sync_queue_local_data_source.dart`**, add these methods:

1. `insertConflict()` - inserts a row into `sync_conflicts`:
```dart
Future<int> insertConflict({
  required String entityType,
  required String entityId,
  required String localPayload,
  required String serverPayload,
  required DateTime localUpdatedAt,
  required DateTime serverUpdatedAt,
  required String winner,
  String resolution = 'lww',
}) async {
  return _db.into(_db.syncConflicts).insert(
    SyncConflictsCompanion.insert(
      entityType: entityType,
      entityId: entityId,
      localPayload: localPayload,
      serverPayload: serverPayload,
      localUpdatedAt: localUpdatedAt,
      serverUpdatedAt: serverUpdatedAt,
      winner: winner,
      detectedAt: DateTime.now(),
    ),
  );
}
```

2. `watchRecentConflictCount()` - stream of conflict count from last 7 days:
```dart
Stream<int> watchRecentConflictCount({int days = 7}) {
  final cutoff = DateTime.now().subtract(Duration(days: days));
  return (_db.selectOnly(_db.syncConflicts)
    ..addColumns([_db.syncConflicts.id.count()])
    ..where(_db.syncConflicts.detectedAt.isBiggerOrEqualValue(cutoff)))
    .map((row) => row.read(_db.syncConflicts.id.count()) ?? 0)
    .watchSingle();
}
```

3. `getRecentConflicts()` - get recent conflicts list (for future UI):
```dart
Future<List<SyncConflict>> getRecentConflicts({int days = 7, int limit = 50}) {
  final cutoff = DateTime.now().subtract(Duration(days: days));
  return (_db.select(_db.syncConflicts)
    ..where((t) => t.detectedAt.isBiggerOrEqualValue(cutoff))
    ..orderBy([(t) => OrderingTerm.desc(t.detectedAt)])
    ..limit(limit))
    .get();
}
```

**In `lib/data/services/sync_service.dart`**, make these changes:

1. **Change `insert` to `upsert` for creates** in `_processItem`:
```dart
case 'create':
  // Idempotent: upsert handles retry-after-timeout gracefully
  await _supabaseClient.from(tableName).upsert(payload);
```

2. **Add version guard for updates** in `_processItem`:
```dart
case 'update':
  // Extract version guard metadata (added by repositories when queueing updates)
  final serverUpdatedAt = payload.remove('_server_updated_at') as String?;

  if (serverUpdatedAt != null) {
    // Optimistic locking: only update if server record hasn't changed
    final result = await _supabaseClient
        .from(tableName)
        .update(payload)
        .eq('id', item.entityId)
        .eq('updated_at', serverUpdatedAt)
        .select();

    if ((result as List).isEmpty) {
      // Version guard failed - conflict detected, resolve via LWW
      await _resolveConflict(item, payload, tableName);
    }
  } else {
    // No version guard (legacy queue items or create+update coalesced)
    await _supabaseClient
        .from(tableName)
        .update(payload)
        .eq('id', item.entityId);
  }
```

3. **Add `_resolveConflict` method** (after `_processItem`):
```dart
/// Resolve a sync conflict using Last-Write-Wins (LWW) strategy.
/// Fetches server record, compares timestamps, logs conflict, and applies winner.
/// This method resolves the conflict internally - it does NOT throw.
/// Only throws if resolution itself fails (can't fetch server, can't write).
Future<void> _resolveConflict(
  db.SyncQueueItem item,
  Map<String, dynamic> localPayload,
  String tableName,
) async {
  _log.warning('sync.push | Conflict detected for ${item.entityType}/${item.entityId}');

  // Fetch current server state
  final serverRecord = await _supabaseClient
      .from(tableName)
      .select()
      .eq('id', item.entityId)
      .maybeSingle();

  if (serverRecord == null) {
    // Record deleted on server - log and treat as server wins
    _log.warning('sync.push | Server record deleted during conflict: ${item.entityId}');
    await _syncQueueDataSource.insertConflict(
      entityType: item.entityType,
      entityId: item.entityId,
      localPayload: jsonEncode(localPayload),
      serverPayload: '{}',
      localUpdatedAt: DateTime.tryParse(localPayload['updated_at'] as String? ?? '') ?? DateTime.now(),
      serverUpdatedAt: DateTime.now(),
      winner: 'server',
      resolution: 'server_deleted',
    );
    return;
  }

  final serverUpdatedAtStr = serverRecord['updated_at'] as String;
  final localUpdatedAtStr = localPayload['updated_at'] as String;
  final serverUpdatedAt = DateTime.parse(serverUpdatedAtStr);
  final localUpdatedAt = DateTime.parse(localUpdatedAtStr);
  final winner = localUpdatedAt.isAfter(serverUpdatedAt) ? 'local' : 'server';

  // Log conflict to audit table regardless of winner
  await _syncQueueDataSource.insertConflict(
    entityType: item.entityType,
    entityId: item.entityId,
    localPayload: jsonEncode(localPayload),
    serverPayload: jsonEncode(serverRecord),
    localUpdatedAt: localUpdatedAt,
    serverUpdatedAt: serverUpdatedAt,
    winner: winner,
  );

  if (winner == 'local') {
    // Local wins - force push without version guard
    await _supabaseClient
        .from(tableName)
        .update(localPayload)
        .eq('id', item.entityId);
    _log.info('sync.push | Conflict resolved: LOCAL wins for ${item.entityType}/${item.entityId}');
  } else {
    // Server wins - apply server data to local DB
    await _applyServerDataLocally(item.entityType, item.entityId, serverRecord);
    _log.info('sync.push | Conflict resolved: SERVER wins for ${item.entityType}/${item.entityId}');
  }
}
```

4. **Add `_applyServerDataLocally` method** - when server wins a conflict, apply server data to local DB by using the same upsert pattern used by pull sync. For each entity type, construct a Companion from the server record and write it to local DB:

```dart
/// Apply server record to local database when server wins a conflict.
Future<void> _applyServerDataLocally(
  String entityType,
  String entityId,
  Map<String, dynamic> serverRecord,
) async {
  // Mark as not pending sync (server data is authoritative)
  // and set lastSyncAt to now
  final syncedAt = DateTime.now();

  switch (entityType) {
    case 'customer':
      await (_database.update(_database.customers)
            ..where((c) => c.id.equals(entityId)))
          .write(db.CustomersCompanion(
            name: Value(serverRecord['name'] as String? ?? ''),
            address: Value(serverRecord['address'] as String? ?? ''),
            provinceId: Value(serverRecord['province_id'] as String? ?? ''),
            cityId: Value(serverRecord['city_id'] as String? ?? ''),
            postalCode: Value(serverRecord['postal_code'] as String?),
            latitude: Value((serverRecord['latitude'] as num?)?.toDouble()),
            longitude: Value((serverRecord['longitude'] as num?)?.toDouble()),
            phone: Value(serverRecord['phone'] as String?),
            email: Value(serverRecord['email'] as String?),
            website: Value(serverRecord['website'] as String?),
            companyTypeId: Value(serverRecord['company_type_id'] as String? ?? ''),
            ownershipTypeId: Value(serverRecord['ownership_type_id'] as String? ?? ''),
            industryId: Value(serverRecord['industry_id'] as String? ?? ''),
            npwp: Value(serverRecord['npwp'] as String?),
            assignedRmId: Value(serverRecord['assigned_rm_id'] as String? ?? ''),
            imageUrl: Value(serverRecord['image_url'] as String?),
            notes: Value(serverRecord['notes'] as String?),
            isActive: Value(serverRecord['is_active'] as bool? ?? true),
            updatedAt: Value(DateTime.parse(serverRecord['updated_at'] as String)),
            deletedAt: serverRecord['deleted_at'] != null
                ? Value(DateTime.parse(serverRecord['deleted_at'] as String))
                : const Value(null),
            isPendingSync: const Value(false),
            lastSyncAt: Value(syncedAt),
          ));

    case 'pipeline':
      await (_database.update(_database.pipelines)
            ..where((p) => p.id.equals(entityId)))
          .write(db.PipelinesCompanion(
            customerId: Value(serverRecord['customer_id'] as String? ?? ''),
            title: Value(serverRecord['title'] as String? ?? ''),
            description: Value(serverRecord['description'] as String?),
            stageId: Value(serverRecord['stage_id'] as String? ?? ''),
            statusId: Value(serverRecord['status_id'] as String? ?? ''),
            estimatedValue: Value((serverRecord['estimated_value'] as num?)?.toDouble() ?? 0),
            finalPremium: Value((serverRecord['final_premium'] as num?)?.toDouble()),
            probability: Value((serverRecord['probability'] as num?)?.toDouble()),
            expectedCloseDate: serverRecord['expected_close_date'] != null
                ? Value(DateTime.parse(serverRecord['expected_close_date'] as String))
                : const Value(null),
            closedAt: serverRecord['closed_at'] != null
                ? Value(DateTime.parse(serverRecord['closed_at'] as String))
                : const Value(null),
            declineReasonId: Value(serverRecord['decline_reason_id'] as String?),
            declineNotes: Value(serverRecord['decline_notes'] as String?),
            updatedAt: Value(DateTime.parse(serverRecord['updated_at'] as String)),
            deletedAt: serverRecord['deleted_at'] != null
                ? Value(DateTime.parse(serverRecord['deleted_at'] as String))
                : const Value(null),
            isPendingSync: const Value(false),
            lastSyncAt: Value(syncedAt),
          ));

    case 'activity':
      await (_database.update(_database.activities)
            ..where((a) => a.id.equals(entityId)))
          .write(db.ActivitiesCompanion(
            status: Value(serverRecord['status'] as String? ?? ''),
            notes: Value(serverRecord['notes'] as String?),
            latitude: Value((serverRecord['latitude'] as num?)?.toDouble()),
            longitude: Value((serverRecord['longitude'] as num?)?.toDouble()),
            checkInTime: serverRecord['check_in_time'] != null
                ? Value(DateTime.parse(serverRecord['check_in_time'] as String))
                : const Value(null),
            checkOutTime: serverRecord['check_out_time'] != null
                ? Value(DateTime.parse(serverRecord['check_out_time'] as String))
                : const Value(null),
            updatedAt: Value(DateTime.parse(serverRecord['updated_at'] as String)),
            deletedAt: serverRecord['deleted_at'] != null
                ? Value(DateTime.parse(serverRecord['deleted_at'] as String))
                : const Value(null),
            isPendingSync: const Value(false),
            lastSyncAt: Value(syncedAt),
          ));

    default:
      // Secondary entities (keyPerson, hvc, broker, cadence, pipelineReferral):
      // Full field-level LWW is not implemented here. The conflict is still
      // logged to sync_conflicts (by _resolveConflict above), and we mark the
      // local record as synced. The next pull cycle will apply the server's
      // authoritative data for these entity types.
      _log.warning('sync.push | Applying server data for $entityType/$entityId with basic sync metadata only');
      await _markEntityAsSynced(entityType, entityId);
  }
}
```

NOTE: The `default` case above handles entity types like keyPerson, hvc, broker, cadenceMeeting, pipelineReferral etc. by just marking them as synced. The three main entity types (customer, pipeline, activity) are the most likely to have real conflicts since they are the primary entities edited by sales reps. If a conflict occurs for other entity types, the server data will overwrite on next pull sync. This is a reasonable trade-off for this phase.

**Important behavioral notes:**
- The `_resolveConflict` method resolves the conflict internally and does NOT throw. The queue item is treated as successfully processed after LWW resolution. Only if the resolution itself fails (can't fetch server record, can't write back) does the error propagate up to the normal error handler.
- The `ConflictSyncError` from the PostgrestException 409 handler in `_processItem` is still useful for HTTP-level conflicts that happen outside the version guard flow (e.g., unique constraint violations). Leave that handler as-is.
- Add `import 'dart:convert';` if not already present in sync_queue_local_data_source.dart.
  </action>
  <verify>
- `flutter analyze` shows no new errors
- `_processItem` uses `.upsert(payload)` for creates (not `.insert(payload)`)
- `_processItem` extracts `_server_updated_at` from payload and uses `.eq('updated_at', serverUpdatedAt)` for updates
- `_resolveConflict` method exists, fetches server record, compares timestamps, logs conflict, applies winner
- `_applyServerDataLocally` handles customer, pipeline, activity entity types with full field-level resolution
- `_applyServerDataLocally` default case logs warning and marks synced for secondary entities (keyPerson, hvc, broker, cadence, pipelineReferral)
- `insertConflict` method exists in `SyncQueueLocalDataSource`
- `watchRecentConflictCount` method exists in `SyncQueueLocalDataSource`
  </verify>
  <done>SyncService._processItem uses upsert for creates and version guard for updates. Conflicts are detected via 0-row response, resolved via LWW timestamp comparison, logged to sync_conflicts table, and completed successfully. Server-wins conflicts update local DB with full field-level resolution for customer/pipeline/activity; secondary entities log the conflict and defer to next pull sync.</done>
</task>

</tasks>

<verification>
- `flutter analyze` passes with no new errors
- Schema version is 11 with sync_conflicts table migration
- `_processItem` create case uses `.upsert(payload)` (not `.insert(payload)`)
- `_processItem` update case extracts `_server_updated_at` and applies version guard
- `_resolveConflict` method exists and implements LWW (higher timestamp wins)
- Conflict audit logging writes to sync_conflicts table with both payloads
- Successfully resolved conflicts don't throw (item completes as successful)
</verification>

<success_criteria>
- SyncConflicts Drift table created at schema v11 with all required columns
- Create operations are idempotent via upsert
- Update operations include updatedAt version guard
- Conflict detected when version guard returns 0 rows
- LWW resolution compares updatedAt timestamps, higher wins
- All conflicts logged to sync_conflicts audit table with before/after snapshots
- Resolved conflicts complete successfully (not marked as failed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-conflict-resolution/04-01-SUMMARY.md`
</output>
