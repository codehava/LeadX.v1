---
phase: 04-conflict-resolution
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lib/data/repositories/customer_repository_impl.dart
  - lib/data/repositories/pipeline_repository_impl.dart
  - lib/data/repositories/activity_repository_impl.dart
  - lib/data/repositories/hvc_repository_impl.dart
  - lib/data/repositories/broker_repository_impl.dart
  - lib/data/repositories/cadence_repository_impl.dart
  - lib/data/repositories/pipeline_referral_repository_impl.dart
  - lib/data/services/sync_service.dart
  - lib/data/datasources/local/customer_local_data_source.dart
  - lib/data/datasources/local/pipeline_local_data_source.dart
  - lib/data/datasources/local/activity_local_data_source.dart
  - lib/data/datasources/local/key_person_local_data_source.dart
  - lib/data/datasources/local/hvc_local_data_source.dart
  - lib/data/datasources/local/broker_local_data_source.dart
  - lib/data/datasources/local/cadence_local_data_source.dart
  - lib/data/datasources/local/pipeline_referral_local_data_source.dart
  - lib/presentation/providers/sync_providers.dart
  - lib/presentation/screens/sync/sync_queue_screen.dart
autonomous: true

must_haves:
  truths:
    - "Update sync payloads include _server_updated_at metadata for the version guard"
    - "Coalesced update+update operations preserve the first _server_updated_at value"
    - "Pull sync does not overwrite local records that have isPendingSync=true"
    - "User can see count of recent conflicts in sync status UI"
  artifacts:
    - path: "lib/data/repositories/customer_repository_impl.dart"
      provides: "Version guard metadata in update sync payloads"
      contains: "_server_updated_at"
    - path: "lib/data/repositories/pipeline_repository_impl.dart"
      provides: "Version guard metadata in update sync payloads"
      contains: "_server_updated_at"
    - path: "lib/data/repositories/activity_repository_impl.dart"
      provides: "Version guard metadata in update sync payloads"
      contains: "_server_updated_at"
    - path: "lib/data/services/sync_service.dart"
      provides: "Coalescing logic preserves _server_updated_at for update+update"
      contains: "_server_updated_at"
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "Conflict count stream provider"
      contains: "conflictCountProvider"
  key_links:
    - from: "lib/data/repositories/customer_repository_impl.dart"
      to: "lib/data/services/sync_service.dart"
      via: "queueOperation payload with _server_updated_at"
      pattern: "_server_updated_at.*toUtcIso8601"
    - from: "lib/data/services/sync_service.dart"
      to: "_resolveConflict"
      via: "version guard extracts _server_updated_at from payload"
      pattern: "payload\\.remove\\('_server_updated_at'\\)"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "watchRecentConflictCount stream"
      pattern: "watchRecentConflictCount"
---

<objective>
Add version guard metadata to all repository update operations, update coalescing logic, add pull sync guard for pending records, and expose conflict count to UI.

Purpose: Without the `_server_updated_at` metadata, the version guard in SyncService (from plan 04-01) has nothing to compare against. Without the pull guard, server data could overwrite unsynced local edits. Without the UI provider, users cannot see conflict activity.
Output: All 27 update queue calls include version guard metadata. Coalescing preserves metadata correctly. Pull sync skips pending records. Conflict count visible in sync queue screen.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-conflict-resolution/04-RESEARCH.md
@.planning/phases/04-conflict-resolution/04-01-SUMMARY.md

@lib/data/repositories/customer_repository_impl.dart
@lib/data/repositories/pipeline_repository_impl.dart
@lib/data/repositories/activity_repository_impl.dart
@lib/data/services/sync_service.dart
@lib/presentation/providers/sync_providers.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _server_updated_at to all repository update queue calls and update coalescing</name>
  <files>lib/data/repositories/customer_repository_impl.dart, lib/data/repositories/pipeline_repository_impl.dart, lib/data/repositories/activity_repository_impl.dart, lib/data/repositories/hvc_repository_impl.dart, lib/data/repositories/broker_repository_impl.dart, lib/data/repositories/cadence_repository_impl.dart, lib/data/repositories/pipeline_referral_repository_impl.dart, lib/data/services/sync_service.dart</files>
  <action>
**Pattern for each repository update method:**

Every method that calls `_syncService.queueOperation(operation: SyncOperation.update, ...)` needs to:
1. Read the existing record's `updatedAt` BEFORE performing the local write (within the same transaction)
2. Add `'_server_updated_at': existingUpdatedAt.toUtcIso8601()` to the sync payload

The existing `updatedAt` represents the last-known server state because:
- For freshly-pulled records: `updatedAt` was set from the server during pull sync
- For previously-locally-edited records: `updatedAt` was set during the local edit, but the `_server_updated_at` captures the state BEFORE this edit

**Example transformation (customer_repository_impl.dart `updateCustomer`):**

BEFORE:
```dart
final updated = await _database.transaction(() async {
  await _localDataSource.updateCustomer(id, companion);
  final data = await _localDataSource.getCustomerById(id);
  if (data == null) return null;
  await _syncService.queueOperation(
    entityType: SyncEntityType.customer,
    entityId: id,
    operation: SyncOperation.update,
    payload: _createUpdateSyncPayload(data),
  );
  return data;
});
```

AFTER:
```dart
final updated = await _database.transaction(() async {
  // Read existing updatedAt BEFORE local write for version guard
  final existing = await _localDataSource.getCustomerById(id);
  final serverUpdatedAt = existing?.updatedAt;

  await _localDataSource.updateCustomer(id, companion);
  final data = await _localDataSource.getCustomerById(id);
  if (data == null) return null;
  await _syncService.queueOperation(
    entityType: SyncEntityType.customer,
    entityId: id,
    operation: SyncOperation.update,
    payload: {
      ..._createUpdateSyncPayload(data),
      if (serverUpdatedAt != null)
        '_server_updated_at': serverUpdatedAt.toUtcIso8601(),
    },
  );
  return data;
});
```

Apply this pattern to ALL 27 update queue calls across these 7 repositories:

1. **customer_repository_impl.dart** (2 calls):
   - `updateCustomer()` - read existing before writing companion
   - `updateKeyPerson()` - read existing key person before writing companion

2. **pipeline_repository_impl.dart** (3 calls):
   - `updatePipeline()` - read existing pipeline before writing
   - `updatePipelineStage()` - read existing pipeline before stage update
   - `closePipeline()` / any other update methods - read existing before writing

3. **activity_repository_impl.dart** (3 calls):
   - `completeActivity()` - read existing activity before completion write
   - `rescheduleActivity()` - read existing before reschedule write
   - Any other update methods - read existing before writing

4. **hvc_repository_impl.dart** (1 call):
   - `updateHvc()` - read existing before writing

5. **broker_repository_impl.dart** (1 call):
   - `updateBroker()` - read existing before writing

6. **cadence_repository_impl.dart** (12 calls):
   - All update operations - read existing record before each local write
   - Note: Many cadence methods update meetings/participants. For each, read the existing meeting or participant `updatedAt` before the local write.

7. **pipeline_referral_repository_impl.dart** (5 calls):
   - All update/status-change operations - read existing referral before writing

**Important:** For methods that already read the existing record before writing (e.g., to check not-found or validate), reuse that read. Do NOT add a redundant read.

**Coalescing update in `sync_service.dart` `queueOperation()`:**

Update the `('update', 'update')` coalescing case to preserve `_server_updated_at` from the FIRST update (the one being replaced). The first update's `_server_updated_at` represents the actual server state before any local edits began.

BEFORE:
```dart
case ('update', 'update'):
  await _syncQueueDataSource.removeOperation(entityType.name, entityId);
  return _syncQueueDataSource.addToQueue(
    entityType: entityType.name,
    entityId: entityId,
    operation: operation.name,
    payload: jsonEncode(payload),
  );
```

AFTER:
```dart
case ('update', 'update'):
  // Preserve _server_updated_at from FIRST update (true server state)
  final existingPayload = jsonDecode(existing.payload) as Map<String, dynamic>;
  final firstServerUpdatedAt = existingPayload['_server_updated_at'];
  if (firstServerUpdatedAt != null && !payload.containsKey('_server_updated_at')) {
    payload['_server_updated_at'] = firstServerUpdatedAt;
  } else if (firstServerUpdatedAt != null) {
    // Even if new payload has _server_updated_at, prefer the first one
    payload['_server_updated_at'] = firstServerUpdatedAt;
  }
  await _syncQueueDataSource.removeOperation(entityType.name, entityId);
  return _syncQueueDataSource.addToQueue(
    entityType: entityType.name,
    entityId: entityId,
    operation: operation.name,
    payload: jsonEncode(payload),
  );
```

Simplify the above to:
```dart
case ('update', 'update'):
  // Preserve _server_updated_at from FIRST update (true server state before edits)
  final existingPayload = jsonDecode(existing.payload) as Map<String, dynamic>;
  final firstServerUpdatedAt = existingPayload['_server_updated_at'];
  if (firstServerUpdatedAt != null) {
    payload['_server_updated_at'] = firstServerUpdatedAt;
  }
  await _syncQueueDataSource.removeOperation(entityType.name, entityId);
  _log.debug('sync.queue | Coalesced update+update for ${entityType.name}/$entityId');
  return _syncQueueDataSource.addToQueue(
    entityType: entityType.name,
    entityId: entityId,
    operation: operation.name,
    payload: jsonEncode(payload),
  );
```

For the `('create', 'update')` coalescing case: the `_server_updated_at` is IRRELEVANT since the record was just created locally and doesn't exist on the server yet. The upsert will handle it. But we should strip `_server_updated_at` from the payload to avoid confusion:
```dart
case ('create', 'update'):
  // Strip version guard metadata - irrelevant for creates (upsert handles it)
  payload.remove('_server_updated_at');
  await _syncQueueDataSource.updatePayload(existing.id, jsonEncode(payload));
  _log.debug('sync.queue | Coalesced create+update for ${entityType.name}/$entityId');
  return existing.id;
```
  </action>
  <verify>
- `flutter analyze` shows no new errors
- `grep -r "_server_updated_at" lib/data/repositories/ --include="*.dart"` returns matches in all 7 repository files
- `grep -c "_server_updated_at" lib/data/repositories/*_impl.dart` shows counts matching or exceeding the expected update call sites per repo
- Coalescing update+update case in `sync_service.dart` preserves `_server_updated_at` from existing payload
- Coalescing create+update case strips `_server_updated_at` from payload
  </verify>
  <done>All 27 update queueOperation calls include _server_updated_at metadata captured from the existing record's updatedAt before local write. Coalescing logic preserves first _server_updated_at for update+update and strips it for create+update.</done>
</task>

<task type="auto">
  <name>Task 2: Pull sync isPendingSync guard + conflict count provider + minimal UI</name>
  <files>lib/data/datasources/local/customer_local_data_source.dart, lib/data/datasources/local/pipeline_local_data_source.dart, lib/data/datasources/local/activity_local_data_source.dart, lib/data/datasources/local/key_person_local_data_source.dart, lib/data/datasources/local/hvc_local_data_source.dart, lib/data/datasources/local/broker_local_data_source.dart, lib/data/datasources/local/cadence_local_data_source.dart, lib/data/datasources/local/pipeline_referral_local_data_source.dart, lib/presentation/providers/sync_providers.dart, lib/presentation/screens/sync/sync_queue_screen.dart</files>
  <action>
**Part A: Pull sync isPendingSync guard**

The local data source upsert methods (used during pull sync) currently use `batch.insertAllOnConflictUpdate()` which blindly overwrites local records. Add a guard: before upserting pulled records, filter out records that have `isPendingSync=true` in the local DB.

The approach: Instead of modifying the batch upsert (which is hard to filter), add a pre-filter step in each upsert method.

For each local data source's upsert method (e.g., `upsertCustomers`, `upsertPipelines`, `upsertActivities`, `upsertKeyPersons`, and the pipeline_referral/hvc/broker/cadence equivalents), add a guard:

**Pattern:**
```dart
/// Upsert multiple customers from remote sync.
/// Skips records where local copy has isPendingSync=true (pending local changes).
Future<void> upsertCustomers(List<CustomersCompanion> customers) async {
  if (customers.isEmpty) return;

  // Get IDs of records with pending local changes
  final pendingIds = await (_db.selectOnly(_db.customers)
    ..addColumns([_db.customers.id])
    ..where(_db.customers.isPendingSync.equals(true)))
    .map((row) => row.read(_db.customers.id)!)
    .get();

  final pendingIdSet = pendingIds.toSet();

  // Filter out records that have pending local changes
  final safeToUpsert = customers.where((c) {
    final id = c.id.value;
    return !pendingIdSet.contains(id);
  }).toList();

  if (safeToUpsert.length < customers.length) {
    // Log skipped records for debugging
    final skipped = customers.length - safeToUpsert.length;
    // Use AppLogger if available, or just skip silently
  }

  if (safeToUpsert.isEmpty) return;

  await _db.batch((batch) {
    batch.insertAllOnConflictUpdate(_db.customers, safeToUpsert);
  });
}
```

Apply this pattern to these upsert methods:
1. `customer_local_data_source.dart` - `upsertCustomers()`
2. `pipeline_local_data_source.dart` - `upsertPipelines()`
3. `activity_local_data_source.dart` - `upsertActivities()`
4. `key_person_local_data_source.dart` - `upsertKeyPersons()`
5. `hvc_local_data_source.dart` - upsert methods for HVCs and CustomerHvcLinks
6. `broker_local_data_source.dart` - upsert method for brokers (if exists, check file)
7. `cadence_local_data_source.dart` - upsert methods for meetings/participants
8. `pipeline_referral_local_data_source.dart` - upsert method for referrals

NOTE: Not all local data sources have batch upsert methods. Some (like broker, cadence) may use individual `insertOnConflictUpdate`. For those, add the same guard: check if the record's ID has `isPendingSync=true` before upserting. If individual upserts, wrap with the check:
```dart
// Before individual upsert:
final hasPending = await (_db.select(_db.brokers)
  ..where((b) => b.id.equals(id) & b.isPendingSync.equals(true)))
  .getSingleOrNull();
if (hasPending != null) {
  // Skip - has pending local changes
  return;
}
```

For the batch pattern, import `AppLogger` if not already imported and log skipped count at debug level:
```dart
import '../../../core/logging/app_logger.dart';
// ... in method:
if (safeToUpsert.length < items.length) {
  AppLogger.instance.debug(
    'sync.pull | Skipped ${items.length - safeToUpsert.length} ${tableName} with pending local changes'
  );
}
```

**Part B: Conflict count provider**

In `lib/presentation/providers/sync_providers.dart`, add:

```dart
/// Provider for the count of recent sync conflicts (last 7 days).
/// Used by sync status UI to show conflict activity.
final conflictCountProvider = StreamProvider<int>((ref) {
  final syncQueueDataSource = ref.watch(syncQueueDataSourceProvider);
  return syncQueueDataSource.watchRecentConflictCount();
});
```

**Part C: Minimal conflict count display**

In `lib/presentation/screens/sync/sync_queue_screen.dart`, add the conflict count to the AppBar or as a header above the queue list.

In the `build` method, watch the `conflictCountProvider`:
```dart
final conflictCount = ref.watch(conflictCountProvider);
```

Add a small section at the top of the body (above the FutureBuilder) or in the AppBar subtitle area showing:
```dart
// In the AppBar, add a bottom or subtitle showing conflict count:
// Or add it as a small banner above the list:
conflictCount.when(
  data: (count) => count > 0
      ? Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          color: theme.colorScheme.tertiaryContainer,
          child: Row(
            children: [
              Icon(Icons.warning_amber, size: 16,
                  color: theme.colorScheme.onTertiaryContainer),
              const SizedBox(width: 8),
              Text(
                '$count conflict${count == 1 ? '' : 's'} detected in last 7 days',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onTertiaryContainer,
                ),
              ),
            ],
          ),
        )
      : const SizedBox.shrink(),
  loading: () => const SizedBox.shrink(),
  error: (_, __) => const SizedBox.shrink(),
)
```

Wrap the existing body in a `Column` if needed, with the conflict banner at top and the existing `FutureBuilder` below (in an `Expanded`).

Add the import for `sync_providers.dart` at the top if not already present (it likely is since `syncQueueDataSourceProvider` is used).
  </action>
  <verify>
- `flutter analyze` shows no new errors
- Customer upsert method filters out records with `isPendingSync=true` before batch insert
- Pipeline upsert method filters out records with `isPendingSync=true`
- Activity upsert method filters out records with `isPendingSync=true`
- `conflictCountProvider` exists in `sync_providers.dart`
- `sync_queue_screen.dart` displays conflict count from `conflictCountProvider`
- `flutter test` passes (existing tests should not break since the guard only affects records with isPendingSync=true, which pull sync data never has)
  </verify>
  <done>Pull sync upsert methods skip records with isPendingSync=true to prevent overwriting pending local changes. Conflict count StreamProvider exposed in sync_providers.dart. Sync queue screen shows conflict count banner when conflicts exist.</done>
</task>

</tasks>

<verification>
- `flutter analyze` passes with no new errors
- `flutter test` passes (all existing tests)
- All 7 repository impl files contain `_server_updated_at` in their update sync payloads
- Coalescing logic in `sync_service.dart` handles `_server_updated_at` correctly for both update+update and create+update cases
- Pull sync upsert methods filter out isPendingSync=true records
- `conflictCountProvider` exists and streams conflict count
- Sync queue screen displays conflict count
</verification>

<success_criteria>
- All 27 update queue calls include `_server_updated_at` metadata from the record's pre-edit updatedAt
- Update+update coalescing preserves the first `_server_updated_at` value
- Create+update coalescing strips `_server_updated_at` (irrelevant for upsert)
- Pull sync upsert methods skip records with `isPendingSync=true`
- Conflict count is visible in the sync queue screen when conflicts exist
- Full end-to-end: update queued with version guard -> SyncService extracts guard -> applies to Supabase update -> conflict detected if 0 rows -> LWW resolution -> conflict logged -> count visible in UI
</success_criteria>

<output>
After completion, create `.planning/phases/04-conflict-resolution/04-02-SUMMARY.md`
</output>
