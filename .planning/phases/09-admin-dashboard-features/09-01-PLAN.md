---
phase: 09-admin-dashboard-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/admin-delete-user/index.ts
  - lib/data/database/tables/users.dart
  - lib/data/database/app_database.dart
  - lib/data/database/app_database.g.dart
  - lib/domain/entities/user.dart
  - lib/domain/entities/user.freezed.dart
  - lib/domain/entities/user.g.dart
  - lib/data/datasources/remote/admin_user_remote_data_source.dart
  - lib/domain/repositories/admin_user_repository.dart
  - lib/data/repositories/admin_user_repository_impl.dart
  - lib/presentation/providers/admin_user_providers.dart
autonomous: true
requirements:
  - FEAT-06

must_haves:
  truths:
    - "Edge Function admin-delete-user accepts userId and newRmId, reassigns all business data, soft-deletes user, and bans auth account"
    - "Users table has deletedAt column in both Drift schema and domain entity"
    - "AdminUserRepository has deleteUser method callable from providers"
  artifacts:
    - path: "supabase/functions/admin-delete-user/index.ts"
      provides: "Server-side user deletion with cascading data reassignment"
      min_lines: 100
    - path: "lib/data/database/tables/users.dart"
      provides: "Users Drift table with deletedAt column"
      contains: "deletedAt"
    - path: "lib/domain/entities/user.dart"
      provides: "User entity with deletedAt field and isDeleted helper"
      contains: "deletedAt"
    - path: "lib/domain/repositories/admin_user_repository.dart"
      provides: "deleteUser method signature"
      contains: "deleteUser"
    - path: "lib/data/datasources/remote/admin_user_remote_data_source.dart"
      provides: "deleteUser remote call via Edge Function"
      contains: "admin-delete-user"
  key_links:
    - from: "lib/data/repositories/admin_user_repository_impl.dart"
      to: "lib/data/datasources/remote/admin_user_remote_data_source.dart"
      via: "deleteUser delegates to remote DS"
      pattern: "_remoteDataSource\\.deleteUser"
    - from: "lib/data/datasources/remote/admin_user_remote_data_source.dart"
      to: "supabase/functions/admin-delete-user/index.ts"
      via: "Edge Function invocation"
      pattern: "admin-delete-user"
    - from: "lib/presentation/providers/admin_user_providers.dart"
      to: "lib/data/repositories/admin_user_repository_impl.dart"
      via: "provider calls repository.deleteUser"
      pattern: "deleteUser"
---

<objective>
Build the backend infrastructure for admin user deletion: Edge Function for server-side data reassignment + soft-delete, Drift migration for deleted_at column, and the full data layer (remote DS, repository, provider) to call it from Flutter.

Purpose: FEAT-06 requires admin user deletion with cascading data reassignment. The Edge Function handles the atomic server-side operation (reassign business data to new RM, soft-delete user, ban auth account). The data layer provides the Flutter interface to invoke it.

Output: Deployable Edge Function, updated Drift schema v13, and complete data layer chain (remote DS -> repository -> provider) for deleteUser.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-admin-dashboard-features/09-CONTEXT.md
@.planning/phases/09-admin-dashboard-features/09-RESEARCH.md
@supabase/functions/admin-create-user/index.ts
@lib/data/datasources/remote/admin_user_remote_data_source.dart
@lib/domain/repositories/admin_user_repository.dart
@lib/data/repositories/admin_user_repository_impl.dart
@lib/presentation/providers/admin_user_providers.dart
@lib/data/database/tables/users.dart
@lib/data/database/app_database.dart
@lib/domain/entities/user.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin-delete-user Edge Function and update Drift schema</name>
  <files>
    supabase/functions/admin-delete-user/index.ts
    lib/data/database/tables/users.dart
    lib/data/database/app_database.dart
    lib/domain/entities/user.dart
  </files>
  <action>
**Edge Function (`supabase/functions/admin-delete-user/index.ts`):**

Create a new Edge Function following the exact boilerplate pattern of `admin-create-user/index.ts`:
- Same CORS headers, same JWT verification via `adminClient.auth.getUser(token)`, same ADMIN/SUPERADMIN role check from users table.
- Interface: `{ userId: string, newRmId: string }`
- Validate required fields (userId, newRmId).
- **Self-delete guard:** Check `userId !== callerUser.id`, return 400 if true with message "Cannot delete yourself".
- **Validate target exists:** Query users table for target user, return 404 if not found.
- **Validate newRm exists:** Query users table for newRmId, return 404 if not found or inactive.

**Reassignment steps (in order per CONTEXT.md locked decisions):**

1. Get deleted user's `parent_id` for subordinate reassignment.
2. **Reassign subordinates:** `UPDATE users SET parent_id = targetUser.parent_id, updated_at = now WHERE parent_id = targetUserId` (moves children to deleted user's parent).
3. **Transfer customers:** `UPDATE customers SET assigned_rm_id = newRmId, updated_at = now WHERE assigned_rm_id = targetUserId AND deleted_at IS NULL` (keep `created_by` intact per audit trail decision).
4. **Transfer pipelines:** `UPDATE pipelines SET assigned_rm_id = newRmId, scored_to_user_id = newRmId, updated_at = now WHERE assigned_rm_id = targetUserId AND deleted_at IS NULL`. Also: `UPDATE pipelines SET scored_to_user_id = newRmId, updated_at = now WHERE scored_to_user_id = targetUserId AND deleted_at IS NULL` (separate query for records where only scored_to is the deleted user). Keep `created_by` and `referred_by_user_id` intact.
5. **Transfer activities:** `UPDATE activities SET user_id = newRmId, updated_at = now WHERE user_id = targetUserId AND deleted_at IS NULL` (keep `created_by` intact).
6. **Transfer HVCs:** `UPDATE hvcs SET created_by = newRmId, updated_at = now WHERE created_by = targetUserId AND deleted_at IS NULL` (HVCs use `created_by` as ownership field).
7. **Transfer Brokers:** `UPDATE brokers SET created_by = newRmId, updated_at = now WHERE created_by = targetUserId AND deleted_at IS NULL` (Brokers use `created_by` as ownership field).
8. **Transfer pipeline referrals:** `UPDATE pipeline_referrals SET referrer_rm_id = newRmId, updated_at = now WHERE referrer_rm_id = targetUserId`. Also: `UPDATE pipeline_referrals SET receiver_rm_id = newRmId, updated_at = now WHERE receiver_rm_id = targetUserId`.
9. **Soft-delete user:** `UPDATE users SET is_active = false, deleted_at = now, updated_at = now WHERE id = targetUserId`.
10. **Ban auth account:** `await adminClient.auth.admin.updateUserById(targetUserId, { ban_duration: '87600h' })` (10 years).

Use `const now = new Date().toISOString()` for all timestamps. Each UPDATE is a separate Supabase call. If any fails, return 500 error with the step that failed. The soft-delete is intentionally LAST so partial failures leave the user active (admin can retry since reassignment is idempotent).

Return `{ success: true, message: 'User deleted and data reassigned' }` with status 200.

Per Claude's discretion: user_targets and user_scores are NOT deleted or modified -- historical scoring data is preserved. The user's `deleted_at` flag on the users table is sufficient for future scoring queries to exclude them.

**Drift migration (`lib/data/database/tables/users.dart`):**

Add `DateTimeColumn get deletedAt => dateTime().nullable()();` to the Users class, after `updatedAt` and before `lastSyncAt`.

**Drift migration (`lib/data/database/app_database.dart`):**

Increment `schemaVersion` from 12 to 13. Add migration step:
```dart
if (from < 13) {
  await m.addColumn(users, users.deletedAt);
}
```

**User entity (`lib/domain/entities/user.dart`):**

Add `DateTime? deletedAt` field to the User Freezed class. Add computed property:
```dart
bool get isDeleted => deletedAt != null;
```

After editing, run `dart run build_runner build --delete-conflicting-outputs` to regenerate `.g.dart` and `.freezed.dart` files.
  </action>
  <verify>
1. `supabase/functions/admin-delete-user/index.ts` exists and follows the admin-create-user pattern structure.
2. `lib/data/database/tables/users.dart` contains `deletedAt` column definition.
3. `lib/data/database/app_database.dart` has `schemaVersion => 13` and migration for `from < 13`.
4. `lib/domain/entities/user.dart` contains `deletedAt` field and `isDeleted` getter.
5. `dart run build_runner build --delete-conflicting-outputs` completes without errors.
6. `flutter analyze` passes (or only has pre-existing warnings unrelated to these changes).
  </verify>
  <done>
Edge Function admin-delete-user is ready for deployment with full data reassignment cascade matching CONTEXT.md decisions. Drift schema is at v13 with deletedAt column. User entity has deletedAt field and isDeleted helper. Build_runner generated files are up to date.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire data layer -- remote data source, repository, and provider for deleteUser</name>
  <files>
    lib/data/datasources/remote/admin_user_remote_data_source.dart
    lib/domain/repositories/admin_user_repository.dart
    lib/data/repositories/admin_user_repository_impl.dart
    lib/presentation/providers/admin_user_providers.dart
  </files>
  <action>
**Remote data source (`admin_user_remote_data_source.dart`):**

Add a `deleteUser` method following the existing `createUser` and `generateTemporaryPassword` patterns:
```dart
/// Delete a user and reassign their data to a new RM.
/// Uses Edge Function for server-side cascade deletion.
Future<void> deleteUser(String userId, String newRmId) async {
  final response = await _client.functions.invoke(
    'admin-delete-user',
    body: {
      'userId': userId,
      'newRmId': newRmId,
    },
  );

  if (response.status != 200) {
    final error = response.data['error'] ?? 'Unknown error';
    throw Exception('Failed to delete user: $error');
  }
}
```

Also update `fetchAllUsers` to filter out deleted users by default. Add an `includeDeleted` parameter:
```dart
Future<List<Map<String, dynamic>>> fetchAllUsers({
  bool includeInactive = false,
  bool includeDeleted = false,
}) async {
  var query = _client.from('users').select();

  if (!includeInactive) {
    query = query.eq('is_active', true);
  }

  if (!includeDeleted) {
    query = query.is_('deleted_at', null);
  }

  final result = await query.order('name');
  return List<Map<String, dynamic>>.from(result);
}
```

**Repository interface (`admin_user_repository.dart`):**

Add method signature:
```dart
/// Delete a user and reassign all business data to [newRmId].
/// Online-only operation via Edge Function.
Future<Result<void>> deleteUser(String userId, String newRmId);
```

**Repository implementation (`admin_user_repository_impl.dart`):**

Add implementation using `runCatching` (matching existing pattern for simple remote-only operations):
```dart
@override
Future<Result<void>> deleteUser(
  String userId, String newRmId,
) => runCatching(() async {
  await _remoteDataSource.deleteUser(userId, newRmId);
}, context: 'deleteUser');
```

**Providers (`admin_user_providers.dart`):**

Add `deleteUser` method to `AdminUserNotifier` (or the existing notifier handling admin user operations). Follow the existing pattern used by `createUser`:
```dart
Future<void> deleteUser(String userId, String newRmId) async {
  final repository = ref.read(adminUserRepositoryProvider);
  final result = await repository.deleteUser(userId, newRmId);

  switch (result) {
    case Success():
      ref.invalidate(allUsersProvider);
    case ResultFailure(:final failure):
      throw Exception(failure.message);
  }
}
```

This invalidates the users list after deletion so the UI reflects the change.
  </action>
  <verify>
1. `flutter analyze` passes.
2. Grep confirms: `admin_user_remote_data_source.dart` contains `deleteUser` method and `admin-delete-user` string.
3. Grep confirms: `admin_user_repository.dart` interface contains `deleteUser` signature.
4. Grep confirms: `admin_user_repository_impl.dart` contains `deleteUser` implementation with `runCatching`.
5. Grep confirms: `admin_user_providers.dart` contains `deleteUser` method with `ref.invalidate(allUsersProvider)`.
  </verify>
  <done>
Complete data layer chain exists: AdminUserRemoteDataSource.deleteUser -> AdminUserRepository.deleteUser -> AdminUserNotifier.deleteUser. The allUsersProvider is invalidated after deletion. fetchAllUsers now filters deleted users by default.
  </done>
</task>

</tasks>

<verification>
1. Edge Function file exists at `supabase/functions/admin-delete-user/index.ts` with correct reassignment sequence.
2. Drift schema version is 13 with deletedAt migration.
3. User entity has deletedAt field and isDeleted computed property.
4. Full data layer chain: remote DS -> repository -> provider is wired for deleteUser.
5. `flutter analyze` passes.
6. `dart run build_runner build --delete-conflicting-outputs` succeeds.
</verification>

<success_criteria>
- Edge Function implements all 10 reassignment/deletion steps per CONTEXT.md locked decisions
- Self-delete is blocked (userId !== callerUser.id check)
- Subordinates reassigned to deleted user's parent before soft-delete
- Users table has deletedAt column (Drift v13)
- User entity has deletedAt field and isDeleted helper
- Data layer chain (remote DS + repo + provider) complete for deleteUser
- allUsersProvider is invalidated after successful deletion
- fetchAllUsers filters deleted_at IS NULL by default
- All code compiles and passes analysis
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-dashboard-features/09-01-SUMMARY.md`
</output>
