---
phase: 03-error-classification-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/core/errors/result.dart
  - lib/core/errors/exception_mapper.dart
  - lib/domain/repositories/customer_repository.dart
  - lib/data/repositories/customer_repository_impl.dart
  - lib/presentation/providers/customer_providers.dart
  - test/data/repositories/customer_repository_impl_test.dart
  - test/data/repositories/customer_repository_impl_test.mocks.dart
autonomous: true

must_haves:
  truths:
    - "Sealed Result<T> type exists with Success and Failure_ variants supporting exhaustive switch"
    - "mapException() maps SocketException to NetworkFailure, TimeoutException to NetworkFailure, PostgrestException 401 to AuthFailure, generic to UnexpectedFailure"
    - "runCatching() convenience wrapper returns Result.failure on any exception"
    - "CustomerRepository interface uses Result<T> instead of Either<Failure, T> for all 8 mutating methods"
    - "CustomerRepositoryImpl catch blocks use mapException() instead of generic DatabaseFailure"
    - "Customer provider notifiers use switch/when pattern matching instead of .fold()"
    - "Customer repository tests pass with updated Result assertions"
  artifacts:
    - path: "lib/core/errors/result.dart"
      provides: "Sealed Result<T> type with Success/Failure_ variants"
      contains: "sealed class Result"
    - path: "lib/core/errors/exception_mapper.dart"
      provides: "Exception-to-Failure mapping utility"
      contains: "mapException"
    - path: "lib/domain/repositories/customer_repository.dart"
      provides: "CustomerRepository interface with Result<T> return types"
      contains: "Result<Customer>"
    - path: "lib/presentation/providers/customer_providers.dart"
      provides: "Customer notifiers using Result pattern matching"
      contains: "case Success"
  key_links:
    - from: "lib/core/errors/exception_mapper.dart"
      to: "lib/core/errors/result.dart"
      via: "runCatching returns Result<T>"
      pattern: "Result\\.failure\\(mapException"
    - from: "lib/data/repositories/customer_repository_impl.dart"
      to: "lib/core/errors/exception_mapper.dart"
      via: "Repository catch blocks use mapException/runCatching"
      pattern: "runCatching|mapException"
    - from: "lib/presentation/providers/customer_providers.dart"
      to: "lib/core/errors/result.dart"
      via: "Notifiers pattern-match on Result"
      pattern: "case Success|case Failure_"
---

<objective>
Create the sealed Result<T> type and exception mapping utility, then migrate CustomerRepository as the first repository to use typed error handling end-to-end (interface -> implementation -> providers -> tests).

Purpose: Establishes the foundation error types that all subsequent repository migrations will use, and proves the migration pattern works end-to-end on the most-used repository.
Output: result.dart, exception_mapper.dart, fully migrated CustomerRepository with typed errors, passing tests.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-classification-recovery/03-RESEARCH.md

@lib/core/errors/failures.dart
@lib/core/errors/exceptions.dart
@lib/domain/repositories/customer_repository.dart
@lib/data/repositories/customer_repository_impl.dart
@lib/presentation/providers/customer_providers.dart
@test/data/repositories/customer_repository_impl_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sealed Result type and exception mapper</name>
  <files>
    lib/core/errors/result.dart
    lib/core/errors/exception_mapper.dart
  </files>
  <action>
Create `lib/core/errors/result.dart` with a minimal sealed Result<T> type:
- `sealed class Result<T>` with two final subclasses: `Success<T>` (holds `T value`) and `Failure_<T>` (holds `Failure failure`)
- Named constructors: `Result.success(T value)` and `Result.failure(Failure failure)`
- `.when()` method for callback-style matching (mirrors dartz .fold() ergonomics)
- Convenience getters: `valueOrNull`, `failureOrNull`, `isSuccess`, `isFailure`
- Import `failures.dart` for the Failure type
- Add an `Either<Failure, T>.toResult()` extension on dartz Either to ease incremental migration (import dartz). This adapter lets code consuming mixed Result/Either repositories convert uniformly. Remove it when all repos are migrated.

Create `lib/core/errors/exception_mapper.dart` with:
- `Failure mapException(Object error, {String? context})` function using Dart 3 switch expression:
  - `SocketException` -> `NetworkFailure(message: 'Check your connection and try again.')`
  - `TimeoutException` -> `NetworkFailure(message: 'Check your connection and try again.')`
  - `PostgrestException` with code parsing: 401/PGRST301 -> `AuthFailure`, 403 -> `ForbiddenFailure`, 404 -> `NotFoundFailure`, 409 -> `SyncConflictFailure`, 400-499 -> `ValidationFailure`, 500+ -> `ServerFailure`
  - `AuthException` -> `AuthFailure(message: 'Session expired. Please login again.')`
  - `FormatException` -> `DatabaseFailure`
  - Fallback `_` -> `UnexpectedFailure`
- `Future<Result<T>> runCatching<T>(Future<T> Function() action, {String? context})` convenience wrapper that try/catches and maps via mapException

Imports needed: `dart:async`, `dart:io`, `package:supabase_flutter/supabase_flutter.dart`, local `failures.dart`, local `result.dart`.

Note: `SocketException` requires `dart:io` which is not available on web. Guard the import with a conditional import or handle `SocketException` inside a try-catch within mapException. Actually, since `SocketException` is in `dart:io` and the app already imports `dart:io` elsewhere, just import it directly. On web builds, `SocketException` will never be thrown (web uses `XMLHttpRequest` errors), so the pattern match branch simply won't match. No conditional import needed.
  </action>
  <verify>
Run `flutter analyze lib/core/errors/result.dart lib/core/errors/exception_mapper.dart` -- no errors or warnings.
Verify `sealed class Result<T>` exists and has exactly 2 subclasses.
Verify `mapException` handles at least 6 exception types.
Verify `runCatching` returns `Result<T>`.
  </verify>
  <done>
result.dart contains sealed Result<T> with Success/Failure_ variants, .when() method, convenience getters, and Either.toResult() adapter.
exception_mapper.dart contains mapException() with typed mapping for Socket/Timeout/Postgrest/Auth/Format exceptions, and runCatching() wrapper.
Both files pass flutter analyze with no issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate CustomerRepository to Result type end-to-end</name>
  <files>
    lib/domain/repositories/customer_repository.dart
    lib/data/repositories/customer_repository_impl.dart
    lib/presentation/providers/customer_providers.dart
    test/data/repositories/customer_repository_impl_test.dart
    test/data/repositories/customer_repository_impl_test.mocks.dart
  </files>
  <action>
**Interface (customer_repository.dart):**
- Replace `import 'package:dartz/dartz.dart'` with `import '../../core/errors/result.dart'`
- Change all 8 `Either<Failure, T>` return types to `Result<T>`:
  - `createCustomer` -> `Future<Result<Customer>>`
  - `updateCustomer` -> `Future<Result<Customer>>`
  - `deleteCustomer` -> `Future<Result<void>>`
  - `addKeyPerson` -> `Future<Result<KeyPerson>>`
  - `updateKeyPerson` -> `Future<Result<KeyPerson>>`
  - `deleteKeyPerson` -> `Future<Result<void>>`
  - `syncFromRemote` -> `Future<Result<int>>`
  - `syncKeyPersonsFromRemote` -> `Future<Result<int>>`
- Keep all stream/get/search methods unchanged (they read from Drift, no Either needed)

**Implementation (customer_repository_impl.dart):**
- Replace `import 'package:dartz/dartz.dart'` with `import '../../core/errors/result.dart'` and `import '../../core/errors/exception_mapper.dart'`
- For each of the 8 methods:
  - Replace `return Right(value)` with `return Result.success(value)`
  - Replace `return Left(DatabaseFailure(message: '...'))` with `return Result.failure(mapException(e, context: '...'))`
  - For simple CRUD methods (createCustomer, updateCustomer, deleteCustomer, addKeyPerson, updateKeyPerson, deleteKeyPerson): refactor to use `runCatching()` wrapping the entire method body
  - For sync methods (syncFromRemote, syncKeyPersonsFromRemote): use explicit try/catch + mapException since they have logging/complex logic
- Remove all `Left(DatabaseFailure(message: 'Failed to X: $e'))` generic catches -- these become typed via mapException
- Remove `Left(NotFoundFailure())` patterns -- use `Result.failure(const NotFoundFailure())` instead

**Providers (customer_providers.dart):**
- Replace `import 'package:dartz/dartz.dart'` with `import '../../core/errors/result.dart'`
- For each .fold() call site (5 sites), replace with switch expression or .when():
  - Old: `result.fold((failure) => ..., (value) => ...)`
  - New: `switch (result) { case Success(:final value): ... case Failure_(:final failure): ... }`
  - OR: `result.when(success: (value) => ..., failure: (failure) => ...)`
- Use whichever pattern is cleaner for each site (switch for multi-statement, .when() for single-expression)

**Tests (customer_repository_impl_test.dart):**
- Replace `import 'package:dartz/dartz.dart'` with `import 'package:leadx/core/errors/result.dart'`
- Update all assertions:
  - `isA<Right<Failure, Customer>>()` -> `isA<Success<Customer>>()`
  - `isA<Left<Failure, Customer>>()` -> `isA<Failure_<Customer>>()`
  - `result.getOrElse(() => ...)` -> `result.valueOrNull` or `(result as Success).value`
  - Any `.fold()` usage in test verification -> switch/when
- Run `dart run build_runner build --delete-conflicting-outputs` to regenerate mock files if interface changes affect mocks
- Run `flutter test test/data/repositories/customer_repository_impl_test.dart` to verify all tests pass

**Important:**
- Do NOT use `runCatching` for methods that need to return different failure types for different conditions (e.g., NotFoundFailure for missing entity vs DatabaseFailure for DB error). In those cases, use explicit try/catch with mapException for the outer catch, and construct specific failures inline.
- The `deleteCustomer` method currently checks existence first and returns `NotFoundFailure` -- preserve this pattern inside runCatching by throwing from the inner function and letting mapException handle unexpected errors, or use explicit try/catch.
  </action>
  <verify>
Run `flutter analyze lib/domain/repositories/customer_repository.dart lib/data/repositories/customer_repository_impl.dart lib/presentation/providers/customer_providers.dart` -- no errors.
Run `flutter test test/data/repositories/customer_repository_impl_test.dart` -- all tests pass.
Grep for `dartz` in all 4 modified lib files -- should return 0 matches.
Grep for `Either<Failure` in customer_repository.dart -- should return 0 matches.
Grep for `\.fold\(` in customer_providers.dart -- should return 0 matches.
  </verify>
  <done>
CustomerRepository interface has 8 methods returning Result<T> instead of Either<Failure, T>.
CustomerRepositoryImpl uses mapException()/runCatching() for typed error classification.
Customer providers use switch/when pattern matching instead of .fold().
All customer repository tests pass with updated Result assertions.
No dartz imports remain in any customer-related file.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes for all modified files with no errors
2. `flutter test test/data/repositories/customer_repository_impl_test.dart` passes all tests
3. No `Either<Failure` references exist in customer_repository.dart
4. No `.fold()` references exist in customer_providers.dart
5. No `dartz` imports in any of the 5 modified lib files
6. `mapException` correctly maps at least: SocketException->NetworkFailure, TimeoutException->NetworkFailure, PostgrestException(401)->AuthFailure, AuthException->AuthFailure
7. `runCatching` is used in at least 3 customer repository CRUD methods
</verification>

<success_criteria>
- Sealed Result<T> type with exhaustive pattern matching works in all consumer code
- CustomerRepository is fully migrated from dartz Either to sealed Result
- Exception mapper centralizes error classification (no more generic DatabaseFailure catches)
- All existing tests pass with Result-based assertions
- Foundation is ready for Plan 02 (Pipeline + Activity migration) and Plan 03 (screen updates)
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-classification-recovery/03-01-SUMMARY.md`
</output>
