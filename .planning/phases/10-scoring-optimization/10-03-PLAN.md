---
phase: 10-scoring-optimization
plan: 03
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - lib/presentation/screens/admin/4dx/scoring_summary_screen.dart
  - lib/presentation/providers/admin/admin_scoring_summary_providers.dart
  - lib/presentation/providers/admin/admin_scoring_summary_providers.g.dart
  - lib/data/datasources/remote/scoreboard_remote_data_source.dart
  - lib/config/routes/app_router.dart
  - lib/config/routes/route_names.dart
  - lib/presentation/screens/admin/4dx/admin_4dx_home_screen.dart
autonomous: true
requirements: [SCORE-01, SCORE-02]

must_haves:
  truths:
    - "Admin can view a users x measures grid showing actual/target/% per cell with composite score at end"
    - "Managers (BH/BM/ROH) see grid filtered to their subordinates only"
    - "Grid is period-aware with a period selector"
    - "Scoring summary screen is navigable from admin 4DX home screen"
  artifacts:
    - path: "lib/presentation/screens/admin/4dx/scoring_summary_screen.dart"
      provides: "Scoring summary grid screen with users as rows and measures as columns"
      min_lines: 100
    - path: "lib/presentation/providers/admin/admin_scoring_summary_providers.dart"
      provides: "Provider that fetches cross-user scoring data for grid display"
      contains: "scoringSummary"
    - path: "lib/config/routes/app_router.dart"
      provides: "Route for scoring summary screen"
      contains: "scoringSummary"
  key_links:
    - from: "lib/presentation/screens/admin/4dx/scoring_summary_screen.dart"
      to: "lib/presentation/providers/admin/admin_scoring_summary_providers.dart"
      via: "ref.watch(scoringSummaryProvider)"
      pattern: "scoringSummary"
    - from: "lib/config/routes/app_router.dart"
      to: "lib/presentation/screens/admin/4dx/scoring_summary_screen.dart"
      via: "GoRoute path: 'scoring-summary'"
      pattern: "scoring.*summary"
---

<objective>
Build the scoring summary grid screen for admins and managers showing users as rows, measures as columns, with actual/target/% per cell and composite score.

Purpose: Per locked decision, admins see all users and managers see their subordinates. This gives visibility into team scoring performance at a glance.

Output: New screen + providers + route registration
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-scoring-optimization/10-CONTEXT.md
@.planning/phases/10-scoring-optimization/10-RESEARCH.md
@.planning/phases/10-scoring-optimization/10-01-SUMMARY.md
@lib/presentation/screens/admin/4dx/admin_4dx_home_screen.dart
@lib/config/routes/app_router.dart
@lib/config/routes/route_names.dart
@lib/data/datasources/remote/scoreboard_remote_data_source.dart
@lib/presentation/providers/scoreboard_providers.dart
@lib/domain/entities/scoring_entities.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scoring summary data models and provider</name>
  <files>
    lib/presentation/providers/admin/admin_scoring_summary_providers.dart
    lib/presentation/providers/admin/admin_scoring_summary_providers.g.dart
    lib/data/datasources/remote/scoreboard_remote_data_source.dart
  </files>
  <action>
**In `scoreboard_remote_data_source.dart`:**

Add a new method to fetch scoring summary data for the grid:
```dart
/// Fetch scoring summary data for all users (admin) or subordinates (manager).
/// Returns a cross-join of users, measures, and their scores for a given period.
Future<List<Map<String, dynamic>>> fetchScoringSummaryData(
  String periodId, {
  String? supervisorUserId, // If non-null, filter to subordinates only
}) async {
  // Strategy: Fetch user_scores with user and measure joins for the period
  // Admin gets all users; manager gets subordinates via user_hierarchy

  // Step 1: Get all active measure definitions (columns for the grid)
  final measures = await fetchMeasureDefinitions();

  // Step 2: Get user_score_aggregates for the period (for composite scores)
  dynamic aggregateQuery = _supabase
      .from('user_score_aggregates')
      .select('*, users!inner(id, name, role, branch_id, is_active, branches(name))')
      .eq('period_id', periodId)
      .eq('users.is_active', true);

  if (supervisorUserId != null) {
    // Filter to subordinates only (manager view)
    // Use user_hierarchy to find descendants
    final hierarchyResponse = await _supabase
        .from('user_hierarchy')
        .select('descendant_id')
        .eq('ancestor_id', supervisorUserId)
        .gt('depth', 0);

    final subordinateIds = (hierarchyResponse as List)
        .map((h) => (h as Map<String, dynamic>)['descendant_id'] as String)
        .toList();

    if (subordinateIds.isEmpty) return [];

    aggregateQuery = aggregateQuery.inFilter('user_id', subordinateIds);
  }

  final aggregates = await aggregateQuery;

  // Step 3: Get all user_scores for the period with measure info
  final userIds = (aggregates as List)
      .map((a) => (a as Map<String, dynamic>)['user_id'] as String)
      .toList();

  if (userIds.isEmpty) return [];

  final scoresResponse = await _supabase
      .from('user_scores')
      .select('user_id, measure_id, actual_value, percentage, score')
      .eq('period_id', periodId)  // Note: this matches the display period
      .inFilter('user_id', userIds);

  // For multi-period: also fetch scores from other current periods
  final allCurrentPeriods = await fetchAllCurrentPeriods();
  final otherPeriodIds = allCurrentPeriods
      .where((p) => p.id != periodId)
      .map((p) => p.id)
      .toList();

  List<dynamic> additionalScores = [];
  if (otherPeriodIds.isNotEmpty) {
    additionalScores = await _supabase
        .from('user_scores')
        .select('user_id, measure_id, actual_value, percentage, score')
        .inFilter('period_id', otherPeriodIds)
        .inFilter('user_id', userIds);
  }

  // Combine all scores
  final allScores = [...(scoresResponse as List), ...additionalScores];

  // Step 4: Build the grid data structure
  // Each row: { user info, measures: { measureId: { actual, target, % } }, composite }
  final List<Map<String, dynamic>> rows = [];

  for (final aggregate in aggregates) {
    final agg = aggregate as Map<String, dynamic>;
    final userId = agg['user_id'] as String;
    final user = agg['users'] as Map<String, dynamic>;
    final branch = user['branches'] as Map<String, dynamic>?;

    // Build measure cells for this user
    final measureCells = <String, Map<String, dynamic>>{};
    for (final score in allScores) {
      final s = score as Map<String, dynamic>;
      if (s['user_id'] == userId) {
        measureCells[s['measure_id'] as String] = {
          'actual_value': (s['actual_value'] as num?)?.toDouble() ?? 0,
          'percentage': (s['percentage'] as num?)?.toDouble() ?? 0,
          'score': (s['score'] as num?)?.toDouble() ?? 0,
        };
      }
    }

    rows.add({
      'user_id': userId,
      'user_name': user['name'] as String? ?? 'Unknown',
      'role': user['role'] as String? ?? '',
      'branch_name': branch?['name'] as String?,
      'total_score': (agg['total_score'] as num?)?.toDouble() ?? 0,
      'lead_score': (agg['lead_score'] as num?)?.toDouble() ?? 0,
      'lag_score': (agg['lag_score'] as num?)?.toDouble() ?? 0,
      'rank': agg['rank'] as int?,
      'measure_cells': measureCells,
    });
  }

  // Sort by rank (nulls last), then by total_score descending
  rows.sort((a, b) {
    final rankA = a['rank'] as int? ?? 9999;
    final rankB = b['rank'] as int? ?? 9999;
    if (rankA != rankB) return rankA.compareTo(rankB);
    return ((b['total_score'] as double) - (a['total_score'] as double)).sign.toInt();
  });

  return rows;
}
```

Note: This method does multiple queries. An alternative would be a single RPC, but for now the multi-query approach is simpler and avoids another SQL migration. If performance is an issue, a follow-up can create an RPC.

**Create `lib/presentation/providers/admin/admin_scoring_summary_providers.dart`:**

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../domain/entities/scoring_entities.dart';
import '../scoreboard_providers.dart';
import '../auth_providers.dart';

part 'admin_scoring_summary_providers.g.dart';

/// Data model for a scoring summary row (one per user).
class ScoringSummaryRow {
  final String userId;
  final String userName;
  final String role;
  final String? branchName;
  final double totalScore;
  final double leadScore;
  final double lagScore;
  final int? rank;
  final Map<String, ScoringSummaryCell> measureCells;

  const ScoringSummaryRow({
    required this.userId,
    required this.userName,
    required this.role,
    this.branchName,
    required this.totalScore,
    required this.leadScore,
    required this.lagScore,
    this.rank,
    required this.measureCells,
  });
}

/// Data for a single cell in the scoring summary grid.
class ScoringSummaryCell {
  final double actualValue;
  final double percentage;
  final double score;

  const ScoringSummaryCell({
    required this.actualValue,
    required this.percentage,
    required this.score,
  });
}

/// State for the scoring summary screen.
class ScoringSummaryState {
  final List<ScoringSummaryRow> rows;
  final List<MeasureDefinition> measures;
  final ScoringPeriod? selectedPeriod;
  final bool isLoading;
  final String? error;

  const ScoringSummaryState({
    this.rows = const [],
    this.measures = const [],
    this.selectedPeriod,
    this.isLoading = false,
    this.error,
  });
}

/// Provider for scoring summary grid data.
@riverpod
class ScoringSummaryNotifier extends _$ScoringSummaryNotifier {
  @override
  Future<ScoringSummaryState> build() async {
    final remoteDS = ref.watch(scoreboardRemoteDataSourceProvider);
    final currentUser = await ref.watch(currentUserProvider.future);

    if (currentUser == null) {
      return const ScoringSummaryState(error: 'User not found');
    }

    try {
      // Get measures for columns
      final measures = await remoteDS.fetchMeasureDefinitions();

      // Get current period
      final currentPeriod = await remoteDS.fetchCurrentPeriod();
      if (currentPeriod == null) {
        return ScoringSummaryState(
          measures: measures,
          error: 'Tidak ada periode aktif',
        );
      }

      // Determine if user is admin or manager
      final isAdmin = currentUser.isAdmin;
      final supervisorId = isAdmin ? null : currentUser.id;

      // Fetch grid data
      final rawData = await remoteDS.fetchScoringSummaryData(
        currentPeriod.id,
        supervisorUserId: supervisorId,
      );

      // Map to ScoringSummaryRow
      final rows = rawData.map((row) {
        final measureCellsRaw = row['measure_cells'] as Map<String, Map<String, dynamic>>;
        final measureCells = measureCellsRaw.map((measureId, cell) {
          return MapEntry(measureId, ScoringSummaryCell(
            actualValue: cell['actual_value'] as double,
            percentage: cell['percentage'] as double,
            score: cell['score'] as double,
          ));
        });

        return ScoringSummaryRow(
          userId: row['user_id'] as String,
          userName: row['user_name'] as String,
          role: row['role'] as String,
          branchName: row['branch_name'] as String?,
          totalScore: row['total_score'] as double,
          leadScore: row['lead_score'] as double,
          lagScore: row['lag_score'] as double,
          rank: row['rank'] as int?,
          measureCells: measureCells,
        );
      }).toList();

      return ScoringSummaryState(
        rows: rows,
        measures: measures,
        selectedPeriod: currentPeriod,
      );
    } catch (e) {
      return ScoringSummaryState(error: e.toString());
    }
  }

  /// Change selected period and reload data.
  Future<void> selectPeriod(ScoringPeriod period) async {
    // Trigger rebuild with new period
    ref.invalidateSelf();
  }

  /// Refresh data.
  Future<void> refresh() async {
    ref.invalidateSelf();
  }
}
```

Run `dart run build_runner build --delete-conflicting-outputs` after creating the provider file.
  </action>
  <verify>
1. `dart run build_runner build --delete-conflicting-outputs` succeeds
2. `flutter analyze` passes (or only pre-existing warnings)
3. Provider file and generated file exist
4. Remote data source has `fetchScoringSummaryData` method
  </verify>
  <done>Scoring summary provider fetches cross-user scoring data and maps to grid-friendly data model. Admin sees all users; managers see subordinates.</done>
</task>

<task type="auto">
  <name>Task 2: Create scoring summary screen and wire route</name>
  <files>
    lib/presentation/screens/admin/4dx/scoring_summary_screen.dart
    lib/config/routes/app_router.dart
    lib/config/routes/route_names.dart
    lib/presentation/screens/admin/4dx/admin_4dx_home_screen.dart
  </files>
  <action>
**Create `lib/presentation/screens/admin/4dx/scoring_summary_screen.dart`:**

Build a screen with:
1. **AppBar** with title "Ringkasan Skor" and refresh button
2. **Period selector** at the top (same pattern as leaderboard_screen.dart -- Card with DropdownButton)
3. **Horizontally scrollable DataTable** (or SingleChildScrollView with Table) showing:
   - **Columns**: # (rank), Nama (name), [one column per active measure showing measure name/code], Total Skor
   - **Rows**: One per user, sorted by rank
   - **Cells**: For each measure cell, show `actual / percentage%` (e.g., "12 / 80%")
   - **Total Skor column**: Show `totalScore` with color coding (green >= 75, amber >= 50, red < 50)
   - If a user has no score for a measure, show "â€”" (dash)
4. **Empty state** if no data
5. **Error state** using `AppErrorState` pattern
6. **Loading state** with CircularProgressIndicator

Use `ConsumerStatefulWidget` for period selector state management.

The grid should be horizontally scrollable since there may be many measures. Use `SingleChildScrollView(scrollDirection: Axis.horizontal)` wrapping a `DataTable` or `Table`.

For role-based access:
- The data is already filtered by the provider (admin sees all, managers see subordinates)
- Add a subtitle showing the filter context: "Semua pengguna" for admin, "Tim Anda" for managers

**In `route_names.dart`:**

Add to the RouteNames class:
```dart
static const String adminScoringSummary = 'admin-scoring-summary';
```

Add to RouteFullPaths class:
```dart
static const String adminScoringSummary = '/admin/4dx/scoring-summary';
```

**In `app_router.dart`:**

Add a new GoRoute under the `4dx` shell route (near the existing measures/periods/targets routes):
```dart
GoRoute(
  path: 'scoring-summary',
  name: RouteNames.adminScoringSummary,
  builder: (context, state) => const ScoringSummaryScreen(),
),
```

Import the new screen file at the top.

**In `admin_4dx_home_screen.dart`:**

Add a new AdminMenuCard for "Ringkasan Skor" that navigates to the scoring summary screen. Place it after the existing cards (Measures, Periods, Targets). Use an appropriate icon (e.g., `Icons.grid_on` or `Icons.table_chart`).

```dart
AdminMenuCard(
  title: 'Ringkasan Skor',
  subtitle: 'Grid skor pengguna per ukuran',
  icon: Icons.table_chart,
  onTap: () => context.goNamed(RouteNames.adminScoringSummary),
),
```

Also make this card visible to managers (BH/BM/ROH), not just admins. Check if the admin_4dx_home_screen already handles role-based visibility; if not, the routing guard should handle it.
  </action>
  <verify>
1. `flutter analyze` passes (or only pre-existing warnings)
2. Route `adminScoringSummary` exists in route_names.dart
3. GoRoute registered in app_router.dart under 4dx path
4. AdminMenuCard for "Ringkasan Skor" exists in admin_4dx_home_screen.dart
5. ScoringSelectScreen file exists with DataTable or Table implementation
6. Screen handles loading, error, empty, and data states
  </verify>
  <done>Scoring summary grid screen is navigable from admin 4DX home. Shows users x measures grid with actual/percentage per cell. Period-aware with selector. Admin sees all, managers see subordinates.</done>
</task>

</tasks>

<verification>
1. `dart run build_runner build --delete-conflicting-outputs` succeeds
2. `flutter analyze` passes (or only pre-existing warnings)
3. New screen file exists at `lib/presentation/screens/admin/4dx/scoring_summary_screen.dart`
4. Route registered and navigable from admin 4DX home
5. Grid shows users as rows, measures as columns, actual/% per cell
6. Admin sees all users, managers see subordinates
7. Period selector works
</verification>

<success_criteria>
Scoring summary grid screen is complete and navigable. Admin and manager roles can view cross-user scoring data in a tabular format. Grid is period-aware and shows actual/target/percentage per cell with composite score.
</success_criteria>

<output>
After completion, create `.planning/phases/10-scoring-optimization/10-03-SUMMARY.md`
</output>
