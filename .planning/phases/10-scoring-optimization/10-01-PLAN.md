---
phase: 10-scoring-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260223000001_ranking_functions.sql
  - supabase/functions/score-aggregation-cron/index.ts
  - docs/04-database/sql/04_rls_policies.sql
autonomous: true
requirements: [SCORE-01, SCORE-02]

must_haves:
  truths:
    - "Ranking SQL function computes DENSE_RANK per role across three pools: company-wide, per-regional-office, and per-branch"
    - "Each pool stores its own rank and rank_change in dedicated columns (rank/rank_change for company, branch_rank/branch_rank_change for branch, regional_rank/regional_rank_change for regional)"
    - "Cron Edge Function calls calculate_rankings() after processing all dirty users"
    - "Filtered leaderboard RPC returns dynamically ranked results partitioned by optional role/branch/region filters"
    - "Expired measures are auto-deactivated when their period ends"
  artifacts:
    - path: "supabase/migrations/20260223000001_ranking_functions.sql"
      provides: "Schema additions (4 new rank columns) + calculate_rankings (3 pools), get_filtered_leaderboard, deactivate_expired_measures SQL functions"
      contains: "DENSE_RANK"
    - path: "supabase/functions/score-aggregation-cron/index.ts"
      provides: "Updated cron that calls ranking after aggregate processing and deactivates expired measures"
      contains: "calculate_rankings"
  key_links:
    - from: "supabase/functions/score-aggregation-cron/index.ts"
      to: "calculate_rankings SQL function"
      via: "supabase.rpc('calculate_rankings')"
      pattern: "calculate_rankings"
    - from: "supabase/functions/score-aggregation-cron/index.ts"
      to: "deactivate_expired_measures SQL function"
      via: "supabase.rpc('deactivate_expired_measures')"
      pattern: "deactivate_expired_measures"
---

<objective>
Create the server-side ranking infrastructure: SQL functions for ranking calculation, filtered leaderboard queries, and measure auto-deactivation. Update the cron Edge Function to call ranking after aggregate processing.

Purpose: The `rank` and `rank_change` columns in `user_score_aggregates` are never populated -- this is the primary gap. Without server-side ranking, the leaderboard shows all users unranked.

Output: SQL migration with 3 functions + updated cron Edge Function
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-scoring-optimization/10-CONTEXT.md
@.planning/phases/10-scoring-optimization/10-RESEARCH.md
@supabase/functions/score-aggregation-cron/index.ts
@supabase/migrations/20260207000001_multi_period_scoring.sql
@docs/04-database/sql/04_rls_policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration with ranking functions</name>
  <files>supabase/migrations/20260223000001_ranking_functions.sql</files>
  <action>
Create a new SQL migration file with schema additions and three functions:

**Schema additions (new columns on user_score_aggregates):**
The existing `rank` and `rank_change` columns represent company-wide ranking. Add four new columns for the other two pools:
```sql
ALTER TABLE user_score_aggregates
  ADD COLUMN IF NOT EXISTS branch_rank INTEGER,
  ADD COLUMN IF NOT EXISTS branch_rank_change INTEGER,
  ADD COLUMN IF NOT EXISTS regional_rank INTEGER,
  ADD COLUMN IF NOT EXISTS regional_rank_change INTEGER;

COMMENT ON COLUMN user_score_aggregates.rank IS 'Company-wide rank within role (DENSE_RANK)';
COMMENT ON COLUMN user_score_aggregates.rank_change IS 'Company-wide rank change vs previous period (positive = improved)';
COMMENT ON COLUMN user_score_aggregates.branch_rank IS 'Per-branch rank within role (DENSE_RANK)';
COMMENT ON COLUMN user_score_aggregates.branch_rank_change IS 'Per-branch rank change vs previous period (positive = improved)';
COMMENT ON COLUMN user_score_aggregates.regional_rank IS 'Per-regional-office rank within role (DENSE_RANK)';
COMMENT ON COLUMN user_score_aggregates.regional_rank_change IS 'Per-regional-office rank change vs previous period (positive = improved)';
```

**1. `calculate_rankings(p_period_id UUID)`**
Computes rankings across THREE pools per locked decision. All pools partition by role (RM vs RM, BH vs BH, etc.).

- **Company-wide pool**: `DENSE_RANK() OVER (PARTITION BY u.role ORDER BY usa.total_score DESC)` → writes to `rank` column
- **Branch pool**: `DENSE_RANK() OVER (PARTITION BY u.role, u.branch_id ORDER BY usa.total_score DESC)` → writes to `branch_rank` column
- **Regional pool**: `DENSE_RANK() OVER (PARTITION BY u.role, b.regional_office_id ORDER BY usa.total_score DESC)` → writes to `regional_rank` column (joins branches to get regional_office_id)

All three pools:
- Exclude admins (`u.role NOT IN ('ADMIN', 'SUPERADMIN')`) and inactive users (`u.is_active = TRUE`)
- Include users with zero scores (they appear at bottom of rankings -- per locked decision)

After computing all three pool ranks, calculate rank_change for EACH pool by finding previous period of same type:
- `SELECT id INTO v_prev_period_id FROM scoring_periods WHERE period_type = v_current_period_type AND end_date < v_current_start_date AND id != p_period_id ORDER BY end_date DESC LIMIT 1`
- For each pool: `pool_rank_change = previous_pool_rank - current_pool_rank` (positive = improved, negative = dropped)
- First-ever period: all rank_change columns = NULL (client already handles NULL as dash)

Implementation approach: Use a single CTE-based UPDATE statement that computes all three ranks via window functions, then a second UPDATE joins with previous period to compute rank_change for each pool. Wrap in a transaction.

- SECURITY DEFINER so cron can call it with service_role

**2. `get_filtered_leaderboard(p_period_id UUID, p_role TEXT DEFAULT NULL, p_branch_id UUID DEFAULT NULL, p_regional_office_id UUID DEFAULT NULL)`**
- Returns TABLE (user_id UUID, user_name TEXT, branch_name TEXT, role TEXT, total_score NUMERIC, lead_score NUMERIC, lag_score NUMERIC, rank BIGINT, rank_change INTEGER)
- Uses `DENSE_RANK() OVER (ORDER BY usa.total_score DESC)` to dynamically compute rank within the filtered subset
- Joins user_score_aggregates with users and branches
- Filters: `u.is_active = TRUE`, `u.role NOT IN ('ADMIN', 'SUPERADMIN')`, optional p_role, p_branch_id, p_regional_office_id
- For rank_change: reads the appropriate pre-computed value based on filter context:
  - If p_branch_id is set → use `usa.branch_rank_change`
  - If p_regional_office_id is set → use `usa.regional_rank_change`
  - Otherwise → use `usa.rank_change` (company-wide)
- ORDER BY rank ASC NULLS LAST
- SECURITY DEFINER STABLE

**3. `deactivate_expired_measures()`**
- Sets `is_active = false` on measure_definitions where their period_type's current period has ended
- Logic: find measures where `md.period_type` matches a scoring_period with `is_current = TRUE AND end_date < NOW()`
- Returns count of deactivated measures for logging
- SECURITY DEFINER

Also add a comment on each function explaining its purpose.

**RLS verification note**: Add a comment block at the top of the migration confirming that the RLS policies `user_score_aggregates_select_authenticated` and `user_scores_select_authenticated` already exist in 04_rls_policies.sql and are sufficient for leaderboard access. No new RLS policies needed.
  </action>
  <verify>
Review the SQL file for:
1. Schema: four new columns added (branch_rank, branch_rank_change, regional_rank, regional_rank_change)
2. DENSE_RANK usage (not RANK) for intuitive tie handling (1,2,2,3 not 1,2,2,4)
3. Three ranking pools computed: company-wide (PARTITION BY role), branch (PARTITION BY role, branch_id), regional (PARTITION BY role, regional_office_id)
4. Proper exclusion of ADMIN/SUPERADMIN roles and inactive users
5. rank_change computed for ALL THREE pools as previous_rank - current_rank (positive = improved)
6. NULL handling for first-ever period (all six rank_change columns NULL)
7. get_filtered_leaderboard returns appropriate rank_change based on filter context
8. deactivate_expired_measures checks period end_date < NOW()
  </verify>
  <done>SQL migration file exists with schema additions (4 new rank columns) and three valid functions. Three ranking pools (company, branch, regional) are computed with independent rank_change per pool. Admin exclusion, zero-score inclusion, and rank_change persistence all handled per locked decisions.</done>
</task>

<task type="auto">
  <name>Task 2: Update cron Edge Function with ranking and auto-deactivation</name>
  <files>supabase/functions/score-aggregation-cron/index.ts</files>
  <action>
Modify the existing `score-aggregation-cron/index.ts` to add two new steps AFTER the dirty user processing loop:

**Step 1: Deactivate expired measures (BEFORE ranking, per pitfall #6 in research)**
After the dirty user loop, BEFORE ranking:
```typescript
// Deactivate expired measures (before ranking to ensure consistent scores)
console.log("Checking for expired measures...");
const { data: deactivated, error: deactivateError } = await supabase.rpc(
  "deactivate_expired_measures"
);
if (deactivateError) {
  console.error("Measure deactivation failed:", deactivateError);
  // Non-fatal -- continue with ranking
} else if (deactivated > 0) {
  console.log(`Deactivated ${deactivated} expired measures`);
}
```

**Step 2: Calculate rankings (AFTER all dirty users processed, per pitfall #1)**
Only if `successCount > 0` (at least one user was recalculated):
```typescript
if (successCount > 0) {
  console.log("Calculating rankings...");
  const { error: rankError } = await supabase.rpc(
    "calculate_rankings",
    { p_period_id: periodId }
  );
  if (rankError) {
    console.error("Ranking calculation failed:", rankError);
    // Log to system_errors but don't fail the entire response
    try {
      await supabase.from("system_errors").insert({
        error_type: "CRON_RANKING_FAILED",
        error_message: `Ranking calculation failed: ${rankError.message}`,
        created_at: new Date().toISOString(),
      });
    } catch (logError) {
      console.error("Failed to log ranking error:", logError);
    }
  } else {
    console.log("Rankings updated for period:", periodId);
  }
}
```

**Update summary response** to include ranking status:
Add `rankingUpdated: boolean` and `measuresDeactivated: number` to the response JSON.

Keep all existing logic (dirty user processing, error handling, etc.) unchanged. Only ADD the new steps after the processing loop and before the final response.
  </action>
  <verify>
Review the updated Edge Function for:
1. Deactivation runs BEFORE ranking
2. Ranking runs ONLY when successCount > 0
3. Ranking failures are logged but don't fail the entire cron
4. Both deactivation and ranking use supabase.rpc() calls
5. Response JSON includes new fields
6. All existing dirty user processing logic is preserved unchanged
  </verify>
  <done>Cron Edge Function processes dirty users, deactivates expired measures, then calculates rankings -- in that order. Ranking failures are non-fatal.</done>
</task>

<task type="auto">
  <name>Task 3: Document RLS policy verification in scoring section</name>
  <files>docs/04-database/sql/04_rls_policies.sql</files>
  <action>
The existing RLS policies in `04_rls_policies.sql` already have the correct SELECT policies for leaderboard access:
- `user_scores_select_authenticated` on user_scores
- `user_score_aggregates_select_authenticated` on user_score_aggregates
- `users_select_authenticated` on users (already exists for basic profile access)

Add a comment block in the scoring section (near line 608) noting that these policies support the Phase 10 leaderboard requirements:

```sql
-- NOTE (Phase 10): These SELECT policies support leaderboard visibility.
-- All authenticated users can read scores and aggregates (public leaderboard).
-- The get_filtered_leaderboard() RPC function uses SECURITY DEFINER to bypass
-- RLS for the ranking computation, but results are filtered by the function's
-- parameters. No new RLS policies needed for Phase 10.
```

Also verify that there are no restrictive policies on the `users` table that would block leaderboard name resolution. The existing `users_select_authenticated` policy (all authenticated can SELECT) is sufficient per the locked decision "Broader SELECT on users -- all authenticated users can SELECT basic profile".

If `users_select_authenticated` does NOT exist, add it:
```sql
CREATE POLICY "users_select_authenticated" ON users
FOR SELECT USING (auth.uid() IS NOT NULL);
```

Check the current file content first -- if it already exists, just add the comment.
  </action>
  <verify>
Verify that the RLS policies doc has the Phase 10 note and that SELECT policies exist for user_scores, user_score_aggregates, and users tables.
  </verify>
  <done>RLS documentation updated with Phase 10 note confirming existing policies are sufficient for leaderboard access</done>
</task>

</tasks>

<verification>
1. SQL migration file exists at `supabase/migrations/20260223000001_ranking_functions.sql` with schema additions and three functions
2. Four new columns exist: branch_rank, branch_rank_change, regional_rank, regional_rank_change
3. `calculate_rankings` computes three pools (company, branch, regional) all partitioned by role, with independent rank_change per pool
4. `get_filtered_leaderboard` returns dynamically ranked results and selects appropriate rank_change based on filter context
5. `deactivate_expired_measures` deactivates measures whose period has ended
6. Cron Edge Function calls deactivation then ranking after dirty user processing
7. RLS policies documented and verified sufficient
</verification>

<success_criteria>
Server-side ranking infrastructure is complete with three ranking pools (company-wide, per-branch, per-regional-office). SQL functions exist, cron calls them in correct order, and RLS policies support leaderboard access. All six rank/rank_change columns on `user_score_aggregates` will be populated after the next cron run.
</success_criteria>

<output>
After completion, create `.planning/phases/10-scoring-optimization/10-01-SUMMARY.md`
</output>
