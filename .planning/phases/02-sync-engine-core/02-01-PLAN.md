---
phase: 02-sync-engine-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/datasources/local/sync_queue_local_data_source.dart
  - lib/data/services/sync_service.dart
  - lib/presentation/providers/sync_providers.dart
autonomous: true

must_haves:
  truths:
    - "create+update for same entity coalesces to create with updated payload in sync queue"
    - "create+delete for same entity removes both entries from sync queue"
    - "update+update for same entity replaces payload with latest"
    - "update+delete for same entity replaces with delete"
    - "Rapid successive repository writes trigger only one sync batch after 500ms window"
    - "Manual sync via SyncNotifier executes immediately without debounce delay"
  artifacts:
    - path: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      provides: "getPendingItemForEntity() method for efficient single-entity queue lookup"
      contains: "getPendingItemForEntity"
    - path: "lib/data/services/sync_service.dart"
      provides: "Full coalescing logic in queueOperation() and debounced triggerSync()"
      contains: "_debounceTimer"
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "SyncNotifier calls processQueue() directly bypassing debounce"
      contains: "processQueue()"
  key_links:
    - from: "lib/data/services/sync_service.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "getPendingItemForEntity() called inside queueOperation()"
      pattern: "getPendingItemForEntity"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/services/sync_service.dart"
      via: "SyncNotifier calls _syncService.processQueue() not triggerSync()"
      pattern: "_syncService\\.processQueue\\(\\)"
---

<objective>
Implement intelligent sync queue coalescing (SYNC-03) and debounced sync triggers (SYNC-04) in SyncService.

Purpose: Prevent redundant sync operations when users rapidly edit the same entity (coalescing) and prevent thundering herd when multiple repository writes fire `triggerSync()` in rapid succession (debouncing). These two changes are tightly coupled in `sync_service.dart` and form the behavioral foundation for the sync queue.

Output: SyncService with full coalescing rules (create+update, create+delete, update+update, update+delete) and 500ms debounced triggerSync with immediate processQueue for manual sync.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sync-engine-core/02-RESEARCH.md

@lib/data/services/sync_service.dart
@lib/data/datasources/local/sync_queue_local_data_source.dart
@lib/presentation/providers/sync_providers.dart
@lib/domain/entities/sync_models.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getPendingItemForEntity and rewrite queueOperation with full coalescing</name>
  <files>
    lib/data/datasources/local/sync_queue_local_data_source.dart
    lib/data/services/sync_service.dart
  </files>
  <action>
**Step 1: Add `getPendingItemForEntity()` to SyncQueueLocalDataSource:**

In `sync_queue_local_data_source.dart`, add a new method that efficiently queries for a single pending queue item matching both entityType AND entityId:

```dart
/// Get the pending sync queue item for a specific entity.
/// Returns null if no pending operation exists.
Future<SyncQueueItem?> getPendingItemForEntity(
  String entityType,
  String entityId,
) async {
  final query = _db.select(_db.syncQueueItems)
    ..where((t) =>
        t.entityType.equals(entityType) & t.entityId.equals(entityId));
  return query.getSingleOrNull();
}
```

**Step 2: Rewrite `queueOperation()` in SyncService with full coalescing logic:**

Replace the existing `queueOperation()` method body in `sync_service.dart`. The new implementation must:

1. Wrap the entire check-and-modify sequence in `_database.transaction()` to prevent race conditions (two rapid writes seeing the same "has pending" state).
2. Use `_syncQueueDataSource.getPendingItemForEntity()` to get the existing item (if any).
3. Apply coalescing rules using Dart 3 pattern matching:
   - `('create', 'update')` → Keep create operation, update payload via `updatePayload()`. Return existing item ID.
   - `('create', 'delete')` → Remove both from queue via `removeOperation()`. Return -1 (no queue item needed).
   - `('update', 'update')` → Remove old operation, add new one. Return new ID.
   - `('update', 'delete')` → Remove old operation, add delete. Return new ID.
   - `default` (unexpected combinations like `delete+create`) → Log warning with `_log.warning('sync.queue | Unexpected coalesce: ...')`, add new item anyway.
4. If no existing item, simply add to queue via `addToQueue()`.

Use the switch expression with record patterns as shown in the research Example 2:
```dart
switch ((existing.operation, operation.name)) {
  case ('create', 'update'): ...
  case ('create', 'delete'): ...
  case ('update', 'update'): ...
  case ('update', 'delete'): ...
  default: ...
}
```

Add structured log calls:
- `_log.debug('sync.queue | Coalesced ${existing.operation}+${operation.name} for ${entityType.name}/${entityId}')` for each coalesce case.
- `_log.debug('sync.queue | Queued ${operation.name} for ${entityType.name}/${entityId}')` for fresh queue insertions.

**Important:** The coalescing for `create+update` must use `updatePayload(existing.id, jsonEncode(payload))` — the payload passed in is already the full current entity state (repositories read the full entity from DB before calling queueOperation for updates). Do NOT merge payloads; replace entirely.
  </action>
  <verify>
Run `flutter analyze` — zero errors. Verify the new `getPendingItemForEntity` method exists in the data source. Verify `queueOperation()` contains a `_database.transaction()` wrapper and switch cases for all 4 coalescing rules.
  </verify>
  <done>
SyncService.queueOperation() handles all 4 coalescing combinations (create+update, create+delete, update+update, update+delete) atomically within a Drift transaction. SyncQueueLocalDataSource has getPendingItemForEntity() for efficient lookup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add debounced triggerSync and update SyncNotifier to bypass debounce</name>
  <files>
    lib/data/services/sync_service.dart
    lib/presentation/providers/sync_providers.dart
  </files>
  <action>
**Step 1: Add debounce fields and rewrite `triggerSync()` in SyncService:**

Add two new fields to `SyncService`:
```dart
Timer? _debounceTimer;
Completer<SyncResult>? _pendingSyncCompleter;
```

Replace the current `triggerSync()` method (which is just `=> processQueue()`) with a debounced version:

```dart
/// Trigger sync with 500ms debounce window.
/// Multiple calls within the window result in a single processQueue().
/// Returns a Future that completes when the batched sync finishes.
Future<SyncResult> triggerSync() {
  _debounceTimer?.cancel();

  if (_pendingSyncCompleter == null || _pendingSyncCompleter!.isCompleted) {
    _pendingSyncCompleter = Completer<SyncResult>();
  }

  final completer = _pendingSyncCompleter!;

  _debounceTimer = Timer(const Duration(milliseconds: 500), () async {
    try {
      final result = await processQueue();
      if (!completer.isCompleted) {
        completer.complete(result);
      }
    } catch (e) {
      if (!completer.isCompleted) {
        completer.completeError(e);
      }
    }
  });

  return completer.future;
}
```

**Step 2: Update `dispose()` to cancel the debounce timer:**

In the existing `dispose()` method, add cleanup before the existing `stopBackgroundSync()` and `_stateController.close()`:
```dart
void dispose() {
  _debounceTimer?.cancel();
  if (_pendingSyncCompleter != null && !_pendingSyncCompleter!.isCompleted) {
    _pendingSyncCompleter!.completeError(
      StateError('SyncService disposed while sync was pending'),
    );
  }
  stopBackgroundSync();
  _stateController.close();
}
```

**Step 3: Update SyncNotifier to call processQueue() directly:**

In `sync_providers.dart`, in `SyncNotifier.triggerSync()`, change the push step from:
```dart
final pushResult = await _syncService.triggerSync();
```
to:
```dart
final pushResult = await _syncService.processQueue();
```

This ensures that user-initiated manual sync executes immediately without the 500ms debounce delay. The debounce only applies to the "fire and forget" `unawaited(_syncService.triggerSync())` calls scattered across repositories.

**Do NOT change** any of the `unawaited(_syncService.triggerSync())` calls in repository files — those should go through the debounced path.
  </action>
  <verify>
Run `flutter analyze` — zero errors. Verify `SyncService` has `_debounceTimer` and `_pendingSyncCompleter` fields. Verify `triggerSync()` creates a `Timer` with 500ms duration. Verify `SyncNotifier.triggerSync()` calls `_syncService.processQueue()` (not `_syncService.triggerSync()`). Verify `dispose()` cancels the timer.
  </verify>
  <done>
SyncService.triggerSync() debounces with 500ms window. SyncNotifier.triggerSync() calls processQueue() directly for immediate manual sync. Dispose cleans up timer and pending completer.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with zero errors
2. `sync_queue_local_data_source.dart` contains `getPendingItemForEntity` method
3. `sync_service.dart` contains `_debounceTimer`, `_pendingSyncCompleter`, and coalescing switch with 4 cases
4. `sync_providers.dart` SyncNotifier calls `_syncService.processQueue()` not `_syncService.triggerSync()`
5. `queueOperation()` is wrapped in `_database.transaction()`
</verification>

<success_criteria>
- Queue coalescing correctly handles all 4 operation combinations within atomic transactions
- Debounced triggerSync batches rapid writes into single sync execution
- Manual sync via SyncNotifier executes immediately
- All code compiles and passes analysis
</success_criteria>

<output>
After completion, create `.planning/phases/02-sync-engine-core/02-01-SUMMARY.md`
</output>
