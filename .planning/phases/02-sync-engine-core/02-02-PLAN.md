---
phase: 02-sync-engine-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/data/repositories/customer_repository_impl.dart
  - lib/data/repositories/pipeline_repository_impl.dart
  - lib/data/repositories/activity_repository_impl.dart
  - lib/presentation/providers/sync_providers.dart
autonomous: true

must_haves:
  truths:
    - "App crash between local DB write and sync queue insertion never loses data for customer, pipeline, and activity operations"
    - "CustomerRepositoryImpl has _database and _syncQueueDataSource constructor parameters"
    - "All customer create/update/delete and key person create/update/delete are wrapped in Drift transactions"
    - "All pipeline create/update/updateStage/updateStatus/delete are wrapped in Drift transactions"
    - "All activity create/createImmediate/update/execute/cancel are wrapped in Drift transactions"
  artifacts:
    - path: "lib/data/repositories/customer_repository_impl.dart"
      provides: "Atomic transactions for all 6 customer+keyPerson write methods"
      contains: "_database.transaction"
    - path: "lib/data/repositories/pipeline_repository_impl.dart"
      provides: "Atomic transactions for all 5 pipeline write methods"
      contains: "_database.transaction"
    - path: "lib/data/repositories/activity_repository_impl.dart"
      provides: "Atomic transactions for all 5 activity write methods"
      contains: "_database.transaction"
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "Updated CustomerRepositoryImpl provider with database and syncQueueDataSource params"
      contains: "database:"
  key_links:
    - from: "lib/data/repositories/customer_repository_impl.dart"
      to: "lib/data/services/sync_service.dart"
      via: "_syncService.queueOperation() called inside _database.transaction()"
      pattern: "_database\\.transaction"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/repositories/customer_repository_impl.dart"
      via: "Provider passes database and syncQueueDataSource to CustomerRepositoryImpl"
      pattern: "database:"
---

<objective>
Wrap local DB writes and sync queue insertions in atomic Drift transactions for Customer, Pipeline, and Activity repositories (SYNC-01, part 1 of 2).

Purpose: Prevent data loss when the app crashes between a local write and the corresponding sync queue insertion. These are the three most-used repositories with 16 methods total that need wrapping. CustomerRepositoryImpl also needs _database injected since it's the only major repo missing it.

Output: All create/update/delete methods in customer, pipeline, and activity repositories wrapped in `_database.transaction()` blocks ensuring atomicity.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sync-engine-core/02-RESEARCH.md
@.planning/phases/02-sync-engine-core/02-01-SUMMARY.md

@lib/data/repositories/customer_repository_impl.dart
@lib/data/repositories/pipeline_repository_impl.dart
@lib/data/repositories/activity_repository_impl.dart
@lib/presentation/providers/sync_providers.dart
@lib/data/services/sync_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _database to CustomerRepositoryImpl and wrap all customer+keyPerson write methods in transactions</name>
  <files>
    lib/data/repositories/customer_repository_impl.dart
    lib/presentation/providers/sync_providers.dart
  </files>
  <action>
**Step 1: Add `_database` constructor parameter to CustomerRepositoryImpl:**

CustomerRepositoryImpl is the only major repository missing a `_database` reference. Add it:

1. Add `required db.AppDatabase database,` to the named constructor parameters
2. Add `_database = database` to the initializer list
3. Add `final db.AppDatabase _database;` field

The import for `app_database.dart as db` already exists.

**Step 2: Update the `_customerRepositoryProvider` in sync_providers.dart:**

In the `_customerRepositoryProvider` definition, add the database parameter:
```dart
final database = ref.watch(databaseProvider);

return CustomerRepositoryImpl(
  localDataSource: localDataSource,
  keyPersonLocalDataSource: keyPersonLocalDataSource,
  remoteDataSource: remoteDataSource,
  keyPersonRemoteDataSource: keyPersonRemoteDataSource,
  syncService: syncService,
  currentUserId: currentUser?.id ?? '',
  database: database,  // NEW
);
```

**Step 3: Wrap all 6 customer + key person write methods in `_database.transaction()`:**

For each of these methods, wrap the local write AND the `_syncService.queueOperation()` call inside `await _database.transaction(() async { ... })`. The `triggerSync()` call MUST remain OUTSIDE the transaction (it's fire-and-forget and should not block the transaction).

Methods to wrap (6 total):

1. **`createCustomer()`** — Wrap `_localDataSource.insertCustomer(companion)` + `_syncService.queueOperation(...)` in transaction. Keep `unawaited(_syncService.triggerSync())` and `getCustomerById(id)` outside.

2. **`updateCustomer()`** — Wrap `_localDataSource.updateCustomer(id, companion)` + reading updated data + `_syncService.queueOperation(...)` in transaction. Keep triggerSync and final getCustomerById outside.

3. **`deleteCustomer()`** — Wrap the local soft-delete update + `_syncService.queueOperation(...)` in transaction. Keep triggerSync outside.

4. **`addKeyPerson()`** — Wrap `_keyPersonLocalDataSource.insertKeyPerson(companion)` + `_syncService.queueOperation(...)` in transaction. Keep triggerSync and getKeyPerson outside.

5. **`updateKeyPerson()`** — Wrap `_keyPersonLocalDataSource.updateKeyPerson(id, companion)` + reading updated data + `_syncService.queueOperation(...)` in transaction. Keep triggerSync outside.

6. **`deleteKeyPerson()`** — Wrap the local soft-delete update + `_syncService.queueOperation(...)` in transaction. Keep triggerSync outside.

**Pattern for each method:**
```dart
// BEFORE (non-atomic):
await _localDataSource.insertCustomer(companion);
await _syncService.queueOperation(...);
unawaited(_syncService.triggerSync());

// AFTER (atomic):
await _database.transaction(() async {
  await _localDataSource.insertCustomer(companion);
  await _syncService.queueOperation(...);
});
unawaited(_syncService.triggerSync());
```

**Critical:** Inside a Drift transaction, all database operations using the same `AppDatabase` instance automatically participate in the transaction via zone-based scoping. Since `_localDataSource._db`, `_syncService._syncQueueDataSource._db`, and `_database` are all the same `AppDatabase` instance (from `databaseProvider`), this works without modifying data source classes.

**Important for updateCustomer/updateKeyPerson:** The pattern of reading updated data inside the transaction is fine — the read will see the just-written data within the transaction scope.
  </action>
  <verify>
Run `flutter analyze` — zero errors. Verify `CustomerRepositoryImpl` constructor accepts `database` parameter. Verify `_customerRepositoryProvider` passes `database`. Grep for `_database.transaction` in `customer_repository_impl.dart` — should find 6 occurrences.
  </verify>
  <done>
CustomerRepositoryImpl has _database field. All 6 customer + key person write methods wrapped in Drift transactions. Provider updated to pass database. An app crash between local write and queue insertion is impossible for customer/keyPerson operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap all pipeline and activity write methods in transactions</name>
  <files>
    lib/data/repositories/pipeline_repository_impl.dart
    lib/data/repositories/activity_repository_impl.dart
  </files>
  <action>
Both PipelineRepositoryImpl and ActivityRepositoryImpl already have `_database` fields. No DI changes needed — just wrap the write methods.

**PipelineRepositoryImpl — 5 methods to wrap:**

1. **`createPipeline()`** — Wrap local insert + queueOperation in `_database.transaction()`. Keep triggerSync + getById outside.

2. **`updatePipeline()`** — Wrap local update + read updated data + queueOperation in transaction. Keep triggerSync outside.

3. **`updatePipelineStage()`** — Wrap local stage update + history log insert + queueOperation(s) in transaction. This method may have TWO queue operations (one for the pipeline update, one for the stage history). Both should be inside the same transaction. Keep triggerSync outside.

4. **`updatePipelineStatus()`** — Wrap local status update + queueOperation in transaction. Keep triggerSync outside.

5. **`deletePipeline()`** — Wrap local soft-delete + queueOperation in transaction. Keep triggerSync outside.

**ActivityRepositoryImpl — 5 methods to wrap:**

1. **`createActivity()`** — Wrap local insert + queueOperation in `_database.transaction()`. Keep triggerSync + getById outside.

2. **`createImmediateActivity()`** — Wrap local insert + queueOperation in transaction. Keep triggerSync outside.

3. **`updateActivity()`** — Wrap local update + read updated data + queueOperation in transaction. Keep triggerSync outside.

4. **`executeActivity()`** — Wrap local execute update (sets executedAt, status, etc.) + queueOperation in transaction. Keep triggerSync outside.

5. **`cancelActivity()`** — Wrap local cancel update + queueOperation in transaction. Keep triggerSync outside.

**Same pattern for all:**
```dart
await _database.transaction(() async {
  await _localDataSource.doLocalWrite(...);
  await _syncService.queueOperation(...);
});
unawaited(_syncService.triggerSync());
```

**Special case — updatePipelineStage:** This method creates both a pipeline update queue entry AND a pipeline stage history queue entry. Both inserts must be inside the same transaction:
```dart
await _database.transaction(() async {
  await _localDataSource.updatePipelineStage(...);
  await _historyLogDataSource.insertStageHistory(...);
  await _syncService.queueOperation(entityType: pipeline, ...);
  await _syncService.queueOperation(entityType: pipelineStageHistory, ...);
});
```

**Note:** Some methods may have additional local reads inside the try block (e.g., reading the updated entity to build the sync payload). These reads should be INSIDE the transaction so they see the just-written data.
  </action>
  <verify>
Run `flutter analyze` — zero errors. Grep for `_database.transaction` in `pipeline_repository_impl.dart` — should find 5 occurrences. Grep for `_database.transaction` in `activity_repository_impl.dart` — should find 5 occurrences.
  </verify>
  <done>
All 5 pipeline and 5 activity write methods wrapped in Drift transactions. Pipeline stage updates wrap both the stage change and history log in one transaction. No data loss possible between local write and queue insertion for pipeline and activity operations.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with zero errors
2. `CustomerRepositoryImpl` constructor has `database` parameter and `_database` field
3. `_customerRepositoryProvider` passes `database: database` to constructor
4. Total of 16 `_database.transaction()` calls across the 3 repository files (6 + 5 + 5)
5. All `triggerSync()` calls remain OUTSIDE transaction blocks
6. All `queueOperation()` calls are INSIDE transaction blocks
</verification>

<success_criteria>
- All customer, pipeline, and activity write operations are atomic (local write + queue insert in single Drift transaction)
- An app crash at any point either completes both operations or neither
- Provider wiring updated for CustomerRepositoryImpl
- Code compiles and passes analysis
</success_criteria>

<output>
After completion, create `.planning/phases/02-sync-engine-core/02-02-SUMMARY.md`
</output>
