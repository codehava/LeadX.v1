---
phase: 06-sync-coordination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/services/sync_coordinator.dart
  - lib/data/services/app_settings_service.dart
  - lib/data/services/sync_service.dart
  - lib/data/services/initial_sync_service.dart
  - lib/domain/entities/sync_models.dart
autonomous: true
requirements:
  - CONF-05

must_haves:
  truths:
    - "SyncCoordinator prevents concurrent sync execution via Completer-based lock"
    - "Initial sync completion gates all regular sync attempts"
    - "5-second cooldown after initial sync prevents premature regular sync triggers"
    - "Lock acquisition and release are logged with sync type and duration"
    - "Stale lock is recovered on startup and after 5-minute timeout"
  artifacts:
    - path: "lib/data/services/sync_coordinator.dart"
      provides: "Central sync coordination service with Completer-based lock"
      contains: "class SyncCoordinator"
    - path: "lib/domain/entities/sync_models.dart"
      provides: "SyncType enum for typed lock tracking"
      contains: "enum SyncType"
  key_links:
    - from: "lib/data/services/sync_coordinator.dart"
      to: "lib/data/services/app_settings_service.dart"
      via: "initial sync state queries"
      pattern: "hasInitialSyncCompleted"
    - from: "lib/data/services/sync_service.dart"
      to: "lib/data/services/sync_coordinator.dart"
      via: "coordinator lock check in processQueue"
      pattern: "SyncCoordinator"
    - from: "lib/data/services/initial_sync_service.dart"
      to: "lib/data/services/sync_coordinator.dart"
      via: "coordinator lock check in performInitialSync"
      pattern: "SyncCoordinator"
---

<objective>
Create the SyncCoordinator service and integrate it with SyncService and InitialSyncService.

Purpose: Replace the two independent `_isSyncing` booleans in SyncService and InitialSyncService with a centralized Completer-based lock that prevents race conditions between all sync entry points, gates regular sync until initial sync completes, and queues excess requests into a single collapsed follow-up execution.

Output: `sync_coordinator.dart` with full lock lifecycle, SyncType enum in sync_models.dart, AppSettingsService cooldown/recovery keys, SyncService and InitialSyncService refactored to delegate lock management to the coordinator.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-sync-coordination/06-RESEARCH.md
@lib/data/services/sync_service.dart
@lib/data/services/initial_sync_service.dart
@lib/data/services/app_settings_service.dart
@lib/data/services/connectivity_service.dart
@lib/domain/entities/sync_models.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncCoordinator service and SyncType enum</name>
  <files>
    lib/data/services/sync_coordinator.dart
    lib/domain/entities/sync_models.dart
    lib/data/services/app_settings_service.dart
  </files>
  <action>
    1. Add `SyncType` enum to `lib/domain/entities/sync_models.dart` (before the `SyncResult` class):
       ```dart
       /// Types of sync operations for lock tracking and logging.
       enum SyncType {
         initial,
         manual,
         background,
         repository,
         masterDataResync,
       }
       ```

    2. Add two new keys and methods to `lib/data/services/app_settings_service.dart`:
       - Add key constants:
         ```dart
         static const String keyInitialSyncCompletedAt = 'initial_sync_completed_at';
         static const String keySyncLockHolder = 'sync_lock_holder';
         ```
       - Add `getInitialSyncCompletedAt()` method: reads `keyInitialSyncCompletedAt`, returns `DateTime?` parsed from stored ISO 8601 string.
       - Add `setInitialSyncCompletedAt(DateTime timestamp)` method: stores timestamp as ISO 8601 UTC string.
       - Add `getSyncLockHolder()` / `setSyncLockHolder(String? holder)` methods: get/set the `keySyncLockHolder` key. `setSyncLockHolder(null)` deletes the key.
       - Update `markInitialSyncCompleted()` to also call `setInitialSyncCompletedAt(DateTime.now().toUtc())`.

    3. Create `lib/data/services/sync_coordinator.dart`:
       - Import `dart:async`, `AppLogger`, `AppSettingsService`, `sync_models.dart` (for `SyncType`, `SyncResult`).
       - Class `SyncCoordinator` with constructor taking `AppSettingsService`.
       - Private fields:
         - `Completer<void>? _activeSyncCompleter` (null = lock available)
         - `bool _queuedSyncPending = false` (cap at 1 queued request, collapses multiples)
         - `bool _initialSyncComplete = false` (in-memory cache, loaded from AppSettingsService on startup)
         - `DateTime? _initialSyncCompletedAt` (for cooldown check)
         - `SyncType? _currentSyncType` (what type of sync holds the lock)
         - `DateTime? _lockAcquiredAt` (for timeout-based recovery)
         - `static const Duration _lockTimeout = Duration(minutes: 5)`
         - `static const Duration _cooldownDuration = Duration(seconds: 5)`

       - `Future<void> initialize()` method:
         - Read `hasInitialSyncCompleted()` from AppSettingsService into `_initialSyncComplete`.
         - Read `getInitialSyncCompletedAt()` into `_initialSyncCompletedAt`.
         - Startup lock recovery: read `getSyncLockHolder()`. If non-null, log warning "sync.coordinator | Clearing stale lock from previous session (was: $holder)" and call `setSyncLockHolder(null)`. This handles app kill during sync.

       - `bool get isInitialSyncComplete => _initialSyncComplete`
       - `bool get isLocked => _activeSyncCompleter != null`
       - `SyncType? get currentSyncType => _currentSyncType`
       - `bool get hasQueuedSync => _queuedSyncPending`

       - `Future<bool> acquireLock({required SyncType type})` method:
         - If lock is held (`_activeSyncCompleter != null`):
           - Check timeout recovery: if `_lockAcquiredAt != null` and elapsed > `_lockTimeout`, force-release the lock with warning log "sync.coordinator | Force-releasing stale lock held for ${elapsed.inSeconds}s (type: $_currentSyncType)". Then fall through to acquire below.
           - Otherwise, if `type != SyncType.initial`, set `_queuedSyncPending = true`, log "sync.coordinator | Queued $type sync (lock held by $_currentSyncType)", return `false`.
           - If `type == SyncType.initial`, log "sync.coordinator | Rejected initial sync (lock held by $_currentSyncType)" and return `false` (initial sync should not overlap).
         - If `!_initialSyncComplete && type != SyncType.initial`:
           - Log "sync.coordinator | Rejected $type sync (initial sync not complete)", return `false`.
         - Cooldown check: if `_initialSyncCompletedAt != null && type != SyncType.initial`:
           - If elapsed since `_initialSyncCompletedAt` < `_cooldownDuration`, log "sync.coordinator | Rejected $type sync (cooldown active, ${remaining}ms left)", return `false`.
         - Acquire: create `_activeSyncCompleter = Completer<void>()`, set `_currentSyncType = type`, set `_lockAcquiredAt = DateTime.now()`.
         - Persist lock holder: `_appSettings.setSyncLockHolder(type.name)`.
         - Log "sync.coordinator | Acquired lock for $type".
         - Return `true`.

       - `void releaseLock()` method:
         - Capture `_lockAcquiredAt` for duration logging.
         - Complete and null out `_activeSyncCompleter`, null `_currentSyncType`, null `_lockAcquiredAt`.
         - Clear persisted lock: `_appSettings.setSyncLockHolder(null)`.
         - Log "sync.coordinator | Released lock for $type (held ${duration}ms)".

       - `Future<void> markInitialSyncComplete()` method:
         - Set `_initialSyncComplete = true`.
         - Set `_initialSyncCompletedAt = DateTime.now()`.
         - Call `_appSettings.markInitialSyncCompleted()`.
         - Call `_appSettings.setInitialSyncCompletedAt(DateTime.now().toUtc())`.
         - Log "sync.coordinator | Initial sync marked complete".

       - `void resetInitialSyncState()` method (for schema migration detection and cancel-and-logout):
         - Set `_initialSyncComplete = false`.
         - Set `_initialSyncCompletedAt = null`.
         - Log "sync.coordinator | Initial sync state reset".

       - `void setQueuedSyncPending()` method:
         - Set `_queuedSyncPending = true`.

       - `bool consumeQueuedSync()` method:
         - If `_queuedSyncPending`, set to `false`, return `true`. Else return `false`.

       Use `AppLogger.instance` with prefix `sync.coordinator` for all logging.
  </action>
  <verify>
    Run `flutter analyze lib/data/services/sync_coordinator.dart lib/data/services/app_settings_service.dart lib/domain/entities/sync_models.dart` -- no errors.
  </verify>
  <done>
    SyncCoordinator class exists with Completer-based lock, SyncType enum exists, AppSettingsService has cooldown/recovery keys, all static analysis passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SyncCoordinator into SyncService and InitialSyncService</name>
  <files>
    lib/data/services/sync_service.dart
    lib/data/services/initial_sync_service.dart
  </files>
  <action>
    1. Modify `lib/data/services/sync_service.dart`:
       - Add optional `SyncCoordinator?` parameter to constructor (optional to preserve backward compatibility for background sync which creates its own SyncService instance).
       - Store as `final SyncCoordinator? _coordinator`.
       - In `processQueue()`: Replace the `_isSyncing` check block (lines ~86-95) with coordinator-aware logic:
         ```dart
         // If coordinator is available, check lock state
         if (_coordinator != null) {
           if (_coordinator!.isLocked) {
             _log.debug('sync.queue | Sync lock held, skipping processQueue');
             return SyncResult(success: false, processedCount: 0, successCount: 0, failedCount: 0, errors: ['Sync lock held by coordinator'], syncedAt: DateTime.now());
           }
         } else {
           // Fallback for standalone usage (background sync)
           if (_isSyncing) {
             _log.debug('sync.queue | Sync already in progress, returning');
             return SyncResult(success: false, processedCount: 0, successCount: 0, failedCount: 0, errors: ['Sync already in progress'], syncedAt: DateTime.now());
           }
         }
         ```
       - Keep `_isSyncing = true` / `_isSyncing = false` in the try/finally for the fallback path (when no coordinator is present). The coordinator path will set its own lock externally.
       - In `startBackgroundSync()`: Replace `!_isSyncing` check with `_coordinator?.isLocked != true && !_isSyncing` to respect both lock sources.

    2. Modify `lib/data/services/initial_sync_service.dart`:
       - Add optional `SyncCoordinator?` parameter to constructor.
       - Store as `final SyncCoordinator? _coordinator`.
       - In `performInitialSync()`: Replace the `_isSyncing` guard (lines ~134-143) with:
         ```dart
         if (_coordinator != null) {
           if (!await _coordinator!.acquireLock(type: SyncType.initial)) {
             return SyncResult(success: false, processedCount: 0, successCount: 0, failedCount: 0, errors: ['Could not acquire initial sync lock'], syncedAt: DateTime.now());
           }
         } else if (_isSyncing) {
           return SyncResult(success: false, processedCount: 0, successCount: 0, failedCount: 0, errors: ['Initial sync already in progress'], syncedAt: DateTime.now());
         }
         ```
       - Keep `_isSyncing = true` in the try block and `_isSyncing = false` in the finally block for the fallback path.
       - In the `finally` block of `performInitialSync()`, add: `_coordinator?.releaseLock();` to release coordinator lock on both success and failure.
       - Apply the same pattern to `performDeltaSync()`: check coordinator lock before proceeding, release in finally.

    NOTE: Do NOT remove the `_isSyncing` field from either service. It serves as a fallback guard when the coordinator is not injected (e.g., background sync's standalone `SyncService` instance). The coordinator is the PRIMARY lock; `_isSyncing` is the SECONDARY fallback.
  </action>
  <verify>
    Run `flutter analyze lib/data/services/sync_service.dart lib/data/services/initial_sync_service.dart` -- no errors. Run `flutter test` to verify existing tests still pass (they don't inject a coordinator, so fallback path is exercised).
  </verify>
  <done>
    SyncService.processQueue() and startBackgroundSync() respect coordinator lock when injected. InitialSyncService.performInitialSync() and performDeltaSync() acquire/release coordinator lock when injected. Both services fall back to _isSyncing when coordinator is null. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with no errors on all modified files
2. `flutter test` passes (existing tests exercise fallback path without coordinator)
3. SyncCoordinator can be instantiated with AppSettingsService and initialized
4. SyncType enum has all 5 values: initial, manual, background, repository, masterDataResync
5. Lock acquire/release cycle works: acquire returns true, isLocked is true, release sets isLocked to false
6. Initial sync gate: acquireLock for manual type returns false when _initialSyncComplete is false
7. Cooldown: acquireLock returns false within 5 seconds of initial sync completion
8. Timeout recovery: lock held > 5 minutes is force-released on next acquisition attempt
9. Startup recovery: stale lock holder key is cleared on initialize()
</verification>

<success_criteria>
- SyncCoordinator exists with typed Completer-based lock, queue collapse flag, initial sync gating, cooldown, and timeout/startup recovery
- SyncType enum added to sync_models.dart
- AppSettingsService has cooldown timestamp and lock recovery keys
- SyncService and InitialSyncService accept optional SyncCoordinator and use it when present
- All existing tests pass without modification (fallback path)
- Zero analysis errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-sync-coordination/06-01-SUMMARY.md`
</output>
