---
phase: 06-sync-coordination
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/services/sync_coordinator.dart
  - lib/data/services/initial_sync_service.dart
  - lib/presentation/providers/sync_providers.dart
  - lib/presentation/widgets/sync/sync_progress_sheet.dart
autonomous: true
requirements:
  - CONF-05
gap_closure: true

must_haves:
  truths:
    - "Phase 2 (delta sync) and Phase 3 (triggerSync) execute without coordinator rejection during initial sync"
    - "After initial sync completes, home screen shows populated customer/pipeline/activity data"
    - "Initial sync populates all tables including transactional tables (customer, pipeline, activity)"
    - "The 5-second cooldown still fires for background/manual syncs triggered AFTER the initial sync flow"
  artifacts:
    - path: "lib/data/services/sync_coordinator.dart"
      provides: "acquireLock() accepts skipInitialSyncChecks flag that bypasses both the _initialSyncComplete gate and the cooldown gate"
      contains: "skipInitialSyncChecks"
    - path: "lib/data/services/initial_sync_service.dart"
      provides: "performDeltaSync() passes skipInitialSyncChecks: true to acquireLock"
      contains: "skipInitialSyncChecks: true"
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "triggerSync() accepts calledFromInitialSync flag; passes skipInitialSyncChecks: true to acquireLock when set"
      contains: "calledFromInitialSync"
    - path: "lib/presentation/widgets/sync/sync_progress_sheet.dart"
      provides: "Calls markInitialSyncComplete() after Phase 3 (not before Phase 2), passes calledFromInitialSync: true to triggerSync"
      contains: "calledFromInitialSync: true"
  key_links:
    - from: "lib/presentation/widgets/sync/sync_progress_sheet.dart"
      to: "lib/data/services/sync_coordinator.dart"
      via: "performDeltaSync and triggerSync both call acquireLock with skipInitialSyncChecks: true during initial sync flow"
      pattern: "skipInitialSyncChecks"
    - from: "lib/presentation/widgets/sync/sync_progress_sheet.dart"
      to: "lib/data/services/sync_coordinator.dart"
      via: "coordinator.markInitialSyncComplete() called after Phase 3 completes"
      pattern: "markInitialSyncComplete"
---

<objective>
Fix the cooldown-gate blocker in the initial sync flow: Phases 2 and 3 are rejected by SyncCoordinator because the 5-second cooldown fires the moment markInitialSyncComplete() sets _initialSyncCompletedAt, blocking Phase 2 and Phase 3 from acquiring the lock milliseconds later.

Purpose: RESEARCH.md (lines 284-288) specifies that Phase 2 and Phase 3 must execute within the initial sync orchestration, before the cooldown applies. The fix adds a `skipInitialSyncChecks` bypass flag to `acquireLock()` that Phase 2 and Phase 3 use when called from the initial sync flow. markInitialSyncComplete() is called AFTER Phase 3 (not before Phase 2), so the cooldown only starts after the full initial sync sequence completes.

Output: Four files modified. Phase 2 (performDeltaSync) and Phase 3 (triggerSync) pass the coordinator gate during initial sync. The cooldown continues to protect against background sync racing in from external triggers after initial sync finishes.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-sync-coordination/06-UAT.md
@.planning/phases/06-sync-coordination/06-04-SUMMARY.md
@.planning/phases/06-sync-coordination/06-RESEARCH.md
@.planning/debug/sync-progress-phase2-3-rejected.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skipInitialSyncChecks flag to SyncCoordinator.acquireLock() and thread it through performDeltaSync() and triggerSync()</name>
  <files>
    lib/data/services/sync_coordinator.dart
    lib/data/services/initial_sync_service.dart
    lib/presentation/providers/sync_providers.dart
  </files>
  <action>
**Why this approach:** RESEARCH.md lines 284-288 states Phase 2 and Phase 3 must execute within the initial sync orchestration before the cooldown starts. The 5-second cooldown fires immediately when markInitialSyncComplete() sets _initialSyncCompletedAt, so Phase 2 and Phase 3 (called milliseconds later) are rejected. The fix: add a bypass flag so that syncs explicitly called from the initial sync flow skip both the `_initialSyncComplete` gate AND the cooldown gate. markInitialSyncComplete() is moved to AFTER Phase 3 in the sheet (Task 2), so the cooldown begins only after the full 3-phase sequence.

**Change 1 — lib/data/services/sync_coordinator.dart:**

Add `bool skipInitialSyncChecks = false` parameter to `acquireLock()`. When true, skip both the gate at line 121 and the cooldown check at lines 128-139.

Current signature (line 78):
```dart
Future<bool> acquireLock({required SyncType type}) async {
```

New signature:
```dart
Future<bool> acquireLock({required SyncType type, bool skipInitialSyncChecks = false}) async {
```

Current gate block (lines 120-126):
```dart
    // Gate regular sync until initial sync completes
    if (!_initialSyncComplete && type != SyncType.initial) {
      _log.debug(
        'sync.coordinator | Rejected $type sync (initial sync not complete)',
      );
      return false;
    }
```

Replace with:
```dart
    // Gate regular sync until initial sync completes
    // (skipInitialSyncChecks=true is used by Phase 2/3 of the initial sync orchestration)
    if (!skipInitialSyncChecks && !_initialSyncComplete && type != SyncType.initial) {
      _log.debug(
        'sync.coordinator | Rejected $type sync (initial sync not complete)',
      );
      return false;
    }
```

Current cooldown block (lines 128-139):
```dart
    // Cooldown check after initial sync
    if (_initialSyncCompletedAt != null && type != SyncType.initial) {
      final elapsed = DateTime.now().difference(_initialSyncCompletedAt!);
      if (elapsed < _cooldownDuration) {
        final remainingMs =
            (_cooldownDuration - elapsed).inMilliseconds;
        _log.debug(
          'sync.coordinator | Rejected $type sync (cooldown active, ${remainingMs}ms left)',
        );
        return false;
      }
    }
```

Replace with:
```dart
    // Cooldown check after initial sync
    // (skipInitialSyncChecks=true bypasses this for Phase 2/3 of initial sync orchestration)
    if (!skipInitialSyncChecks && _initialSyncCompletedAt != null && type != SyncType.initial) {
      final elapsed = DateTime.now().difference(_initialSyncCompletedAt!);
      if (elapsed < _cooldownDuration) {
        final remainingMs =
            (_cooldownDuration - elapsed).inMilliseconds;
        _log.debug(
          'sync.coordinator | Rejected $type sync (cooldown active, ${remainingMs}ms left)',
        );
        return false;
      }
    }
```

**Change 2 — lib/data/services/initial_sync_service.dart:**

In `performDeltaSync()`, change the `acquireLock` call at line 968 to pass `skipInitialSyncChecks: true`:

Current (line 968):
```dart
      if (!await _coordinator.acquireLock(type: SyncType.masterDataResync)) {
```

New:
```dart
      if (!await _coordinator.acquireLock(type: SyncType.masterDataResync, skipInitialSyncChecks: true)) {
```

Add a comment above it explaining the flag:
```dart
      // skipInitialSyncChecks: true — performDeltaSync is called as Phase 2 of the
      // initial sync orchestration (from SyncProgressSheet) while _initialSyncComplete
      // is still false and before markInitialSyncComplete() sets the cooldown timestamp.
      if (!await _coordinator.acquireLock(type: SyncType.masterDataResync, skipInitialSyncChecks: true)) {
```

**Change 3 — lib/presentation/providers/sync_providers.dart:**

In `SyncNotifier.triggerSync()`, add `bool calledFromInitialSync = false` parameter. When true, pass `skipInitialSyncChecks: true` to `acquireLock()`.

Current signature (line 201):
```dart
  Future<void> triggerSync() async {
```

New signature:
```dart
  Future<void> triggerSync({bool calledFromInitialSync = false}) async {
```

Current acquireLock call (line 211):
```dart
    final acquired = await _coordinator.acquireLock(type: SyncType.manual);
```

New:
```dart
    final acquired = await _coordinator.acquireLock(
      type: SyncType.manual,
      skipInitialSyncChecks: calledFromInitialSync,
    );
```

Add a comment above:
```dart
    // skipInitialSyncChecks: Phase 3 of initial sync calls triggerSync before
    // markInitialSyncComplete() runs, so the coordinator gate and cooldown must be bypassed.
    final acquired = await _coordinator.acquireLock(
      type: SyncType.manual,
      skipInitialSyncChecks: calledFromInitialSync,
    );
```

The recursive `triggerSync()` call in the finally block (line 253) does NOT pass `calledFromInitialSync: true` — it is a follow-up queued sync triggered after initial sync is complete, so it should go through the normal gate.
  </action>
  <verify>
1. Run `flutter analyze` — no new errors or warnings.
2. Grep to confirm the flag exists in coordinator:
   `grep -n "skipInitialSyncChecks" lib/data/services/sync_coordinator.dart`
   Should show matches in acquireLock signature and both gate blocks.
3. Grep to confirm performDeltaSync passes it:
   `grep -n "skipInitialSyncChecks" lib/data/services/initial_sync_service.dart`
   Should show match on the acquireLock call in performDeltaSync.
4. Grep to confirm triggerSync accepts calledFromInitialSync:
   `grep -n "calledFromInitialSync\|skipInitialSyncChecks" lib/presentation/providers/sync_providers.dart`
   Should show both the parameter declaration and the acquireLock call.
5. Run `flutter test` — existing tests continue to pass.
  </verify>
  <done>
acquireLock() has skipInitialSyncChecks flag. performDeltaSync() passes it. triggerSync() accepts calledFromInitialSync and threads it through. The changes compile and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SyncProgressSheet to pass calledFromInitialSync to triggerSync and move markInitialSyncComplete() to after Phase 3</name>
  <files>lib/presentation/widgets/sync/sync_progress_sheet.dart</files>
  <action>
**Why:** Task 1 wires the bypass flags. This task uses them correctly in the orchestration:
- Phase 2 (`performDeltaSync`) already has `skipInitialSyncChecks: true` baked in — no sheet change needed for Phase 2.
- Phase 3 (`triggerSync`) needs `calledFromInitialSync: true` to pass its gate.
- `markInitialSyncComplete()` must be called AFTER Phase 3 (not before Phase 2) so the 5-second cooldown starts AFTER the full 3-phase sequence completes. This is the key fix for the checker's blocker.

**In `lib/presentation/widgets/sync/sync_progress_sheet.dart`, inside `_performSingleSyncAttempt()`:**

Step A — Remove any `markInitialSyncComplete()` call that was before Phase 2 (the original Task 1 plan that this revision is replacing). If it was already added during a previous executor attempt, remove it now.

Step B — Update the Phase 3 triggerSync call. Current (around line 200):
```dart
        await ref.read(syncNotifierProvider.notifier).triggerSync();
```

Change to:
```dart
        await ref.read(syncNotifierProvider.notifier).triggerSync(calledFromInitialSync: true);
```

Step C — Add `markInitialSyncComplete()` call AFTER Phase 3 completes and BEFORE `return true`. The insertion point is after the Phase 3 try/catch block and before `return true` (around line 206):

Current (around lines 198-207):
```dart
      AppLogger.instance.info('ui.sync | Starting user data pull...');
      try {
        await ref.read(syncNotifierProvider.notifier).triggerSync();
        AppLogger.instance.info('ui.sync | User data pull complete');
      } catch (e) {
        AppLogger.instance.warning('ui.sync | User data pull error: $e');
        // Don't fail the whole sync for user data errors - they can retry later
      }

      return true;
```

Change to:
```dart
      AppLogger.instance.info('ui.sync | Starting user data pull...');
      try {
        await ref.read(syncNotifierProvider.notifier).triggerSync(calledFromInitialSync: true);
        AppLogger.instance.info('ui.sync | User data pull complete');
      } catch (e) {
        AppLogger.instance.warning('ui.sync | User data pull error: $e');
        // Don't fail the whole sync for user data errors - they can retry later
      }

      // Mark initial sync complete AFTER all three phases (Phase 1 master data,
      // Phase 2 delta sync, Phase 3 user data pull). This ensures the 5-second
      // cooldown in SyncCoordinator only starts after the full sequence finishes,
      // not between phases. See sync_coordinator.dart _cooldownDuration.
      final coordinator = ref.read(syncCoordinatorProvider);
      await coordinator.markInitialSyncComplete();
      AppLogger.instance.info('ui.sync | All phases complete — initial sync marked done, cooldown started');

      return true;
```

`syncCoordinatorProvider` is already available from the `sync_providers.dart` import that is already in this file (used for `syncNotifierProvider`).

Do NOT remove the existing `coordinator.markInitialSyncComplete()` calls in `login_screen.dart` or `home_screen.dart`. Those are now redundant double-calls (harmless) and serve as safety nets for code paths that bypass the sheet.
  </action>
  <verify>
1. Run `flutter analyze` — no new errors or warnings.
2. Grep to confirm triggerSync is called with calledFromInitialSync:
   `grep -n "calledFromInitialSync" lib/presentation/widgets/sync/sync_progress_sheet.dart`
   Should show match on the triggerSync call.
3. Grep to confirm markInitialSyncComplete is called AFTER the triggerSync try/catch:
   `grep -n "markInitialSyncComplete\|triggerSync\|return true" lib/presentation/widgets/sync/sync_progress_sheet.dart`
   Output must show triggerSync BEFORE markInitialSyncComplete BEFORE return true (in line number order).
4. Confirm no markInitialSyncComplete call exists before Phase 2 (before the Phase 2 setState block):
   Read lines 148-210 of the modified file and verify ordering.
5. Run `flutter test` — existing tests continue to pass.
  </verify>
  <done>
sync_progress_sheet.dart calls triggerSync(calledFromInitialSync: true) for Phase 3, and calls markInitialSyncComplete() after Phase 3 completes. The ordering is: Phase 1 master sync → Phase 2 delta sync (skipInitialSyncChecks bypasses gate) → Phase 3 user data pull (calledFromInitialSync bypasses gate and cooldown) → markInitialSyncComplete() (starts cooldown). All three phases execute without coordinator rejection during initial sync.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `flutter analyze` passes with no new errors
2. Execution order in `_performSingleSyncAttempt` is: performInitialSync → performDeltaSync → triggerSync(calledFromInitialSync: true) → markInitialSyncComplete()
3. `grep -rn "skipInitialSyncChecks"` finds matches in sync_coordinator.dart, initial_sync_service.dart, and sync_providers.dart
4. `grep -n "calledFromInitialSync"` finds matches in sync_providers.dart and sync_progress_sheet.dart
5. `flutter test` passes (smoke test)
6. Logic verification: _initialSyncComplete is false for the entire sheet execution. Phase 2 bypasses via skipInitialSyncChecks. Phase 3 bypasses via calledFromInitialSync→skipInitialSyncChecks. markInitialSyncComplete() runs last, setting _initialSyncComplete=true and _initialSyncCompletedAt=now(). The 5-second cooldown now correctly blocks external background sync triggers that fire in the 5 seconds after initial sync, while not blocking Phases 2 and 3.
</verification>

<success_criteria>
- acquireLock() has skipInitialSyncChecks parameter; both gate checks are wrapped with `!skipInitialSyncChecks &&`
- performDeltaSync() passes skipInitialSyncChecks: true to acquireLock
- triggerSync() accepts calledFromInitialSync parameter and passes it to acquireLock as skipInitialSyncChecks
- sync_progress_sheet.dart calls triggerSync(calledFromInitialSync: true) and calls markInitialSyncComplete() AFTER Phase 3 (not before Phase 2)
- Phase 2 (SyncType.masterDataResync) passes the coordinator during initial sync
- Phase 3 (SyncType.manual via triggerSync) passes both the _initialSyncComplete gate and the cooldown gate during initial sync
- The 5-second cooldown still activates normally for background/manual syncs triggered after the initial sync flow finishes
- All 3 UAT gaps (tests 2, 3, 8) root cause addressed
- No regressions: login_screen.dart and home_screen.dart safety-net markInitialSyncComplete() calls remain untouched
</success_criteria>

<output>
After completion, create `.planning/phases/06-sync-coordination/06-05-SUMMARY.md`
</output>
