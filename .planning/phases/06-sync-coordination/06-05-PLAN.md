---
phase: 06-sync-coordination
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/presentation/widgets/sync/sync_progress_sheet.dart
autonomous: true
requirements:
  - CONF-05
gap_closure: true

must_haves:
  truths:
    - "Phase 2 (delta sync) and Phase 3 (triggerSync) execute without coordinator rejection during initial sync"
    - "After initial sync completes, home screen shows populated customer/pipeline/activity data"
    - "Initial sync populates all tables including transactional tables (customer, pipeline, activity)"
  artifacts:
    - path: "lib/presentation/widgets/sync/sync_progress_sheet.dart"
      provides: "markInitialSyncComplete called after Phase 1, before Phase 2"
      contains: "coordinator.markInitialSyncComplete"
  key_links:
    - from: "lib/presentation/widgets/sync/sync_progress_sheet.dart"
      to: "lib/data/services/sync_coordinator.dart"
      via: "ref.read(syncCoordinatorProvider).markInitialSyncComplete() in _performSingleSyncAttempt"
      pattern: "syncCoordinatorProvider.*markInitialSyncComplete"
---

<objective>
Fix the root cause of UAT tests 2, 3, and 8 failing: SyncProgressSheet Phases 2 and 3 are rejected by the SyncCoordinator gate because markInitialSyncComplete() is not called until AFTER the sheet returns, but Phase 2/3 run INSIDE the sheet.

Purpose: The coordinator gate at sync_coordinator.dart:121 rejects any non-initial SyncType when _initialSyncComplete is false. Phase 2 uses SyncType.masterDataResync and Phase 3 uses SyncType.manual — both hit this gate and silently fail, leaving transactional tables empty.
Output: sync_progress_sheet.dart patched so markInitialSyncComplete() is called after Phase 1 succeeds but before Phase 2 starts. Phase 2 and 3 will then pass the coordinator gate and populate all tables.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-sync-coordination/06-UAT.md
@.planning/phases/06-sync-coordination/06-04-SUMMARY.md
@.planning/debug/sync-progress-phase2-3-rejected.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Call markInitialSyncComplete in SyncProgressSheet after Phase 1, before Phase 2</name>
  <files>lib/presentation/widgets/sync/sync_progress_sheet.dart</files>
  <action>
In `lib/presentation/widgets/sync/sync_progress_sheet.dart`, inside `_performSingleSyncAttempt()`, add a call to `coordinator.markInitialSyncComplete()` immediately after Phase 1 succeeds and before the Phase 2 block starts.

The exact insertion point is in `_performSingleSyncAttempt()`, after the Phase 1 failure check (the `if (!result.success && result.errors.isNotEmpty)` block that returns false) and before the Phase 2 setState block.

Currently (around lines 150-163):
```dart
      AppLogger.instance.info('ui.sync | Master data sync result: success=${result.success}, processed=${result.processedCount}, errors=${result.errors}');

      if (!result.success && result.errors.isNotEmpty) {
        if (mounted) {
          setState(() {
            _error = result.errors.first;
          });
        }
        return false;
      }

      // Phase 2: Delta sync for transactional tables
      if (mounted) {
        setState(() {
          _progress = InitialSyncProgress(
```

Change to:
```dart
      AppLogger.instance.info('ui.sync | Master data sync result: success=${result.success}, processed=${result.processedCount}, errors=${result.errors}');

      if (!result.success && result.errors.isNotEmpty) {
        if (mounted) {
          setState(() {
            _error = result.errors.first;
          });
        }
        return false;
      }

      // Mark initial sync complete after Phase 1 so Phase 2/3 pass the coordinator gate.
      // The coordinator gate at sync_coordinator.dart:121 rejects non-initial SyncTypes
      // when _initialSyncComplete is false. Phase 2 (masterDataResync) and Phase 3 (manual)
      // both need this flag set BEFORE they call acquireLock — not after the sheet returns.
      final coordinator = ref.read(syncCoordinatorProvider);
      await coordinator.markInitialSyncComplete();
      AppLogger.instance.info('ui.sync | Phase 1 complete — marked initial sync done, Phase 2/3 gate cleared');

      // Phase 2: Delta sync for transactional tables
      if (mounted) {
        setState(() {
          _progress = InitialSyncProgress(
```

Also add the import for `syncCoordinatorProvider` if it is not already imported in this file. Check the existing imports: `sync_providers.dart` is already imported (used for `syncNotifierProvider` on the triggerSync line), so `syncCoordinatorProvider` is available from the same import.

Do NOT remove the existing `coordinator.markInitialSyncComplete()` call in `login_screen.dart` (lines 53-54). That call is now redundant (the flag is already set by the sheet), but it is harmless as a double-call and provides a safety net for any code path that bypasses the sheet. Leave it as-is.

Do NOT remove the `coordinator.markInitialSyncComplete()` call in `home_screen.dart` (lines 56-57). Same reasoning — harmless double-call, keep as safety net.
  </action>
  <verify>
1. Run `flutter analyze` — no new errors or warnings.
2. Grep to confirm coordinator call is now in sync_progress_sheet.dart:
   `grep -n "coordinator.markInitialSyncComplete\|syncCoordinatorProvider" lib/presentation/widgets/sync/sync_progress_sheet.dart`
   Should show matches for both `syncCoordinatorProvider` and `coordinator.markInitialSyncComplete`.
3. Verify the call site is between Phase 1 result check and Phase 2 setState block by reading lines 148-175 of the modified file.
4. Run `flutter test` — existing tests continue to pass.
  </verify>
  <done>
sync_progress_sheet.dart calls coordinator.markInitialSyncComplete() after Phase 1 succeeds and before Phase 2 starts. Phase 2 (performDeltaSync with SyncType.masterDataResync) and Phase 3 (triggerSync with SyncType.manual) will now pass the coordinator gate and execute fully, populating customer/pipeline/activity tables during initial sync.
  </done>
</task>

</tasks>

<verification>
After the task:
1. `flutter analyze` passes with no new errors
2. `grep -n "markInitialSyncComplete" lib/presentation/widgets/sync/sync_progress_sheet.dart` shows a match inside `_performSingleSyncAttempt`
3. The match appears between the Phase 1 result check and the Phase 2 setState block (line order confirms placement)
4. `flutter test` passes (smoke test)
</verification>

<success_criteria>
- sync_progress_sheet.dart calls markInitialSyncComplete() after Phase 1 success, before Phase 2 starts
- Phase 2 (SyncType.masterDataResync) passes the coordinator gate during initial sync
- Phase 3 (SyncType.manual via triggerSync) passes the coordinator gate during initial sync
- All 3 UAT gaps (tests 2, 3, 8) root cause addressed by this single-line insertion
- No regressions: login_screen.dart and home_screen.dart safety-net calls remain untouched
</success_criteria>

<output>
After completion, create `.planning/phases/06-sync-coordination/06-05-SUMMARY.md`
</output>
