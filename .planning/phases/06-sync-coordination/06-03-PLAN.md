---
phase: 06-sync-coordination
plan: 03
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - lib/presentation/providers/sync_providers.dart
  - lib/data/services/background_sync_service.dart
  - lib/main.dart
autonomous: true
requirements:
  - CONF-05

must_haves:
  truths:
    - "All sync entry points go through SyncCoordinator lock"
    - "SyncNotifier.triggerSync() acquires coordinator lock before push+pull"
    - "Toast notification appears when sync triggers while another is running"
    - "Queued sync executes after current sync completes (collapse multiple into one)"
    - "Background sync (WorkManager) checks initial sync completion before proceeding"
    - "SyncCoordinator is initialized on app startup with stale lock recovery"
    - "Push-then-pull serialization is preserved within a single lock acquisition"
  artifacts:
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "SyncCoordinator provider and coordinator-integrated SyncNotifier"
      contains: "syncCoordinatorProvider"
    - path: "lib/data/services/background_sync_service.dart"
      provides: "Background sync that checks initial sync completion gate"
      contains: "hasInitialSyncCompleted"
  key_links:
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/services/sync_coordinator.dart"
      via: "syncCoordinatorProvider wraps SyncCoordinator singleton"
      pattern: "syncCoordinatorProvider"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/services/sync_service.dart"
      via: "SyncNotifier uses coordinator for lock before calling processQueue"
      pattern: "acquireLock"
    - from: "lib/data/services/background_sync_service.dart"
      to: "lib/data/services/app_settings_service.dart"
      via: "background callback checks initial sync flag before processing"
      pattern: "initial_sync_completed"
---

<objective>
Wire SyncCoordinator into all sync entry points: providers, SyncNotifier, background sync, and app startup.

Purpose: The SyncCoordinator created in plan 01 needs to be injected into all sync callers. This plan creates the Riverpod provider, updates SyncNotifier.triggerSync() to acquire/release the coordinator lock (with queued execution and toast notification), updates the background sync callback to check initial sync completion, and initializes the coordinator on app startup.

Output: All 7 sync entry points are coordinated through a single lock. Toast notifications inform users when sync is queued. Background sync respects initial sync gate.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-sync-coordination/06-RESEARCH.md
@.planning/phases/06-sync-coordination/06-01-SUMMARY.md
@lib/presentation/providers/sync_providers.dart
@lib/data/services/background_sync_service.dart
@lib/data/services/sync_coordinator.dart
@lib/main.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncCoordinator provider and update SyncNotifier with coordinated sync</name>
  <files>
    lib/presentation/providers/sync_providers.dart
  </files>
  <action>
    1. Add import for `sync_coordinator.dart` at the top of `sync_providers.dart`.

    2. Add `syncCoordinatorProvider` as a `Provider<SyncCoordinator>`:
       ```dart
       /// Provider for the sync coordinator (central lock for all sync operations).
       final syncCoordinatorProvider = Provider<SyncCoordinator>((ref) {
         final appSettings = ref.watch(appSettingsServiceProvider);
         return SyncCoordinator(appSettingsService: appSettings);
       });
       ```

    3. Update `syncServiceProvider` to inject the coordinator:
       - Read `syncCoordinatorProvider` and pass to SyncService constructor:
         ```dart
         final coordinator = ref.watch(syncCoordinatorProvider);
         ```
       - Add `coordinator: coordinator` to the SyncService constructor call.

    4. Update `initialSyncServiceProvider` to inject the coordinator:
       - Read `syncCoordinatorProvider` and pass to InitialSyncService constructor.

    5. Update `SyncNotifier` class:
       - Add `SyncCoordinator _coordinator` field.
       - Update constructor to accept `SyncCoordinator coordinator` parameter.
       - Rewrite `triggerSync()` to use coordinated execution:
         ```dart
         Future<void> triggerSync() async {
           await _connectivityService.ensureInitialized();

           if (!_connectivityService.isConnected) {
             state = AsyncValue.error('Device is offline', StackTrace.current);
             return;
           }

           // Attempt to acquire the coordinator lock
           final acquired = await _coordinator.acquireLock(type: SyncType.manual);
           if (!acquired) {
             AppLogger.instance.info('sync.coordinator | Manual sync queued (lock held)');
             // Don't set error state -- the sync is queued, not failed
             return;
           }

           state = const AsyncValue.loading();
           try {
             // Step 1: Push - upload local changes to Supabase
             AppLogger.instance.debug('sync.queue | Starting push sync...');
             final pushResult = await _syncService.processQueue();
             AppLogger.instance.debug('sync.queue | Push sync complete: ${pushResult.successCount} uploaded');

             // Step 2: Sync pending photos
             AppLogger.instance.debug('sync.queue | Starting photo sync...');
             await _syncPhotos();
             AppLogger.instance.debug('sync.queue | Photo sync complete');

             // Step 3: Sync pending audit logs
             AppLogger.instance.debug('sync.queue | Starting audit log sync...');
             await _syncAuditLogs();
             AppLogger.instance.debug('sync.queue | Audit log sync complete');

             // Step 4: Pull - download changes from Supabase
             AppLogger.instance.debug('sync.queue | Starting pull sync...');
             await _pullFromRemote();
             AppLogger.instance.debug('sync.queue | Pull sync complete');

             state = AsyncValue.data(pushResult);
           } catch (e, st) {
             AppLogger.instance.error('sync.queue | Sync error: $e');
             state = AsyncValue.error(e, st);
           } finally {
             _coordinator.releaseLock();

             // Execute queued sync if pending (collapse multiple into one)
             if (_coordinator.consumeQueuedSync()) {
               AppLogger.instance.info('sync.coordinator | Executing queued sync');
               // Small delay to avoid tight loop
               await Future.delayed(const Duration(milliseconds: 200));
               // Recursive call -- safe because lock is released
               await triggerSync();
             }
           }
         }
         ```

    6. Update `syncNotifierProvider` to pass coordinator:
       - Read `syncCoordinatorProvider` and pass to SyncNotifier constructor.

    7. Update `initializeSyncServices()` function:
       - Read `syncCoordinatorProvider` and call `await coordinator.initialize()` to perform startup lock recovery and load initial sync state.
       - This should happen BEFORE `syncService.startBackgroundSync()`.

    8. Add a helper method for showing toast from providers (or document that toast is shown at the UI layer):
       - Since providers don't have BuildContext, the toast notification ("Sync sedang berjalan -- permintaan Anda diantrikan") needs to be triggered at the UI layer.
       - Add a `Stream<String> get toastStream` to SyncCoordinator (or use a simple callback pattern).
       - Actually, the simpler approach: In responsive_shell.dart's sync trigger (the manual sync button), check coordinator state and show toast there. And in repository-triggered syncs (which use SyncService.triggerSync debounce), the queuing is silent per user decision ("Coordination issues are silent to user -- logged to Talker only"). The toast is only for user-initiated manual sync.
       - So the toast logic belongs in the UI layer, not in the provider. The SyncNotifier.triggerSync() returning without error when queued is sufficient. The responsive_shell.dart manual sync button should check coordinator state before triggering.
       - Update the manual sync trigger in responsive_shell.dart: before calling `syncNotifierProvider.notifier.triggerSync()`, check `ref.read(syncCoordinatorProvider).isLocked`. If locked, show snackbar "Sinkronisasi sedang berjalan -- permintaan Anda diantrikan" and set `_coordinator.setQueuedSyncPending()` to ensure the sync runs after current one completes. If not locked, proceed normally.
       - NOTE: responsive_shell.dart is also modified in plan 02 for the long-press re-sync check. Both changes are to different code paths (long-press vs regular tap), so they target different lines and won't conflict.
  </action>
  <verify>
    Run `flutter analyze lib/presentation/providers/sync_providers.dart` -- no errors.
  </verify>
  <done>
    syncCoordinatorProvider exists. SyncNotifier.triggerSync() acquires/releases coordinator lock with queued execution. SyncService and InitialSyncService receive coordinator via providers. initializeSyncServices calls coordinator.initialize(). Manual sync shows toast when queued.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update background sync and app startup for coordinator integration</name>
  <files>
    lib/data/services/background_sync_service.dart
    lib/main.dart
  </files>
  <action>
    1. Update `lib/data/services/background_sync_service.dart` `callbackDispatcher()`:
       - After checking auth session (step 3) and before checking background sync enabled (step 5), add initial sync completion check:
         ```dart
         // 3.5. Check if initial sync has completed (must have reference data before pushing)
         final appSettings = AppSettingsService(db);
         final initialSyncDone = await appSettings.hasInitialSyncCompleted();
         if (!initialSyncDone) {
           // Skip -- initial sync must complete first via foreground app
           await db.close();
           return true;
         }
         ```
       - Move the `AppSettingsService` creation earlier (currently AppSettingsService is not used in background callback, but it reads settings directly from DB). Create an `AppSettingsService(db)` instance.
       - The background sync already reads `background_sync_enabled` directly from DB. Replace that raw query with `appSettings.get('background_sync_enabled')` for consistency.
       - Note: Background sync runs in a separate FlutterEngine and CANNOT share the in-memory coordinator lock. The `hasInitialSyncCompleted()` check via persisted DB flag is the coordination mechanism for background sync. This is acceptable because: (a) push operations are idempotent (upsert), (b) SQLite WAL handles concurrent access, (c) background sync is push-only.

    2. Update `lib/main.dart`:
       - The app startup already calls `initializeSyncServices()`. Verify this is the case. The coordinator initialization (added in Task 1 to `initializeSyncServices()`) will run automatically.
       - If `main.dart` does any initial sync checking directly, ensure it defers to the coordinator state.
       - Check if there's a schema version comparison that could trigger initial sync re-run. Per user decision: "Initial sync gate also applies after schema migration if new sync tables were added." Add a comment/TODO for this since the actual schema migration detection is a future concern (the mechanism is: store schema version at initial sync time, compare on startup, reset if newer).
       - Add to `initializeSyncServices()` or a nearby startup function:
         ```dart
         // TODO(Phase 6): Schema migration detection for re-triggering initial sync
         // When schemaVersion at initial sync time < current schemaVersion AND
         // new migration includes sync-relevant tables, reset initial sync flag.
         ```
  </action>
  <verify>
    Run `flutter analyze lib/data/services/background_sync_service.dart lib/main.dart` -- no errors.
    Run `flutter analyze` on the full project to verify no cross-file issues.
    Run `flutter test` to verify all existing tests still pass.
  </verify>
  <done>
    Background sync callback checks initial sync completion flag before processing queue. App startup initializes SyncCoordinator with stale lock recovery. All 7 sync entry points are now coordinated: (1) SyncService.processQueue checks coordinator lock, (2) SyncService.triggerSync checks coordinator lock, (3) SyncService.startBackgroundSync checks coordinator lock, (4) SyncNotifier.triggerSync acquires/releases coordinator lock, (5) InitialSyncService.performInitialSync acquires/releases coordinator lock, (6) InitialSyncService.performDeltaSync acquires/releases coordinator lock, (7) background sync checks persisted initial sync flag.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes on all modified files
2. `flutter test` passes (all existing tests)
3. syncCoordinatorProvider exists and returns SyncCoordinator
4. SyncNotifier.triggerSync acquires lock, runs push+pull, releases lock, then checks queued
5. Background sync checks hasInitialSyncCompleted before processing
6. Manual sync button shows toast when coordinator lock is held
7. Coordinator is initialized on app startup via initializeSyncServices
8. Push-then-pull serialization is preserved (push completes before pull starts, both within single lock acquisition)
</verification>

<success_criteria>
- All 7 sync entry points are coordinated through SyncCoordinator
- SyncNotifier acquires/releases lock with queued execution and collapse
- Background sync respects initial sync gate via persisted flag
- Toast notification shown for user-initiated sync when another sync is running
- All tests pass, zero analysis errors
- Push-then-pull is serialized within a single lock hold
</success_criteria>

<output>
After completion, create `.planning/phases/06-sync-coordination/06-03-SUMMARY.md`
</output>
