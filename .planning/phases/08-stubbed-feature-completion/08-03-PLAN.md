---
phase: 08-stubbed-feature-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/dtos/activity_dtos.dart
  - lib/data/dtos/activity_dtos.freezed.dart
  - lib/data/dtos/activity_dtos.g.dart
  - lib/domain/repositories/activity_repository.dart
  - lib/data/repositories/activity_repository_impl.dart
  - lib/presentation/providers/activity_providers.dart
  - lib/config/routes/route_names.dart
  - lib/config/routes/app_router.dart
  - lib/presentation/screens/activity/activity_form_screen.dart
  - lib/presentation/screens/activity/activity_detail_screen.dart
autonomous: true
requirements:
  - FEAT-04

must_haves:
  truths:
    - "User tapping Edit button on activity detail AppBar navigates to activity form in edit mode"
    - "Activity form in edit mode shows all fields pre-filled with existing activity data"
    - "User can update activity fields and save changes successfully"
    - "Completed activities only allow editing notes/summary (other fields locked)"
    - "Activity edit is queued for offline sync with update operation"
    - "Edit route /home/activities/:id/edit exists and works"
  artifacts:
    - path: "lib/data/dtos/activity_dtos.dart"
      provides: "ActivityUpdateDto for partial activity updates"
      contains: "ActivityUpdateDto"
    - path: "lib/domain/repositories/activity_repository.dart"
      provides: "updateActivity method signature"
      contains: "updateActivity"
    - path: "lib/data/repositories/activity_repository_impl.dart"
      provides: "updateActivity implementation with sync queue"
      contains: "updateActivity"
    - path: "lib/config/routes/app_router.dart"
      provides: "Activity edit route /home/activities/:id/edit"
      contains: "activityEdit"
    - path: "lib/presentation/screens/activity/activity_form_screen.dart"
      provides: "Edit mode with activityId parameter and pre-filled fields"
      contains: "activityId"
    - path: "lib/presentation/screens/activity/activity_detail_screen.dart"
      provides: "Edit button navigation to edit route"
      contains: "activityEdit"
  key_links:
    - from: "lib/presentation/screens/activity/activity_detail_screen.dart"
      to: "lib/config/routes/app_router.dart"
      via: "context.pushNamed(RouteNames.activityEdit)"
      pattern: "activityEdit"
    - from: "lib/presentation/screens/activity/activity_form_screen.dart"
      to: "lib/presentation/providers/activity_providers.dart"
      via: "updateActivity notifier call"
      pattern: "updateActivity"
    - from: "lib/data/repositories/activity_repository_impl.dart"
      to: "sync_service"
      via: "queueOperation with SyncOperation.update"
      pattern: "SyncOperation\\.update"
---

<objective>
Implement activity editing: create ActivityUpdateDto, add updateActivity to repository, add edit route, and modify ActivityFormScreen to support edit mode with pre-filled fields and field locking for completed activities.

Purpose: Enable sales reps to edit scheduled and completed activities (completed: only notes), fixing the biggest missing CRUD operation in the activity domain.
Output: Full activity edit flow from detail screen edit button through form submission to sync queue.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stubbed-feature-completion/08-RESEARCH.md

@lib/data/dtos/activity_dtos.dart
@lib/domain/repositories/activity_repository.dart
@lib/data/repositories/activity_repository_impl.dart
@lib/data/datasources/local/activity_local_data_source.dart
@lib/presentation/providers/activity_providers.dart
@lib/presentation/screens/activity/activity_form_screen.dart
@lib/presentation/screens/activity/activity_detail_screen.dart
@lib/config/routes/app_router.dart
@lib/config/routes/route_names.dart
@lib/domain/entities/activity.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ActivityUpdateDto and add updateActivity to repository layer</name>
  <files>
    lib/data/dtos/activity_dtos.dart
    lib/domain/repositories/activity_repository.dart
    lib/data/repositories/activity_repository_impl.dart
    lib/data/datasources/local/activity_local_data_source.dart
    lib/presentation/providers/activity_providers.dart
  </files>
  <action>
**1. ActivityUpdateDto** (lib/data/dtos/activity_dtos.dart):
Add a new `@freezed` class `ActivityUpdateDto` alongside the existing `ActivityCreateDto`:
```dart
@freezed
class ActivityUpdateDto with _$ActivityUpdateDto {
  const factory ActivityUpdateDto({
    String? activityTypeId,
    DateTime? scheduledDatetime,
    String? keyPersonId,
    String? summary,
    String? notes,
  }) = _ActivityUpdateDto;
}
```
All fields are optional since this is a partial update. Object type/ID and isImmediate are intentionally omitted (locked per decision). Run `dart run build_runner build --delete-conflicting-outputs` after adding the freezed class.

**2. Repository interface** (lib/domain/repositories/activity_repository.dart):
Add method signature:
```dart
Future<Result<Activity>> updateActivity(String id, ActivityUpdateDto dto);
```

**3. Repository implementation** (lib/data/repositories/activity_repository_impl.dart):
Add `updateActivity` implementation following the existing `executeActivity` or `rescheduleActivity` pattern:
- Build `ActivitiesCompanion` from the non-null DTO fields (only set fields that are provided)
- Always set `updatedAt: Value(DateTime.now())`
- Wrap in `_database.transaction()` for atomicity:
  1. Call `_localDataSource.updateActivity(id, companion)` — check if this method exists; if not, add a general `updateActivity(String id, ActivitiesCompanion companion)` to the local data source that does `(update(activities)..where((a) => a.id.equals(id))).write(companion)`
  2. Insert audit log with action 'EDITED' (follow existing `_insertHistoryLog` pattern if it exists)
  3. Queue sync operation: `SyncOperation.update` with full activity snapshot as payload (build using `ActivitySyncDto` format or match existing sync payload pattern from `createActivity`). Use `.toUtcIso8601()` for datetime fields.
- Call `unawaited(_syncService.triggerSync())` after transaction
- Return the updated activity via `_localDataSource.getActivityById(id)`
- Wrap in `runCatching()` per existing pattern

**4. Local data source update** (lib/data/datasources/local/activity_local_data_source.dart):
If no general `updateActivity(String id, ActivitiesCompanion companion)` method exists, add one. Check existing methods — there may be `updateActivityStatus` or similar that can guide the pattern.

**5. Provider/notifier update** (lib/presentation/providers/activity_providers.dart):
Add `updateActivity(String id, ActivityUpdateDto dto)` method to the appropriate notifier (likely `ActivityFormNotifier` or `ActivityListNotifier`). Follow the pattern of existing `createActivity` — call repository, handle Result, return success/failure. Look at how `createActivity` is defined and mirror it for update.

Run `dart run build_runner build --delete-conflicting-outputs` after all changes to regenerate freezed/generated files.
  </action>
  <verify>Run `dart run build_runner build --delete-conflicting-outputs` to generate freezed files. Run `flutter analyze` to verify no compilation errors. Verify ActivityUpdateDto class is generated, repository interface has updateActivity, implementation has the method with sync queue operation.</verify>
  <done>ActivityUpdateDto exists with optional fields (activityTypeId, scheduledDatetime, keyPersonId, summary, notes). Repository has updateActivity that writes to local DB, queues SyncOperation.update, and triggers sync. Notifier has updateActivity method for UI to call.</done>
</task>

<task type="auto">
  <name>Task 2: Add edit route and modify ActivityFormScreen for edit mode</name>
  <files>
    lib/config/routes/route_names.dart
    lib/config/routes/app_router.dart
    lib/presentation/screens/activity/activity_form_screen.dart
    lib/presentation/screens/activity/activity_detail_screen.dart
  </files>
  <action>
**1. Route name** (lib/config/routes/route_names.dart):
Add `static const String activityEdit = 'activity-edit';` in the ACTIVITY ROUTES section.
Add `static const String activityEdit = '/home/activities/:id/edit';` in RoutePaths.

**2. Route definition** (lib/config/routes/app_router.dart):
Add an `edit` subroute under the existing `activities/:id` route. Currently the `:id` route has no children — add:
```dart
GoRoute(
  path: ':id',
  name: RouteNames.activityDetail,
  parentNavigatorKey: _rootNavigatorKey,
  builder: (context, state) {
    final id = state.pathParameters['id']!;
    return ActivityDetailScreen(activityId: id);
  },
  routes: [
    GoRoute(
      path: 'edit',
      name: RouteNames.activityEdit,
      parentNavigatorKey: _rootNavigatorKey,
      builder: (context, state) {
        final id = state.pathParameters['id']!;
        return ActivityFormScreen(activityId: id);
      },
    ),
  ],
),
```

**3. ActivityFormScreen edit mode** (lib/presentation/screens/activity/activity_form_screen.dart):
Add `activityId` optional parameter to the constructor:
```dart
final String? activityId;
const ActivityFormScreen({super.key, this.objectType, this.objectId, this.objectName, this.isImmediate = false, this.activityId});
```

Add an `_isEditMode` getter: `bool get _isEditMode => widget.activityId != null;`

In `initState`, if `_isEditMode`:
- Use `WidgetsBinding.instance.addPostFrameCallback` to load existing activity data from provider
- Call `ref.read(activityDetailProvider(widget.activityId!))` or the appropriate provider to get the activity
- Pre-fill all form controllers and state variables from the loaded activity:
  - `_selectedObjectType` from activity.objectType (LOCKED — shown but not editable in edit mode)
  - `_selectedObjectId` from activity.objectId (LOCKED — shown but not editable in edit mode)
  - `_selectedActivityTypeId` from activity.activityTypeId
  - `_scheduledDate` from activity.scheduledDatetime
  - `_scheduledTime` from activity.scheduledDatetime
  - `_selectedKeyPersonId` from activity.keyPersonId
  - `_summaryController.text` from activity.summary
  - `_notesController.text` from activity.notes
- Use a `_dataLoaded` flag to prevent overwriting user edits on rebuild

**Field locking logic:**
- If `_isEditMode`:
  - Object type and object (customer/HVC/broker) dropdowns: Always DISABLED (shown as read-only)
  - `isImmediate` checkbox/flag: Always DISABLED
- If `_isEditMode` AND activity status is `completed` (check `activity.status` or `activity.executedAt != null`):
  - Activity type dropdown: DISABLED
  - Scheduled datetime pickers: DISABLED
  - Key person dropdown: DISABLED
  - Only `_summaryController` and `_notesController` remain editable

**Submit handler modification:**
In the form submit method:
- If `_isEditMode`: Build `ActivityUpdateDto` from form fields and call `notifier.updateActivity(widget.activityId!, dto)`
- If NOT edit mode: Keep existing `createActivity` logic unchanged
- Change submit button text: "Simpan Perubahan" for edit mode, keep existing text for create mode
- Change AppBar title: "Edit Aktivitas" for edit mode, keep existing for create mode

**4. Activity detail screen** (lib/presentation/screens/activity/activity_detail_screen.dart):
Find the edit button in the AppBar (currently has `// TODO: Navigate to edit`). Wire it to:
```dart
context.pushNamed(
  RouteNames.activityEdit,
  pathParameters: {'id': activityId},
);
```
  </action>
  <verify>Run `flutter analyze` to verify no compilation errors. Verify the edit route exists in route_names.dart and app_router.dart. Verify ActivityFormScreen accepts activityId parameter. Verify activity detail edit button navigates to edit route.</verify>
  <done>Edit route `/home/activities/:id/edit` exists and works. ActivityFormScreen supports edit mode via `activityId` parameter with pre-filled fields. Completed activities have all fields locked except summary/notes. Object type and object association are always locked in edit mode. Detail screen edit button navigates to edit route. Submit in edit mode calls updateActivity.</done>
</task>

</tasks>

<verification>
1. `dart run build_runner build --delete-conflicting-outputs` succeeds
2. `flutter analyze` passes with no errors
3. ActivityUpdateDto is generated with optional fields
4. Repository chain: interface -> impl -> local DS all have updateActivity
5. Route `/home/activities/:id/edit` defined in router
6. Activity form pre-fills all fields when activityId is provided
7. Completed activity locks all fields except summary/notes
8. Edit button on activity detail navigates to edit route
9. Form submit in edit mode calls updateActivity and queues sync
</verification>

<success_criteria>
- User can tap edit on activity detail, see pre-filled form, modify fields, save changes
- Completed activities restrict editing to notes/summary only
- Edit operation queues SyncOperation.update for offline sync
- Object type and association are locked in edit mode
</success_criteria>

<output>
After completion, create `.planning/phases/08-stubbed-feature-completion/08-03-SUMMARY.md`
</output>
