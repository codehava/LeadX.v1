---
phase: 05-background-sync-dead-letter-queue
plan: 03
type: execute
wave: 3
depends_on: [05-02]
files_modified:
  - lib/data/services/background_sync_service.dart
  - lib/main.dart
  - lib/presentation/screens/profile/settings_screen.dart
  - ios/Runner/AppDelegate.swift
  - ios/Runner/Info.plist
  - pubspec.yaml
autonomous: false
requirements: [CONF-04]

must_haves:
  truths:
    - "Background sync processes the push queue when the app is backgrounded or closed via WorkManager/BGTaskScheduler"
    - "Background sync only pushes (no pull) to stay within iOS 30-second time limit"
    - "User can enable/disable background sync from Settings toggle"
    - "Background task checks for valid Supabase session and skips sync gracefully if auth expired"
    - "Background task does not run database migrations (foreground only)"
    - "Periodic task uses ExistingPeriodicWorkPolicy.update to prevent duplicate registrations"
  artifacts:
    - path: "lib/data/services/background_sync_service.dart"
      provides: "Top-level callbackDispatcher and BackgroundSyncService class"
      contains: "callbackDispatcher"
    - path: "lib/main.dart"
      provides: "Workmanager initialization in app startup"
      contains: "Workmanager"
    - path: "lib/presentation/screens/profile/settings_screen.dart"
      provides: "Background sync toggle switch"
      contains: "background_sync"
    - path: "ios/Runner/AppDelegate.swift"
      provides: "WorkmanagerPlugin.registerTask call"
      contains: "WorkmanagerPlugin"
    - path: "ios/Runner/Info.plist"
      provides: "UIBackgroundModes and BGTaskSchedulerPermittedIdentifiers"
      contains: "BGTaskSchedulerPermittedIdentifiers"
    - path: "pubspec.yaml"
      provides: "workmanager dependency"
      contains: "workmanager"
  key_links:
    - from: "lib/data/services/background_sync_service.dart"
      to: "lib/data/services/sync_service.dart"
      via: "Creates SyncService instance and calls processQueue()"
      pattern: "processQueue"
    - from: "lib/main.dart"
      to: "lib/data/services/background_sync_service.dart"
      via: "Workmanager().initialize(callbackDispatcher)"
      pattern: "callbackDispatcher"
    - from: "lib/presentation/screens/profile/settings_screen.dart"
      to: "lib/data/services/background_sync_service.dart"
      via: "Toggle calls registerPeriodicTask or cancelByUniqueName"
      pattern: "background_sync"
---

<objective>
Add background sync via the workmanager package so sync queue processing persists across app restarts.

Purpose: Sales reps sometimes background or close the app after making changes. Without background sync, pending queue items wait until the next foreground session. WorkManager (Android) and BGTaskScheduler (iOS) enable the OS to wake the app periodically to process the sync queue, ensuring data reaches the server within ~15 minutes even if the app is closed. Per locked decisions, this is "nice to have" with a user-controllable toggle.

Output: Working background sync service, platform configurations, settings toggle, workmanager package integration.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-background-sync-dead-letter-queue/05-RESEARCH.md
@.planning/phases/05-background-sync-dead-letter-queue/05-01-SUMMARY.md
@.planning/phases/05-background-sync-dead-letter-queue/05-02-SUMMARY.md

@lib/main.dart
@lib/data/services/sync_service.dart
@lib/data/services/connectivity_service.dart
@lib/data/database/app_database.dart
@lib/presentation/screens/profile/settings_screen.dart
@lib/data/services/app_settings_service.dart
@ios/Runner/AppDelegate.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workmanager dependency + create BackgroundSyncService + platform configuration</name>
  <files>
    pubspec.yaml
    lib/data/services/background_sync_service.dart
    ios/Runner/AppDelegate.swift
    ios/Runner/Info.plist
  </files>
  <action>
**1. Add workmanager to pubspec.yaml:**
```bash
flutter pub add workmanager
```

**2. Create `lib/data/services/background_sync_service.dart`:**

This file contains the top-level callback and a helper class for registration/cancellation.

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:workmanager/workmanager.dart';

import '../../core/logging/app_logger.dart';
import '../database/app_database.dart';
import '../datasources/local/sync_queue_local_data_source.dart';
import 'connectivity_service.dart';
import 'sync_service.dart';

/// Unique task name for WorkManager registration.
const _backgroundSyncTaskName = 'leadx-background-sync';
const _backgroundSyncTaskTag = 'backgroundSync';

/// Top-level callback for WorkManager.
/// MUST be a top-level function (not a class method) because it runs
/// in a separate FlutterEngine with no access to the foreground app's state.
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    // Skip on web -- WorkManager is mobile-only
    if (kIsWeb) return true;

    try {
      // 1. Load environment variables
      await dotenv.load(fileName: '.env');

      // 2. Initialize Supabase independently (separate FlutterEngine)
      await Supabase.initialize(
        url: dotenv.env['SUPABASE_URL']!,
        anonKey: dotenv.env['SUPABASE_ANON_KEY']!,
      );

      // 3. Check if we have a valid auth session
      final session = Supabase.instance.client.auth.currentSession;
      if (session == null) {
        // No auth session available -- user needs to open app and login.
        // Return true (success) so WorkManager doesn't retry immediately.
        return true;
      }

      // 4. Open database independently (not shared with foreground)
      // Do NOT run migrations from background -- if schema is outdated,
      // skip and let the foreground handle migration on next app open.
      final db = AppDatabase();

      try {
        // 5. Create minimal dependencies for sync
        final syncQueueDs = SyncQueueLocalDataSource(db);
        final connectivityService = ConnectivityService(
          supabaseClient: Supabase.instance.client,
        );
        await connectivityService.initialize();

        // Check connectivity before proceeding
        if (!connectivityService.isConnected) {
          connectivityService.dispose();
          await db.close();
          return true; // Don't retry -- will run again on next periodic schedule
        }

        final syncService = SyncService(
          syncQueueDataSource: syncQueueDs,
          connectivityService: connectivityService,
          supabaseClient: Supabase.instance.client,
          database: db,
        );

        // 6. Process queue (PUSH ONLY -- no pull in background)
        // Push is fast and bounded by queue size.
        // Pull involves 10+ tables and risks exceeding iOS 30-second limit.
        await syncService.processQueue();

        // 7. Cleanup
        connectivityService.dispose();
        syncService.dispose();
      } finally {
        await db.close();
      }

      return true; // Success
    } catch (e) {
      // Return false to let WorkManager handle retry with backoff.
      // But for most errors, we want true (don't retry aggressively).
      return true;
    }
  });
}

/// Service for managing background sync registration.
class BackgroundSyncService {
  /// Initialize WorkManager with the callback dispatcher.
  /// Call once during app startup.
  static Future<void> initialize() async {
    if (kIsWeb) return; // WorkManager is mobile-only

    await Workmanager().initialize(
      callbackDispatcher,
      isInDebugMode: !kReleaseMode,
    );
  }

  /// Register periodic background sync task.
  /// Minimum interval is 15 minutes (enforced by both Android and iOS).
  /// Uses ExistingPeriodicWorkPolicy.update to prevent duplicate registrations.
  static Future<void> registerPeriodicSync() async {
    if (kIsWeb) return;

    await Workmanager().registerPeriodicTask(
      _backgroundSyncTaskName,
      _backgroundSyncTaskTag,
      frequency: const Duration(minutes: 15),
      constraints: Constraints(
        networkType: NetworkType.connected,
        requiresBatteryNotLow: true,
      ),
      existingWorkPolicy: ExistingPeriodicWorkPolicy.update,
      backoffPolicy: BackoffPolicy.exponential,
      backoffPolicyDelay: const Duration(minutes: 1),
    );
  }

  /// Cancel background sync (when user disables the toggle).
  static Future<void> cancelPeriodicSync() async {
    if (kIsWeb) return;

    await Workmanager().cancelByUniqueName(_backgroundSyncTaskName);
  }
}
```

**3. Update `ios/Runner/AppDelegate.swift`:**

Add WorkmanagerPlugin import and task registration:
```swift
import Flutter
import UIKit
import workmanager

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)

    // Register background task identifier for WorkManager
    WorkmanagerPlugin.registerTask(
      withIdentifier: "com.askrindo.leadx_crm.backgroundSync"
    )

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}
```

**4. Update `ios/Runner/Info.plist`:**

Add UIBackgroundModes and BGTaskSchedulerPermittedIdentifiers. Find the existing `<dict>` and add before the closing `</dict>`:
```xml
<key>UIBackgroundModes</key>
<array>
  <string>fetch</string>
  <string>processing</string>
</array>
<key>BGTaskSchedulerPermittedIdentifiers</key>
<array>
  <string>com.askrindo.leadx_crm.backgroundSync</string>
</array>
```

Read the existing Info.plist first to find the right insertion point. Add these keys inside the top-level `<dict>` alongside existing keys.
  </action>
  <verify>
    `flutter pub get` succeeds.
    `flutter analyze` passes.
    Read ios/Runner/AppDelegate.swift and confirm WorkmanagerPlugin import and registration.
    Read ios/Runner/Info.plist and confirm UIBackgroundModes and BGTaskSchedulerPermittedIdentifiers.
    Read lib/data/services/background_sync_service.dart and confirm callbackDispatcher is top-level with @pragma.
  </verify>
  <done>
    - workmanager package added to pubspec.yaml
    - Background sync callback created as top-level function with independent Supabase+Drift init
    - Callback does push-only sync (no pull) within iOS time limits
    - Auth session checked before sync attempt
    - iOS plist configured with UIBackgroundModes and BGTaskSchedulerPermittedIdentifiers
    - iOS AppDelegate registers background task identifier
    - BackgroundSyncService provides static register/cancel methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate workmanager init in main.dart + Settings toggle for background sync</name>
  <files>
    lib/main.dart
    lib/presentation/screens/profile/settings_screen.dart
  </files>
  <action>
**Update `lib/main.dart`:**

Add WorkManager initialization after Supabase init, before runApp:

```dart
import 'data/services/background_sync_service.dart';

// Inside appRunner, after Supabase.initialize() and before runApp():
// Initialize background sync (WorkManager)
await BackgroundSyncService.initialize();
```

Do NOT register the periodic task here -- that's controlled by the user toggle in Settings. The initialization just sets up the callback dispatcher. However, we need to check if background sync was previously enabled (persisted setting) and re-register if so.

Add after initialize:
```dart
// Re-register periodic sync if previously enabled
// Read setting from AppSettings table via a lightweight check
final db = AppDatabase();
try {
  final setting = await (db.select(db.appSettings)
    ..where((t) => t.key.equals('background_sync_enabled')))
    .getSingleOrNull();
  if (setting?.value == 'true') {
    await BackgroundSyncService.registerPeriodicSync();
  }
} catch (_) {
  // Ignore -- first launch or no setting yet
} finally {
  // Don't close db -- the ProviderScope will create its own instance.
  // Actually, this is a separate db instance just for reading the setting.
  await db.close();
}
```

Wait -- this creates a temporary DB connection just to check a setting. That's wasteful. Better approach: always register the periodic task during init, and have the callback itself check the setting and skip if disabled. This avoids the complexity of register/cancel lifecycle on every app launch.

Revised approach:
```dart
// In main.dart, after Supabase.initialize():
await BackgroundSyncService.initialize();
// Always register -- the callback checks the toggle setting internally
await BackgroundSyncService.registerPeriodicSync();
```

Then in the callback dispatcher, check the setting:
Actually, checking the setting in the callback means opening the DB in background just to check a flag. The research recommended: "Always register during init. Check the toggle setting inside the callback and skip processing if disabled."

But there's a cleaner approach: When user disables the toggle, call `cancelByUniqueName`. When user enables, call `registerPeriodicSync`. On app launch, check the persisted setting and conditionally register. This is cleaner than always registering.

Final approach for main.dart -- register based on stored preference. Use shared_preferences for this single boolean since it's lightweight and doesn't require opening Drift:

Actually, let's NOT add shared_preferences as a new dependency just for this. The app already has AppSettings (Drift-based). Let's use the simpler "always register, check in callback" pattern:

In main.dart:
```dart
await BackgroundSyncService.initialize();
await BackgroundSyncService.registerPeriodicSync();
```

In the callback (already in Task 1), add a check:
```dart
// Check if background sync is enabled
final db = AppDatabase();
try {
  final setting = await (db.select(db.appSettings)
    ..where((t) => t.key.equals('background_sync_enabled')))
    .getSingleOrNull();
  if (setting?.value == 'false') {
    await db.close();
    return true; // Skip -- disabled by user
  }
  // ... proceed with sync
```

Update the callbackDispatcher in background_sync_service.dart to include this check early, right after opening the DB and before creating sync dependencies.

**Update `lib/presentation/screens/profile/settings_screen.dart`:**

Add a background sync toggle to the Sinkronisasi section. The settings screen was already modified in Plan 02 to add badge and timestamp. Now add a toggle.

1. Add a new ListTile with a Switch (or SwitchListTile) below the Sinkronisasi row:
   ```dart
   SwitchListTile(
     secondary: const Icon(Icons.sync_lock_outlined),
     title: const Text('Sinkronisasi Latar Belakang'),
     subtitle: const Text('Sinkronkan data saat aplikasi ditutup'),
     value: backgroundSyncEnabled,
     onChanged: (value) async {
       // Persist setting
       final appSettings = ref.read(appSettingsServiceProvider);
       await appSettings.setSetting('background_sync_enabled', value.toString());
       // Register or cancel
       if (value) {
         await BackgroundSyncService.registerPeriodicSync();
       } else {
         await BackgroundSyncService.cancelPeriodicSync();
       }
       // Trigger rebuild
       ref.invalidate(backgroundSyncEnabledProvider);
     },
   ),
   ```

2. Create a `backgroundSyncEnabledProvider` in sync_providers.dart (or inline it). Since we need to read from AppSettings:
   ```dart
   final backgroundSyncEnabledProvider = FutureProvider<bool>((ref) async {
     final appSettings = ref.watch(appSettingsServiceProvider);
     final value = await appSettings.getSetting('background_sync_enabled');
     return value == 'true'; // Default false if not set
   });
   ```

   Check if AppSettingsService has a `getSetting` method. It likely uses key-value pairs in the `app_settings` table. If no generic `getSetting` exists, add one or use the DB directly.

   Actually, look at `AppSettingsService` -- it has methods like `getTableLastSyncAt` which read from app_settings table. Add a generic `getSetting(String key)` and `setSetting(String key, String value)` if they don't exist. Read the file first during execution to confirm.

3. In the settings_screen build method, watch the provider:
   ```dart
   final bgSyncAsync = ref.watch(backgroundSyncEnabledProvider);
   final backgroundSyncEnabled = bgSyncAsync.valueOrNull ?? false;
   ```

4. Place the SwitchListTile inside the same Card as the Sinkronisasi ListTile, adding a Divider between them. The card already has the notification settings and sinkronisasi rows with dividers.

5. Add the import for BackgroundSyncService.

6. Add `backgroundSyncEnabledProvider` to sync_providers.dart.

Note: The toggle defaults to OFF (false) when no setting exists, per the "nice to have" characterization. Users opt in.
  </action>
  <verify>
    `flutter analyze` passes.
    `flutter build apk --debug` succeeds (confirms Android WorkManager integration compiles).
    Read main.dart and confirm BackgroundSyncService.initialize() is called.
    Read settings_screen.dart and confirm toggle exists with register/cancel logic.
  </verify>
  <done>
    - WorkManager initialized on app startup with periodic task registered
    - Background callback checks toggle setting and skips if disabled
    - Settings screen has toggle for enabling/disabling background sync
    - Toggle persists to AppSettings and controls WorkManager registration
    - Background sync defaults to disabled
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 5 implementation:
1. Dead letter status tracking with migration v12
2. Production-ready sync queue screen with Indonesian labels, error translation, retry/discard
3. Settings badge + timestamp + background sync toggle
4. App bar dead letter warning indicator
5. WorkManager background sync (push-only)
  </what-built>
  <how-to-verify>
1. Run `flutter run` on Android device or emulator
2. Navigate to Settings > Sinkronisasi -- verify "Terakhir sinkronisasi: X menit lalu" subtitle appears
3. If dead letter items exist, verify red badge count appears on Settings sync icon and in app bar
4. Tap app bar warning icon -- should navigate to sync queue screen
5. Verify sync queue screen shows "Gagal" tab by default with dead letter items (if any)
6. Switch to "Semua" tab -- shows all items
7. Verify error messages are in Indonesian (not raw exception text)
8. Test retry: tap "Coba Ulang" on a dead letter item -- should reset to pending
9. Test discard: tap "Buang" -- confirmation dialog should appear in Indonesian
10. Verify background sync toggle in Settings (defaults to off)
11. Enable background sync toggle, background the app for 15+ minutes, verify sync occurs
12. If no dead letter items exist to test, create one by: going offline, creating a customer, going online, and manually corrupting the queue item's payload to trigger a validation error

Note: If there are no sync queue items, the screen should show "Semua data tersinkronisasi" with checkmark.
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `flutter analyze` passes
2. `flutter build apk --debug` succeeds
3. WorkManager callback is top-level function with @pragma('vm:entry-point')
4. iOS Info.plist has UIBackgroundModes and BGTaskSchedulerPermittedIdentifiers
5. Settings toggle controls background sync registration
6. Full dead letter flow works: fail -> dead_letter -> retry/discard
</verification>

<success_criteria>
- Background sync processes queue when app is backgrounded (push-only, within iOS limits)
- User can enable/disable background sync from Settings
- Background task safely handles expired auth sessions
- Periodic task uses ExistingPeriodicWorkPolicy.update (no duplicates)
- All platform configurations in place (iOS plist, AppDelegate, Android via package)
</success_criteria>

<output>
After completion, create `.planning/phases/05-background-sync-dead-letter-queue/05-03-SUMMARY.md`
</output>
