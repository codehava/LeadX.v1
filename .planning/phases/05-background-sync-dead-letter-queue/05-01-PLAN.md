---
phase: 05-background-sync-dead-letter-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/database/tables/sync_queue.dart
  - lib/data/database/app_database.dart
  - lib/data/database/app_database.g.dart
  - lib/data/datasources/local/sync_queue_local_data_source.dart
  - lib/data/services/sync_service.dart
  - lib/presentation/providers/sync_providers.dart
autonomous: true
requirements: [SYNC-06, CONF-02]

must_haves:
  truths:
    - "Non-retryable sync errors (auth, validation, conflict) immediately mark items as dead_letter instead of silently reprocessing every cycle"
    - "Orphaned queue items (no valid status) older than 7 days are pruned as a safety net after each sync"
    - "Dead letter items older than 30 days are auto-expired and pruned"
    - "Dead letter count is watchable as a reactive Drift stream"
    - "Retrying a dead letter item resets retryCount to 0 and status back to pending (isPendingSync on the entity is already true since it is only cleared by _markEntityAsSynced on successful sync)"
    - "Discarding a dead letter item removes it from queue and clears isPendingSync on the entity"
  artifacts:
    - path: "lib/data/database/tables/sync_queue.dart"
      provides: "status column definition on SyncQueueItems table"
      contains: "status"
    - path: "lib/data/database/app_database.dart"
      provides: "Migration v12 adding status column with backfill"
      contains: "from < 12"
    - path: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      provides: "Dead letter queries, pruning, discard, status-aware retry"
      exports: ["watchDeadLetterCount", "getDeadLetterItems", "pruneOldItems", "pruneExpiredDeadLetters", "discardDeadLetterItem", "markAsDeadLetter"]
    - path: "lib/data/services/sync_service.dart"
      provides: "Status-based queue processing, non-retryable immediate dead letter, post-sync pruning"
      contains: "markAsDeadLetter"
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "deadLetterCountProvider and lastSyncAtProvider"
      contains: "deadLetterCountProvider"
  key_links:
    - from: "lib/data/services/sync_service.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "markAsDeadLetter for non-retryable errors"
      pattern: "markAsDeadLetter"
    - from: "lib/data/services/sync_service.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "pruneOldItems + pruneExpiredDeadLetters + pruneSyncConflicts after processQueue"
      pattern: "prune"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "deadLetterCountProvider watches watchDeadLetterCount stream"
      pattern: "watchDeadLetterCount"
---

<objective>
Add dead letter status tracking to sync queue and fix the non-retryable error reprocessing bug.

Purpose: Currently, non-retryable errors (AuthSyncError, ValidationSyncError, ConflictSyncError) call markAsFailed() without incrementing retryCount, causing these items to be reprocessed every sync cycle indefinitely. Adding an explicit `status` column with proper lifecycle management fixes this bug and enables dead letter queries for the UI (Plan 02) and pruning for queue hygiene (SYNC-06).

Output: Migration v12 with status column, updated sync service with dead letter logic, pruning methods, and reactive providers for dead letter count.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-background-sync-dead-letter-queue/05-RESEARCH.md

@lib/data/database/tables/sync_queue.dart
@lib/data/database/app_database.dart
@lib/data/datasources/local/sync_queue_local_data_source.dart
@lib/data/services/sync_service.dart
@lib/presentation/providers/sync_providers.dart
@lib/core/errors/sync_errors.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status column to sync_queue table + migration v12</name>
  <files>
    lib/data/database/tables/sync_queue.dart
    lib/data/database/app_database.dart
    lib/data/database/app_database.g.dart
  </files>
  <action>
1. In `lib/data/database/tables/sync_queue.dart`, add a `status` column to `SyncQueueItems`:
   ```dart
   TextColumn get status => text().withDefault(const Constant('pending'))();
   ```
   Valid values: 'pending', 'failed', 'dead_letter'. There is no 'completed' status because completed items are deleted immediately via markAsCompleted().

2. In `lib/data/database/app_database.dart`:
   - Bump `schemaVersion` from 11 to 12
   - Add migration block `if (from < 12)`:
     ```dart
     if (from < 12) {
       await m.addColumn(syncQueueItems, syncQueueItems.status);
       // Backfill existing items based on current state
       await customStatement(
         "UPDATE sync_queue SET status = CASE "
         "WHEN retry_count >= 5 THEN 'dead_letter' "
         "WHEN last_error IS NOT NULL AND retry_count > 0 THEN 'failed' "
         "ELSE 'pending' "
         "END"
       );
     }
     ```

3. Run `dart run build_runner build --delete-conflicting-outputs` to regenerate `app_database.g.dart` with the new column.
  </action>
  <verify>
    `dart run build_runner build --delete-conflicting-outputs` completes without errors.
    `flutter analyze` passes with no errors related to sync_queue or app_database.
  </verify>
  <done>SyncQueueItems table has a `status` text column with default 'pending'. Migration v12 adds the column and backfills existing items. Generated code compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Dead letter data source methods + sync service status-based processing + pruning + providers</name>
  <files>
    lib/data/datasources/local/sync_queue_local_data_source.dart
    lib/data/services/sync_service.dart
    lib/presentation/providers/sync_providers.dart
  </files>
  <action>
**sync_queue_local_data_source.dart -- Add these methods:**

1. `markAsDeadLetter(int id, String error)` -- Sets status='dead_letter', lastError=error, lastAttemptAt=now.

2. `watchDeadLetterCount()` -- Returns `Stream<int>` watching count of items WHERE status='dead_letter'. Follow the same Drift `.watchSingle()` pattern as `watchPendingCount()` and `watchRecentConflictCount()`.

3. `getDeadLetterItems()` -- Returns `Future<List<SyncQueueItem>>` with status='dead_letter', ordered by lastAttemptAt desc.

4. Two pruning methods:
   - `pruneOldItems({required Duration completedRetention})` -- Safety net for orphaned items. Deletes items where `createdAt < now - completedRetention` AND `status NOT IN ('pending', 'failed', 'dead_letter')`. Since completed items are deleted immediately on success via `markAsCompleted()`, this only catches items in an unexpected state (e.g., no status after a crash). This is a safety net, not routine cleanup.
   - `pruneExpiredDeadLetters({Duration expiry = const Duration(days: 30)})` -- Deletes items where `status = 'dead_letter' AND lastAttemptAt < now - 30 days`. This is the primary pruning mechanism per locked decision "dead letter items auto-expire after 30 days".

5. `discardDeadLetterItem(int id)` -- Removes the item from sync queue by ID. The caller (SyncService) handles clearing isPendingSync on the entity.

6. Update `resetRetryCount(int id)` -- Also set `status` back to `'pending'` in the write companion. This is critical: currently it only resets retryCount and lastError but doesn't change status, which means dead_letter items would stay as dead_letter even after retry reset. Note: The entity's `isPendingSync` flag does NOT need to be set here because it is already `true` -- it was set to `true` when the sync queue item was first created, and is only cleared by `_markEntityAsSynced()` on successful sync or `_markEntityAsLocalOnly()` on discard. This satisfies Roadmap SC5 ("Retrying a dead letter item resets retryCount and marks isPendingSync=true") because isPendingSync is implicitly still true for all unsynced items.

7. Update `getRetryableItems({int maxRetries = 5})` -- Add WHERE filter: `t.status.equals('pending') | t.status.equals('failed')`. This prevents dead_letter items from being picked up by processQueue(). This is THE critical fix for the non-retryable error reprocessing bug.

8. Update `markAsFailed(int id, String error)` -- Also set `status` to `'failed'`.

9. Prune sync_conflicts older than 30 days. Add `pruneSyncConflicts({Duration olderThan = const Duration(days: 30)})` -- Deletes from syncConflicts WHERE detectedAt < now-30days.

**sync_service.dart -- Update processQueue() and error handling:**

1. In the `on SyncError` catch block inside processQueue():
   - For non-retryable errors (`!syncError.isRetryable`): call `_syncQueueDataSource.markAsDeadLetter(item.id, syncError.message)` instead of `markAsFailed()`. This immediately moves auth/validation/conflict errors to dead_letter status.
   - For retryable errors: keep `incrementRetryCount()` but ALSO check if the new retry count reaches `maxRetries`. If so, call `markAsDeadLetter()` instead. To do this cleanly: after `incrementRetryCount()`, fetch the item again and check retryCount >= maxRetries, then call `markAsDeadLetter()`.

2. After the processing loop in processQueue() (after the for loop, before the return), add pruning. All three pruning methods must be called:
   ```dart
   // Prune queue after sync
   await _syncQueueDataSource.pruneOldItems(completedRetention: const Duration(days: 7));
   await _syncQueueDataSource.pruneExpiredDeadLetters();
   await _syncQueueDataSource.pruneSyncConflicts();
   ```
   The `pruneOldItems` call is a safety net for orphaned items (completed items are already deleted on success, but any items that somehow end up with no valid status and are older than 7 days get cleaned up). The `pruneExpiredDeadLetters` call removes dead letter items older than 30 days per locked decision. The `pruneSyncConflicts` call removes old conflict records.

3. Add a `discardDeadLetterItem(SyncQueueItem item)` method to SyncService that:
   a. Calls `_syncQueueDataSource.discardDeadLetterItem(item.id)` to remove from queue.
   b. Calls `_markEntityAsLocalOnly(item.entityType, item.entityId)` (new private method).

4. Add private `_markEntityAsLocalOnly(String entityType, String entityId)` method. Similar to `_markEntityAsSynced` but sets `isPendingSync: false, lastSyncAt: Value(null)` to indicate "exists locally, never synced". Use the same switch/case structure as `_markEntityAsSynced` covering all entity types.

**sync_providers.dart -- Add new providers:**

1. Add `deadLetterCountProvider`:
   ```dart
   final deadLetterCountProvider = StreamProvider<int>((ref) {
     final syncQueueDataSource = ref.watch(syncQueueDataSourceProvider);
     return syncQueueDataSource.watchDeadLetterCount();
   });
   ```

2. Add `lastSyncTimestampProvider` -- a StreamProvider or FutureProvider that reads last sync timestamp from AppSettingsService. Use `appSettingsServiceProvider` to get the service, then call a method to get the last overall sync time. Check if AppSettingsService has a relevant method. If not, use the `getTableLastSyncAt` method with a general key or take the max across table-specific timestamps. For simplicity, read the 'last_pull_sync_at_customers' key as a proxy for "last sync time" since customers are always pulled. Make this a FutureProvider that re-evaluates when sync state changes:
   ```dart
   final lastSyncTimestampProvider = FutureProvider<DateTime?>((ref) async {
     // Re-evaluate whenever sync state changes
     ref.watch(syncNotifierProvider);
     final appSettings = ref.watch(appSettingsServiceProvider);
     return appSettings.getTableLastSyncAt('customers');
   });
   ```
  </action>
  <verify>
    `flutter analyze` passes with no errors.
    `flutter test test/data/services/` passes (or at least doesn't introduce new failures).
    Verify that `getRetryableItems` now filters by status by reading the updated code.
    Verify that the post-sync pruning block in `processQueue()` calls all three: `pruneOldItems`, `pruneExpiredDeadLetters`, and `pruneSyncConflicts`.
  </verify>
  <done>
    - Non-retryable SyncErrors immediately mark items as dead_letter (not silently reprocessed).
    - Retryable errors that exhaust maxRetries also become dead_letter.
    - Dead letter count is available as a reactive StreamProvider.
    - Queue pruning runs after each sync: orphaned items older than 7 days pruned (safety net), expired dead letters removed after 30 days, sync_conflicts pruned after 30 days.
    - resetRetryCount resets status to pending (isPendingSync is already true on the entity implicitly per SC5).
    - discardDeadLetterItem removes from queue and marks entity as local-only.
    - getRetryableItems filters out dead_letter items.
  </done>
</task>

</tasks>

<verification>
1. `dart run build_runner build --delete-conflicting-outputs` succeeds
2. `flutter analyze` passes
3. Read sync_queue_local_data_source.dart and confirm getRetryableItems filters by status
4. Read sync_service.dart and confirm non-retryable errors call markAsDeadLetter
5. Read sync_service.dart and confirm post-sync pruning calls pruneOldItems, pruneExpiredDeadLetters, AND pruneSyncConflicts
6. Read sync_providers.dart and confirm deadLetterCountProvider exists
</verification>

<success_criteria>
- Migration v12 adds status column with backfill logic
- Non-retryable errors immediately become dead_letter (fixing the reprocessing bug)
- Dead letter count is watchable via Drift stream
- Queue pruning cleans up orphaned items (7 days), expired dead letters (30 days), and old conflicts (30 days) after each sync
- Retry/discard methods exist with proper status management
</success_criteria>

<output>
After completion, create `.planning/phases/05-background-sync-dead-letter-queue/05-01-SUMMARY.md`
</output>
