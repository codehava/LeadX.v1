---
phase: 07-offline-ux-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/presentation/widgets/shell/responsive_shell.dart
  - lib/presentation/screens/activity/activity_detail_screen.dart
  - lib/presentation/screens/home/tabs/activities_tab.dart
  - lib/presentation/screens/pipeline/pipeline_detail_screen.dart
  - lib/presentation/screens/customer/customer_detail_screen.dart
  - lib/presentation/screens/home/tabs/customers_tab.dart
  - lib/data/datasources/local/sync_queue_local_data_source.dart
  - lib/presentation/providers/sync_providers.dart
  - lib/data/services/app_settings_service.dart
  - lib/core/utils/format_last_sync.dart
  - lib/presentation/screens/profile/settings_screen.dart
  - lib/presentation/widgets/common/sync_status_badge.dart
  - lib/core/theme/app_colors.dart
autonomous: true
requirements:
  - UX-01

must_haves:
  truths:
    - "OfflineBanner appears at the top of all ResponsiveShell-wrapped screens when offline (detail/form screens using parentNavigatorKey are excluded by routing architecture)"
    - "OfflineBanner disappears instantly when connectivity is restored"
    - "No duplicate OfflineBanner appears on any screen (per-screen deployments removed)"
    - "A batch sync queue status map provider exists and reactively emits entity status changes"
    - "A global last sync timestamp provider returns the max across all table sync timestamps"
    - "A shared formatLastSync utility exists and is used by settings screen"
    - "SyncStatus.failed color is amber/orange (for 'will retry') and SyncStatus.deadLetter color is red (for 'needs manual action') per locked decision"
  artifacts:
    - path: "lib/presentation/widgets/shell/responsive_shell.dart"
      provides: "Shell-level OfflineBanner in all three layout modes"
      contains: "OfflineBanner"
    - path: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      provides: "watchAllItems Stream method for batch sync queue status"
      contains: "watchAllItems"
    - path: "lib/presentation/providers/sync_providers.dart"
      provides: "syncQueueEntityStatusMapProvider and updated lastSyncTimestampProvider"
      contains: "syncQueueEntityStatusMapProvider"
    - path: "lib/data/services/app_settings_service.dart"
      provides: "getGlobalLastSyncAt method"
      contains: "getGlobalLastSyncAt"
    - path: "lib/core/utils/format_last_sync.dart"
      provides: "Shared formatLastSync utility function"
      contains: "formatLastSync"
    - path: "lib/core/theme/app_colors.dart"
      provides: "Corrected sync color constants (failed=amber, deadLetter=red)"
      contains: "syncFailed"
    - path: "lib/presentation/widgets/common/sync_status_badge.dart"
      provides: "SyncStatusBadge using AppColors.syncDeadLetter instead of Colors.orange"
      contains: "AppColors.syncDeadLetter"
  key_links:
    - from: "lib/presentation/widgets/shell/responsive_shell.dart"
      to: "lib/presentation/widgets/common/offline_banner.dart"
      via: "import and Column wrapping widget.child"
      pattern: "OfflineBanner"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/datasources/local/sync_queue_local_data_source.dart"
      via: "syncQueueEntityStatusMapProvider watches watchAllItems"
      pattern: "watchAllItems"
    - from: "lib/presentation/providers/sync_providers.dart"
      to: "lib/data/services/app_settings_service.dart"
      via: "lastSyncTimestampProvider calls getGlobalLastSyncAt"
      pattern: "getGlobalLastSyncAt"
---

<objective>
Move OfflineBanner to shell level for global coverage, create batch sync queue status provider infrastructure, add global last sync timestamp, and extract shared formatting utility.

Purpose: Establishes all shared infrastructure that card badges (Plan 02) and dashboard staleness (Plan 03) depend on. Consolidates OfflineBanner to a single location covering all shell-wrapped screens.

Output: Shell-level OfflineBanner, syncQueueEntityStatusMapProvider, updated lastSyncTimestampProvider, getGlobalLastSyncAt, shared formatLastSync utility.
</objective>

<execution_context>
@C:/Users/cartr/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cartr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-offline-ux-polish/07-RESEARCH.md
@lib/presentation/widgets/shell/responsive_shell.dart
@lib/presentation/widgets/common/offline_banner.dart
@lib/data/datasources/local/sync_queue_local_data_source.dart
@lib/presentation/providers/sync_providers.dart
@lib/data/services/app_settings_service.dart
@lib/presentation/screens/profile/settings_screen.dart
@lib/presentation/widgets/common/sync_status_badge.dart
@lib/core/theme/app_colors.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move OfflineBanner to shell level and remove per-screen deployments</name>
  <files>
    lib/presentation/widgets/shell/responsive_shell.dart
    lib/presentation/screens/activity/activity_detail_screen.dart
    lib/presentation/screens/home/tabs/activities_tab.dart
    lib/presentation/screens/pipeline/pipeline_detail_screen.dart
    lib/presentation/screens/customer/customer_detail_screen.dart
    lib/presentation/screens/home/tabs/customers_tab.dart
  </files>
  <action>
    In `responsive_shell.dart`:
    1. Add import for OfflineBanner: `import '../common/offline_banner.dart';`
    2. In `_buildMobileLayout`: wrap `widget.child` in a Column with OfflineBanner above:
       ```dart
       body: Column(
         children: [
           const OfflineBanner(),
           Expanded(child: widget.child),
         ],
       ),
       ```
    3. In `_buildTabletLayout`: wrap the `Expanded(child: widget.child)` in the Row in a Column with OfflineBanner:
       ```dart
       Expanded(
         child: Column(
           children: [
             const OfflineBanner(),
             Expanded(child: widget.child),
           ],
         ),
       ),
       ```
    4. In `_buildDesktopLayout`: add `const OfflineBanner(),` above the `Expanded(child: widget.child)` in the right-side Column (the one that already contains `_buildDesktopTopBar`).

    Remove OfflineBanner from all 5 per-screen files:
    - `activity_detail_screen.dart`: Remove OfflineBanner widget and its import. Search for `OfflineBanner` in the build method and remove it plus any Column wrapper that was only there for it.
    - `activities_tab.dart`: Same removal pattern.
    - `pipeline_detail_screen.dart`: Same removal pattern.
    - `customer_detail_screen.dart`: Same removal pattern.
    - `customers_tab.dart`: Same removal pattern.

    For each file: remove the `import` line for `offline_banner.dart`, then remove the `OfflineBanner()` widget usage. If the OfflineBanner was the only reason for a Column wrapper, simplify back to the direct child.

    Note: Detail screens use `parentNavigatorKey: _rootNavigatorKey` so they push OVER the shell. They will NOT have the banner -- this is acceptable per locked decision.
  </action>
  <verify>Run `flutter analyze` and confirm no unused imports or dead code warnings related to OfflineBanner in the 5 cleaned-up screens. Verify the OfflineBanner import exists in responsive_shell.dart.</verify>
  <done>OfflineBanner appears exactly once in the codebase (in ResponsiveShell), wrapping all three layout modes. All 5 per-screen deployments are removed with no compilation errors.</done>
</task>

<task type="auto">
  <name>Task 2: Fix badge colors, create batch sync queue status provider, global last sync timestamp, and shared format utility</name>
  <files>
    lib/core/theme/app_colors.dart
    lib/presentation/widgets/common/sync_status_badge.dart
    lib/data/datasources/local/sync_queue_local_data_source.dart
    lib/presentation/providers/sync_providers.dart
    lib/data/services/app_settings_service.dart
    lib/core/utils/format_last_sync.dart
    lib/presentation/screens/profile/settings_screen.dart
  </files>
  <action>
    **0. Fix SyncStatusBadge color mapping (locked decision compliance):**
    The locked decision specifies: "amber/orange for 'failed, will retry' (retry count < 5) vs red for 'dead letter, needs manual action' (retry count >= 5)."
    The current code has these INVERTED: `syncFailed` = Red (0xFFEF4444), `deadLetter` = Colors.orange.

    In `lib/core/theme/app_colors.dart`:
    - Change `syncFailed` from `Color(0xFFEF4444)` (Red) to `Color(0xFFF59E0B)` (Amber -- same as syncPending for visual family, or use `Color(0xFFFF8C00)` for distinct dark amber/orange). Use `Color(0xFFFF8C00)` to distinguish from pending's amber.
    - Add a new constant: `static const Color syncDeadLetter = Color(0xFFEF4444);  // Red -- needs manual action`
    - Update the comment on `syncFailed` to: `// Amber/orange -- will retry`

    In `lib/presentation/widgets/common/sync_status_badge.dart`:
    - Change the `SyncStatus.deadLetter` case from `Colors.orange` to `AppColors.syncDeadLetter` (which is now red).
    - The `SyncStatus.failed` case already uses `AppColors.syncFailed` which is now amber/orange. No change needed there.

    Result after fix:
    - `SyncStatus.failed` -> `AppColors.syncFailed` = amber/orange (0xFFFF8C00) -- "will retry"
    - `SyncStatus.deadLetter` -> `AppColors.syncDeadLetter` = red (0xFFEF4444) -- "needs manual action"

    **1. SyncQueueLocalDataSource -- add watchAllItems():**
    In `sync_queue_local_data_source.dart`, add a new Stream method:
    ```dart
    /// Watch all sync queue items. Used by batch status provider to build
    /// a per-entity status map without N+1 queries.
    Stream<List<SyncQueueItem>> watchAllItems() {
      return (_db.select(_db.syncQueueItems)
            ..orderBy([(t) => OrderingTerm.desc(t.createdAt)]))
          .watch();
    }
    ```

    **2. AppSettingsService -- add getGlobalLastSyncAt():**
    In `app_settings_service.dart`, add a method that queries all `table_sync_at_*` keys and returns the maximum DateTime:
    ```dart
    /// Get the most recent sync timestamp across ALL synced tables.
    /// Returns null if no tables have been synced.
    Future<DateTime?> getGlobalLastSyncAt() async {
      final settings = await _db.select(_db.appSettings).get();
      DateTime? latest;
      for (final setting in settings) {
        if (setting.key.startsWith(_keyTableSyncPrefix)) {
          final dt = DateTime.tryParse(setting.value);
          if (dt != null && (latest == null || dt.isAfter(latest))) {
            latest = dt;
          }
        }
      }
      return latest;
    }
    ```

    **3. Shared formatLastSync utility:**
    Create `lib/core/utils/format_last_sync.dart` with the function currently private in `settings_screen.dart`:
    ```dart
    /// Format a last sync timestamp into a user-friendly Indonesian relative string.
    String formatLastSync(DateTime? lastSync) {
      if (lastSync == null) return 'Belum pernah sinkronisasi';
      final diff = DateTime.now().difference(lastSync);
      if (diff.inMinutes < 1) return 'Terakhir sinkronisasi: baru saja';
      if (diff.inMinutes < 60) {
        return 'Terakhir sinkronisasi: ${diff.inMinutes} menit lalu';
      }
      if (diff.inHours < 24) {
        return 'Terakhir sinkronisasi: ${diff.inHours} jam lalu';
      }
      return 'Terakhir sinkronisasi: ${diff.inDays} hari lalu';
    }
    ```
    Update `settings_screen.dart` to import and use the shared function, removing the private `_formatLastSync` function.

    **4. sync_providers.dart -- add SyncQueueEntityStatus enum and batch provider:**
    Add an enum at the top of the file (or just above the provider):
    ```dart
    /// Per-entity sync queue status for card badge display.
    /// Index order matters -- higher index = worse status (used for priority).
    enum SyncQueueEntityStatus {
      none,       // No queue entry (synced)
      pending,    // status == 'pending'
      failed,     // status == 'failed' (retryCount < 5)
      deadLetter, // status == 'dead_letter' (retryCount >= 5)
    }
    ```

    Add the batch stream provider:
    ```dart
    /// Batch provider for per-entity sync queue status.
    /// Watches the entire sync queue table (typically 0-50 items) and produces
    /// a Map<String, SyncQueueEntityStatus> keyed by entityId.
    /// Cards do O(1) lookups instead of N individual queries.
    final syncQueueEntityStatusMapProvider =
        StreamProvider<Map<String, SyncQueueEntityStatus>>((ref) {
      final syncQueueDataSource = ref.watch(syncQueueDataSourceProvider);
      return syncQueueDataSource.watchAllItems().map((items) {
        final map = <String, SyncQueueEntityStatus>{};
        for (final item in items) {
          final status = switch (item.status) {
            'dead_letter' => SyncQueueEntityStatus.deadLetter,
            'failed' => SyncQueueEntityStatus.failed,
            _ => SyncQueueEntityStatus.pending,
          };
          // Keep the worst status per entity (deadLetter > failed > pending)
          final existing = map[item.entityId];
          if (existing == null || status.index > existing.index) {
            map[item.entityId] = status;
          }
        }
        return map;
      });
    });
    ```

    **5. Update lastSyncTimestampProvider to use global max:**
    Replace the existing `lastSyncTimestampProvider` implementation:
    ```dart
    /// Provider for the last sync timestamp.
    /// Uses the maximum timestamp across ALL synced tables for accurate global staleness.
    final lastSyncTimestampProvider = FutureProvider<DateTime?>((ref) async {
      // Re-evaluate whenever sync state changes
      ref.watch(syncNotifierProvider);
      final appSettings = ref.watch(appSettingsServiceProvider);
      return appSettings.getGlobalLastSyncAt();
    });
    ```
    Remove the old comment about "customer sync timestamp as a proxy."
  </action>
  <verify>Run `flutter analyze` to confirm no errors. Verify that `syncQueueEntityStatusMapProvider` and `SyncQueueEntityStatus` are importable from sync_providers.dart. Verify `formatLastSync` import works in settings_screen.dart.</verify>
  <done>
    - `AppColors.syncFailed` is amber/orange (0xFFFF8C00) and `AppColors.syncDeadLetter` is red (0xFFEF4444)
    - `SyncStatusBadge` uses `AppColors.syncDeadLetter` for dead letter state (not `Colors.orange`)
    - `SyncQueueLocalDataSource.watchAllItems()` exists and returns `Stream<List<SyncQueueItem>>`
    - `AppSettingsService.getGlobalLastSyncAt()` exists and computes max across all `table_sync_at_*` keys
    - `syncQueueEntityStatusMapProvider` exists as a StreamProvider producing `Map<String, SyncQueueEntityStatus>`
    - `lastSyncTimestampProvider` uses `getGlobalLastSyncAt()` instead of customers-only proxy
    - `formatLastSync` is a shared top-level function in `lib/core/utils/format_last_sync.dart`
    - `settings_screen.dart` uses the shared `formatLastSync` function (no private copy)
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with no errors
2. OfflineBanner import exists only in `responsive_shell.dart` and `offline_banner.dart` itself (not in the 5 cleaned-up screens)
3. `syncQueueEntityStatusMapProvider` is defined and compiles
4. `lastSyncTimestampProvider` calls `getGlobalLastSyncAt()` instead of `getTableLastSyncAt('customers')`
5. `formatLastSync` is importable from `lib/core/utils/format_last_sync.dart`
</verification>

<success_criteria>
- OfflineBanner appears in all three ResponsiveShell layouts (mobile, tablet, desktop)
- All 5 per-screen OfflineBanner deployments are removed
- SyncStatus.failed renders amber/orange, SyncStatus.deadLetter renders red (per locked decision)
- Batch sync queue status provider infrastructure is ready for card badges
- Global last sync timestamp replaces customers-only proxy
- Shared formatLastSync utility extracted and used by settings screen
</success_criteria>

<output>
After completion, create `.planning/phases/07-offline-ux-polish/07-01-SUMMARY.md`
</output>
