# Testing Patterns

**Analysis Date:** 2026-02-13

## Test Framework

### Runner

**Framework:** `flutter_test` (built into Flutter SDK)

**Configuration:** Tests run via `flutter test` command

**Run Commands:**

```bash
# Run all tests in the project
flutter test

# Run a specific test file
flutter test test/data/repositories/customer_repository_impl_test.dart

# Run tests with coverage
flutter test --coverage

# Watch mode (re-run on changes)
dart run build_runner watch --delete-conflicting-outputs
# Then in another terminal:
flutter test --watch

# Run tests verbosely
flutter test -v

# Run tests matching a pattern
flutter test --name="CustomerRepository"
```

### Assertion Library

**Library:** `flutter_test` matchers (built-in)

**Key matchers used:**
- `expect(value, matcher)` - Standard assertion
- `findsOneWidget`, `findsNWidgets(n)`, `findsWidgets(n)` - Widget count matchers
- `findsNothing` - Widget not found
- `isNull`, `isNotNull` - Null checks
- `throwsException` - Exception thrown
- `hasLength(n)` - Collection length
- `contains(value)` - List contains
- `equals(value)` - Equality
- `TypeMatcher<T>()` - Type checking

**Example from `test/presentation/screens/customer/customers_tab_test.dart`:**
```dart
expect(find.text('Customer'), findsOneWidget);
expect(find.byIcon(Icons.search), findsOneWidget);
expect(find.byType(FloatingActionButton), findsOneWidget);
expect(find.text('Belum ada customer'), findsOneWidget);
expect(find.byType(CustomerCard), findsNWidgets(3));
```

## Test File Organization

### Location

**Pattern:** Mirror `lib/` structure

**Examples:**
- `lib/data/repositories/customer_repository_impl.dart` → `test/data/repositories/customer_repository_impl_test.dart`
- `lib/data/services/sync_service.dart` → `test/data/services/sync_service_test.dart`
- `lib/presentation/screens/auth/login_screen.dart` → `test/presentation/screens/auth/login_screen_test.dart`

### Naming

**Convention:** `{file}_test.dart`

**Location structure:**
```
test/
├── data/
│   ├── repositories/
│   │   ├── auth_repository_impl_test.dart
│   │   ├── auth_repository_impl_test.mocks.dart  (generated by mockito)
│   │   ├── customer_repository_impl_test.dart
│   │   └── customer_repository_impl_test.mocks.dart
│   └── services/
│       ├── sync_service_test.dart
│       └── sync_service_test.mocks.dart
├── integration/
│   ├── customer_flow_test.dart
│   ├── customer_flow_test.mocks.dart
│   ├── offline_sync_flow_test.dart
│   └── offline_sync_flow_test.mocks.dart
├── presentation/screens/
│   ├── auth/
│   │   ├── forgot_password_screen_test.dart
│   │   ├── login_screen_test.dart
│   │   └── reset_password_screen_test.dart
│   └── customer/
│       └── customers_tab_test.dart
└── helpers/
    ├── customer_test_helpers.dart
    ├── mock_sync_infrastructure.dart
    └── test_helpers.dart
```

## Test Structure

### Suite Organization

**Pattern:** `group()` with nested `test()` or `testWidgets()`

**File structure from `test/data/repositories/customer_repository_impl_test.dart`:**

```dart
void main() {
  late CustomerRepositoryImpl repository;
  late MockCustomerLocalDataSource mockLocalDataSource;
  late MockKeyPersonLocalDataSource mockKeyPersonLocalDataSource;
  // ... more mocks ...

  const testUserId = 'test-user-id';
  final testNow = DateTime(2026, 1, 21);

  // Helper functions for test data
  db.Customer createTestDbCustomer({...}) {
    return db.Customer(...);
  }

  CustomerCreateDto createTestDto({...}) {
    return CustomerCreateDto(...);
  }

  // Setup/Teardown
  setUp(() {
    mockLocalDataSource = MockCustomerLocalDataSource();
    // ... initialize all mocks ...
    repository = CustomerRepositoryImpl(
      localDataSource: mockLocalDataSource,
      // ... inject all mocks ...
    );
  });

  group('CustomerRepositoryImpl', () {
    group('getCustomerById', () {
      test('returns Customer when found', () async {
        // Arrange
        final testDbCustomer = createTestDbCustomer();
        when(mockLocalDataSource.getCustomerById('customer-1'))
            .thenAnswer((_) async => testDbCustomer);

        // Act
        final result = await repository.getCustomerById('customer-1');

        // Assert
        expect(result, isNotNull);
      });

      test('returns null when customer not found', () async {
        // Arrange
        when(mockLocalDataSource.getCustomerById('nonexistent'))
            .thenAnswer((_) async => null);

        // Act
        final result = await repository.getCustomerById('nonexistent');

        // Assert
        expect(result, isNull);
      });
    });

    group('createCustomer', () {
      test('creates customer and returns Right(customer)', () async {
        // Arrange
        final dto = createTestDto();
        when(mockLocalDataSource.insertCustomer(any))
            .thenAnswer((_) async => 1);

        // Act
        final result = await repository.createCustomer(dto);

        // Assert
        expect(result.isRight(), true);
        result.fold(
          (failure) => fail('Should return Right'),
          (customer) => expect(customer.name, dto.name),
        );
      });
    });
  });
}
```

### Patterns

**Setup Pattern:**
```dart
setUp(() {
  mockLocalDataSource = MockCustomerLocalDataSource();
  mockRemoteDataSource = MockCustomerRemoteDataSource();
  mockSyncService = MockSyncService();

  repository = CustomerRepositoryImpl(
    localDataSource: mockLocalDataSource,
    remoteDataSource: mockRemoteDataSource,
    syncService: mockSyncService,
    currentUserId: testUserId,
  );
});
```

**Teardown Pattern:**
```dart
tearDown(() {
  syncService.dispose();
  fakeConnectivityService.dispose();
});
```

**Async Assertion Pattern:**
```dart
test('async operation succeeds', () async {
  // Arrange
  when(mockDataSource.getData()).thenAnswer((_) async => data);

  // Act
  final result = await repository.fetchData();

  // Assert
  expect(result, data);
  verify(mockDataSource.getData()).called(1);
});
```

## Mocking

### Framework

**Library:** `mockito` (v5.4.4)

**Generator:** `build_runner` generates `.mocks.dart` files

**Command to generate mocks:**
```bash
dart run build_runner build --delete-conflicting-outputs
```

### Patterns

**Annotation pattern from `test/data/repositories/customer_repository_impl_test.dart`:**
```dart
@GenerateMocks([
  CustomerLocalDataSource,
  KeyPersonLocalDataSource,
  CustomerRemoteDataSource,
  KeyPersonRemoteDataSource,
  SyncService,
])
import 'customer_repository_impl_test.mocks.dart';
```

**Setup stubbing:**
```dart
// Return a single value
when(mockLocalDataSource.getCustomerById('customer-1'))
    .thenReturn(testCustomer);

// Return asynchronously
when(mockLocalDataSource.getCustomerById('customer-1'))
    .thenAnswer((_) async => testCustomer);

// Return multiple values in sequence
when(mockLocalDataSource.getCustomerCount())
    .thenAnswer((_) async => 10);

// Throw an exception
when(mockLocalDataSource.getCustomerById('error'))
    .thenThrow(DatabaseException(...));

// Return Stream
when(mockLocalDataSource.watchAllCustomers())
    .thenAnswer((_) => Stream.value([testCustomer]));
```

**Verification pattern:**
```dart
// Verify called exactly once
verify(mockLocalDataSource.getCustomerById('customer-1')).called(1);

// Verify called any number of times
verify(mockLocalDataSource.insertCustomer(any)).called(greaterThan(0));

// Verify never called
verifyNever(mockRemoteDataSource.createCustomer(any));

// Verify in order
verifyInOrder([
  mockLocalDataSource.getCustomerById(any),
  mockSyncService.queueOperation(any),
]);
```

### What to Mock

**Always mock:**
- External services (Supabase, HTTP clients)
- Database operations (use mocks, not real Drift)
- Repositories when testing layers above them
- Async operations and streams

**Example from `test/helpers/customer_test_helpers.dart` - Fake implementation:**
```dart
class FakeCustomerRepository implements CustomerRepository {
  final _customersController = StreamController<List<Customer>>.broadcast();
  List<Customer> _customers = [];
  bool shouldCreateSucceed = true;

  void setCustomers(List<Customer> customers) {
    _customers = customers;
    _customersController.add(customers);
  }

  @override
  Stream<List<Customer>> watchAllCustomers() {
    return Stream.multi((controller) {
      controller.add(_customers);
      final subscription = _customersController.stream.listen(
        controller.add,
        onError: controller.addError,
        onDone: controller.close,
      );
      controller.onCancel = subscription.cancel;
    });
  }

  @override
  Future<Either<Failure, Customer>> createCustomer(CustomerCreateDto dto) async {
    if (!shouldCreateSucceed) {
      return Left(DatabaseFailure(message: errorMessage ?? 'Failed'));
    }
    final customer = createTestCustomer(name: dto.name);
    addCustomer(customer);
    return Right(customer);
  }
}
```

### What NOT to Mock

**Avoid mocking:**
- Simple utility functions
- Constants and configurations
- Pure functions without side effects
- Value objects (use real instances)
- Freezed/immutable models (use factory functions)

**Use real instances for:** DTOs, entities, simple value holders

## Fixtures and Factories

### Test Data Pattern

**Location:** `test/helpers/`

**File:** `test/helpers/customer_test_helpers.dart` (672 lines)

**Factory functions for creating test entities:**

```dart
/// Creates a test customer with customizable properties.
Customer createTestCustomer({
  String? id,
  String? code,
  String name = 'Test Customer',
  String address = 'Test Address',
  String provinceId = 'province-1',
  String cityId = 'city-1',
  String companyTypeId = 'company-type-1',
  String ownershipTypeId = 'ownership-type-1',
  String industryId = 'industry-1',
  String assignedRmId = 'rm-1',
  String? phone,
  String? email,
  double? latitude,
  double? longitude,
  bool isActive = true,
  bool isPendingSync = false,
  String? provinceName,
  String? cityName,
  String? companyTypeName,
  String? ownershipTypeName,
  String? industryName,
}) {
  final timestamp = DateTime.now().millisecondsSinceEpoch;
  return Customer(
    id: id ?? 'customer-$timestamp',
    code: code ?? 'CUST-$timestamp',
    name: name,
    address: address,
    provinceId: provinceId,
    cityId: cityId,
    companyTypeId: companyTypeId,
    ownershipTypeId: ownershipTypeId,
    industryId: industryId,
    assignedRmId: assignedRmId,
    createdBy: 'test-user',
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    phone: phone,
    email: email,
    latitude: latitude,
    longitude: longitude,
    isActive: isActive,
    isPendingSync: isPendingSync,
    provinceName: provinceName ?? 'Test Province',
    cityName: cityName ?? 'Test City',
    companyTypeName: companyTypeName ?? 'PT',
    ownershipTypeName: ownershipTypeName ?? 'Swasta',
    industryName: industryName ?? 'Manufacturing',
  );
}
```

**Master data factories:**

```dart
/// Creates test provinces.
List<ProvinceDto> createTestProvinces() {
  return [
    const ProvinceDto(id: 'province-1', code: 'JKT', name: 'DKI Jakarta', isActive: true),
    const ProvinceDto(id: 'province-2', code: 'JBR', name: 'Jawa Barat', isActive: true),
    const ProvinceDto(id: 'province-3', code: 'JTG', name: 'Jawa Tengah', isActive: true),
  ];
}

/// Creates test cities for a province.
List<CityDto> createTestCities({String? provinceId}) {
  final pId = provinceId ?? 'province-1';
  return [
    CityDto(id: 'city-1', code: 'JKP', name: 'Jakarta Pusat', provinceId: pId, isActive: true),
    CityDto(id: 'city-2', code: 'JKS', name: 'Jakarta Selatan', provinceId: pId, isActive: true),
  ];
}
```

**Fake implementation factories:**

```dart
/// Creates a [ProviderScope] configured for customer testing.
Widget createCustomerTestApp({
  required Widget child,
  FakeCustomerRepository? fakeCustomerRepository,
  FakeGpsService? fakeGpsService,
  List<Customer>? initialCustomers,
  List<ProvinceDto>? provinces,
  List<CityDto>? cities,
  List<CompanyTypeDto>? companyTypes,
  List<OwnershipTypeDto>? ownershipTypes,
  List<IndustryDto>? industries,
  Customer? existingCustomer,
  bool? shouldCreateSucceed,
  bool? shouldUpdateSucceed,
  String? errorMessage,
  List<Override> additionalOverrides = const [],
}) {
  final customerRepo = fakeCustomerRepository ?? FakeCustomerRepository();
  final gpsService = fakeGpsService ?? FakeGpsService();

  // Configure fake repository
  if (shouldCreateSucceed != null) {
    customerRepo.shouldCreateSucceed = shouldCreateSucceed;
  }
  if (shouldUpdateSucceed != null) {
    customerRepo.shouldUpdateSucceed = shouldUpdateSucceed;
  }

  return ProviderScope(
    overrides: [
      customerRepositoryProvider.overrideWithValue(customerRepo),
      customerListStreamProvider.overrideWith((ref) {
        return customerRepo.watchAllCustomers();
      }),
      gpsServiceProvider.overrideWithValue(gpsService),
      // ... more overrides ...
    ],
    child: MaterialApp(
      home: child,
    ),
  );
}
```

## Coverage

### Requirements

**Enforcement:** Not explicitly enforced in CI/CD

**Target:** Aim for >80% coverage on critical paths (repositories, services)

### View Coverage

**Command:**
```bash
flutter test --coverage

# Generate HTML report (requires lcov)
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html
```

**Coverage file:** `coverage/lcov.info` (generated after test run)

## Test Types

### Unit Tests

**Scope:** Test a single function/class in isolation

**Dependencies:** Fully mocked

**Location:** `test/data/repositories/`, `test/data/services/`

**Example from `test/data/repositories/customer_repository_impl_test.dart`:**
```dart
group('CustomerRepositoryImpl', () {
  group('getCustomerById', () {
    test('returns Customer when found', () async {
      // Arrange
      final testDbCustomer = createTestDbCustomer();
      when(mockLocalDataSource.getCustomerById('customer-1'))
          .thenAnswer((_) async => testDbCustomer);

      // Act
      final result = await repository.getCustomerById('customer-1');

      // Assert
      expect(result, isNotNull);
      verify(mockLocalDataSource.getCustomerById('customer-1')).called(1);
    });
  });
});
```

### Integration Tests

**Scope:** Test multiple components working together

**Dependencies:** May use real implementations for some layers, mocks for external services

**Location:** `test/integration/`

**Pattern from `test/integration/customer_flow_test.dart`:**
```dart
void main() {
  late CustomerRepositoryImpl repository;
  late MockCustomerLocalDataSource mockLocalDataSource;
  late TrackingSyncQueueDataSource trackingQueueDataSource;
  late FakeConnectivityService fakeConnectivityService;
  late SyncService syncService;

  setUp(() {
    mockLocalDataSource = MockCustomerLocalDataSource();
    trackingQueueDataSource = TrackingSyncQueueDataSource();
    fakeConnectivityService = FakeConnectivityService();

    syncService = SyncService(
      syncQueueDataSource: trackingQueueDataSource,
      connectivityService: fakeConnectivityService,
      // ...
    );

    repository = CustomerRepositoryImpl(
      localDataSource: mockLocalDataSource,
      syncService: syncService,
      // ...
    );
  });

  group('Customer Flow Integration Tests', () {
    group('Create Customer Flow', () {
      test('creating a customer queues for sync', () async {
        // Arrange
        final dto = CustomerCreateDto(...);
        when(mockLocalDataSource.insertCustomer(any))
            .thenAnswer((_) async => 1);

        // Act
        final result = await repository.createCustomer(dto);

        // Assert
        expect(result.isRight(), true);
        expect(trackingQueueDataSource.items.length, 1);
        expect(trackingQueueDataSource.items.first.entityType, 'customer');
      });

      test('creating a customer succeeds even when offline', () async {
        // Arrange
        fakeConnectivityService.setConnected(false);

        // Act
        final result = await repository.createCustomer(dto);

        // Assert - should still succeed (offline-first)
        expect(result.isRight(), true);
      });
    });
  });
}
```

### Widget Tests

**Scope:** Test UI widgets and their interactions

**Dependencies:** Mocked repositories and services

**Location:** `test/presentation/screens/`

**Pattern from `test/presentation/screens/customer/customers_tab_test.dart`:**
```dart
void main() {
  late FakeCustomerRepository fakeCustomerRepo;

  setUp(() {
    fakeCustomerRepo = FakeCustomerRepository();
  });

  tearDown(() {
    fakeCustomerRepo.dispose();
  });

  group('CustomersTab', () {
    group('Initial Rendering', () {
      testWidgets('renders app bar with title "Customer"', (tester) async {
        await tester.pumpWidget(
          createCustomerTestApp(
            child: const CustomersTab(),
            fakeCustomerRepository: fakeCustomerRepo,
            initialCustomers: [],
          ),
        );
        await tester.pumpAndSettle();

        expect(find.text('Customer'), findsOneWidget);
      });
    });

    group('Empty State', () {
      testWidgets('shows empty state when no customers exist', (tester) async {
        await tester.pumpWidget(
          createCustomerTestApp(
            child: const CustomersTab(),
            fakeCustomerRepository: fakeCustomerRepo,
            initialCustomers: [],
          ),
        );
        await tester.pumpAndSettle();

        expect(find.text('Belum ada customer'), findsOneWidget);
      });
    });

    group('Customer List', () {
      testWidgets('renders CustomerCard for each customer', (tester) async {
        final customers = [
          createTestCustomer(id: 'c1', name: 'Customer 1'),
          createTestCustomer(id: 'c2', name: 'Customer 2'),
          createTestCustomer(id: 'c3', name: 'Customer 3'),
        ];

        await tester.pumpWidget(
          createCustomerTestApp(
            child: const CustomersTab(),
            initialCustomers: customers,
          ),
        );
        await tester.pumpAndSettle();

        expect(find.byType(CustomerCard), findsNWidgets(3));
      });
    });
  });
}
```

**Key Widget Testing Patterns:**

```dart
// Pump widget into test
await tester.pumpWidget(widget);

// Wait for async operations to complete
await tester.pumpAndSettle();
await tester.pumpAndSettle(Duration(seconds: 5));

// Find widgets
find.text('Text');
find.byType(WidgetType);
find.byKey(Key('key'));
find.byIcon(Icons.icon);
find.byTooltip('Tooltip');

// Interact with widgets
await tester.tap(find.byType(Button));
await tester.enterText(find.byType(TextField), 'text');
await tester.drag(find.byType(Scrollable), Offset(0, -500));

// Test gestures
await tester.longPress(find.byType(Widget));
await tester.multiDrag(find.byType(Widget), [Offset(0, 100)]);
```

### E2E Tests

**Status:** Not currently implemented

**Recommendation:** Use Flutter Driver or Patrol for E2E testing

**See:** TESTING_SUMMARY.md for detailed analysis

## Common Patterns

### Async Testing

**Pattern from `test/data/repositories/customer_repository_impl_test.dart`:**

```dart
test('returns Customer when found', () async {
  // Arrange
  when(mockLocalDataSource.getCustomerById('customer-1'))
      .thenAnswer((_) async => testDbCustomer);

  // Act
  final result = await repository.getCustomerById('customer-1');

  // Assert
  expect(result, isNotNull);
});

test('handles errors correctly', () async {
  // Arrange
  when(mockLocalDataSource.getCustomerById('error'))
      .thenThrow(DatabaseException(message: 'DB error'));

  // Act
  final result = await repository.getCustomerById('error');

  // Assert
  expect(result.isLeft(), true);
  result.fold(
    (failure) => expect(failure.message, contains('error')),
    (_) => fail('Should return Left'),
  );
});
```

### Stream Testing

**Pattern for Drift streams:**

```dart
test('watches customers returns stream of updates', () async {
  // Arrange
  final customers = [createTestCustomer()];
  when(mockLocalDataSource.watchAllCustomers())
      .thenAnswer((_) => Stream.value(customers));

  // Act
  final stream = repository.watchAllCustomers();

  // Assert
  expect(stream, emitsInOrder([
    customers,
    // ... other emissions
    emitsDone,
  ]));
});
```

### Error Testing

**Pattern using Either type:**

```dart
test('createCustomer returns Left(DatabaseFailure) on error', () async {
  // Arrange
  when(mockLocalDataSource.insertCustomer(any))
      .thenThrow(Exception('DB error'));

  // Act
  final result = await repository.createCustomer(createTestDto());

  // Assert
  expect(result.isLeft(), true);
  result.fold(
    (failure) {
      expect(failure, isA<DatabaseFailure>());
      expect(failure.message, contains('Failed to create customer'));
    },
    (_) => fail('Should return Left'),
  );
});
```

### Setup/Teardown for State

**Pattern from `test/helpers/customer_test_helpers.dart`:**

```dart
class FakeCustomerRepository implements CustomerRepository {
  // Control test behavior
  bool shouldCreateSucceed = true;
  bool shouldUpdateSucceed = true;
  bool shouldDeleteSucceed = true;
  String? errorMessage;

  // Track mutations
  CustomerCreateDto? lastCreatedCustomerDto;
  CustomerUpdateDto? lastUpdatedCustomerDto;
  String? lastUpdatedCustomerId;
  String? lastDeletedCustomerId;

  // Test assertions
  void expectCreated(CustomerCreateDto dto) {
    expect(lastCreatedCustomerDto, dto);
  }

  void expectUpdated(String id, CustomerUpdateDto dto) {
    expect(lastUpdatedCustomerId, id);
    expect(lastUpdatedCustomerDto, dto);
  }
}
```

---

*Testing analysis: 2026-02-13*
